<!DOCTYPE html><html><head hexo-theme="https://volantis.js.org/#2.6.3"><meta charset="utf-8"><meta name="renderer" content="webkit"><meta name="force-rendering" content="webkit"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="HandheldFriendly" content="True"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><title>load initialize的本质 - ticsmatic</title><meta name="description" content="学习MJ的视频课程，整理总结知识点–load initialize的本质这一篇通过+load和+initialize的官方文档并结合Demo来介绍这两个方法。同时会依据runtime源码来介绍+load和+initialize底层的逻辑。"><link rel="alternate" href="/atom.xml" title="ticsmatic"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css"><link rel="shortcut icon" type="image/x-icon" href="https://cdn.ticsmatic.com/img/favicon.png"><link rel="stylesheet" href="/css/style.css"><script>function setLoadingBarProgress(e){document.getElementById("loading-bar").style.width=e+"%"}</script></head><body><div id="loading-bar-wrapper"><div id="loading-bar"></div></div><header class="l_header shadow blur"><div class="container"><div class="wrapper"><div class="nav-sub"><p class="title"></p><ul class="switcher nav-list-h"><li><a class="s-comment fas fa-comments fa-fw" target="_self" href="javascript:void(0)"></a></li><li><a class="s-toc fas fa-list fa-fw" target="_self" href="javascript:void(0)"></a></li></ul></div><div class="nav-main"><a class="title flat-box" target="_self" href="/">ticsmatic</a><div class="menu navigation"><ul class="nav-list-h"><li><a class="flat-box" href="/" id="home"><i class="fas fa-rss fa-fw"></i>博文</a></li><li><a class="flat-box" href="/archives/" id="archives"><i class="fas fa-archive fa-fw"></i>归档</a></li><li><a class="flat-box" href="/categories/" id="categories"><i class="fas fa-folder-open fa-fw"></i>分类</a></li><li><a class="flat-box" href="/tags/" id="tags"><i class="fas fa-tags fa-fw"></i>标签</a></li><li><a class="flat-box" href="/about/" id="about"><i class="fas fa-info-circle fa-fw"></i>关于</a></li></ul></div><div class="m_search"><form name="searchform" class="form u-search-form"><i class="icon fas fa-search fa-fw"></i> <input type="text" class="input u-search-input" placeholder="Search..."></form></div><ul class="switcher nav-list-h"><li><a class="s-search fas fa-search fa-fw" target="_self" href="javascript:void(0)"></a></li><li><a class="s-menu fas fa-bars fa-fw" target="_self" href="javascript:void(0)"></a><ul class="menu-phone list-v navigation white-box"><li><a class="flat-box" href="/" id="home"><i class="fas fa-rss fa-fw"></i>博文</a></li><li><a class="flat-box" href="/archives/" id="archives"><i class="fas fa-archive fa-fw"></i>归档</a></li><li><a class="flat-box" href="/categories/" id="categories"><i class="fas fa-folder-open fa-fw"></i>分类</a></li><li><a class="flat-box" href="/tags/" id="tags"><i class="fas fa-tags fa-fw"></i>标签</a></li><li><a class="flat-box" href="/about/" id="about"><i class="fas fa-info-circle fa-fw"></i>关于</a></li></ul></li></ul></div></div></div></header><script>setLoadingBarProgress(40)</script><div class="l_body nocover"><div class="body-wrapper"><div class="l_main"><article id="post" class="post white-box shadow article-type-post" itemscope itemprop="blogPost"><section class="meta"><div class="meta" id="header-meta"><h1 class="title"><a href="/p/4235a91d/">load initialize的本质</a></h1><div class="new-meta-box"><div class="new-meta-item date"><a class="notlink"><i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i><p>2020-05-07</p></a></div><div class="new-meta-item browse busuanzi"><a class="notlink"><i class="fas fa-eye fa-fw" aria-hidden="true"></i><p><span id="busuanzi_value_page_pv"><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span></p></a></div></div><hr></div></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><p>学习MJ的视频课程，整理总结知识点–load initialize的本质</p><p>这一篇通过<code>+load</code>和<code>+initialize</code>的官方文档并结合Demo来介绍这两个方法。同时会依据runtime源码来介绍<code>+load</code>和<code>+initialize</code>底层的逻辑。</p><a id="more"></a><p>[TOC]</p><h2 id="load介绍"><a href="#load介绍" class="headerlink" title="+load介绍"></a>+load介绍</h2><p>关于<code>+load</code>，我们知道<strong>+load方法会在runtime加载类、分类时调用</strong>，apple文档中关于load介绍如下</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Summary</span><br><span class="line"></span><br><span class="line">Invoked whenever a <span class="keyword">class</span> or category is added to the Objective-C runtime; implement <span class="keyword">this</span> method to perform <span class="keyword">class</span>-specific behavior upon loading.</span><br><span class="line"></span><br><span class="line">Declaration</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load;</span><br><span class="line">Discussion</span><br><span class="line"></span><br><span class="line">The load message is sent to classes and categories that are both dynamically loaded and statically linked, but only <span class="keyword">if</span> the newly loaded <span class="keyword">class</span> or category implements a method that can respond.</span><br><span class="line">The order of initialization is as follows:</span><br><span class="line">All initializers <span class="keyword">in</span> any framework you link to.</span><br><span class="line">All +load methods <span class="keyword">in</span> your image.</span><br><span class="line">All C++ <span class="keyword">static</span> initializers and C/C++ __attribute__(constructor) functions <span class="keyword">in</span> your image.</span><br><span class="line">All initializers <span class="keyword">in</span> frameworks that link to you.</span><br><span class="line"></span><br><span class="line">In addition:</span><br><span class="line">A <span class="keyword">class</span>’s +load method is called after all of its superclasses’ +load methods.</span><br><span class="line">A category +load method is called after the <span class="keyword">class</span>’s own +load method.</span><br><span class="line">In a custom implementation of load you can therefore safely message other unrelated classes from the same image, but any load methods implemented by those classes may not have run yet.</span><br><span class="line"></span><br><span class="line">Important</span><br><span class="line">Custom implementations of the load method <span class="keyword">for</span> Swift classes bridged to Objective-C are not called automatically.</span><br></pre></td></tr></table></figure><p>结合文档我们知道</p><ol><li>+load方法会在runtime加载类、分类时调用</li><li>每个类、分类的+load，在程序运行过程中只调用一次</li><li>先调用类的+load，再调用分类的+load</li><li>调用子类的+load之前会先调用父类的+load</li></ol><h2 id="load调用原理"><a href="#load调用原理" class="headerlink" title="+load调用原理"></a>+load调用原理</h2><p>我们知道<code>+load</code>是在runtime添加到运行时的时候调用，所以我们可以从runtime源码入手，查找并分析<code>+load</code>的调用原理</p><p>结合上一篇文章，我们知道runtime的初始化方法是<code>_objc_init</code>，这个函数内部有这个方法<code>_dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</code>，其中，<code>load_images</code><br>就是我们剖析<code>+load</code>机制的入口。我们看一下<code>load_images</code>函数的源码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* load_images</span></span><br><span class="line"><span class="comment">* Process +load in the given images which are being mapped in by dyld.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Locking: write-locks runtimeLock and loadMethodLock</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">load_images(<span class="keyword">const</span> <span class="keyword">char</span> *path __unused, <span class="keyword">const</span> <span class="keyword">struct</span> mach_header *mh)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Return without taking locks if there are no +load methods here.</span></span><br><span class="line">    <span class="keyword">if</span> (!hasLoadMethods((<span class="keyword">const</span> headerType *)mh)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    recursive_mutex_locker_t lock(loadMethodLock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Discover load methods</span></span><br><span class="line">    &#123;</span><br><span class="line">        rwlock_writer_t lock2(runtimeLock);</span><br><span class="line">        prepare_load_methods((<span class="keyword">const</span> headerType *)mh);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call +load methods (without runtimeLock - re-entrant)</span></span><br><span class="line">    call_load_methods();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数内部主要分3步（<strong>判断、查找并添加、调用</strong>），我们对这3个步骤用通俗易懂的语言进行概述：</p><ol><li>判断有没有<code>+load</code>方法，没有的话直接return；</li><li>有的话就添加到一个数据保存起来；</li><li>遍历这个数据，调用每个元素的<code>+load</code>方法。</li></ol><p>下面进行每一步的介绍。</p><h3 id="1-hasLoadMethods"><a href="#1-hasLoadMethods" class="headerlink" title="1. hasLoadMethods"></a>1. hasLoadMethods</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Quick scan for +load methods that doesn't take a lock.</span></span><br><span class="line"><span class="keyword">bool</span> hasLoadMethods(<span class="keyword">const</span> headerType *mhdr)</span><br><span class="line">&#123;</span><br><span class="line">    size_t count;</span><br><span class="line">    <span class="keyword">if</span> (_getObjc2NonlazyClassList(mhdr, &amp;count)  &amp;&amp;  count &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (_getObjc2NonlazyCategoryList(mhdr, &amp;count)  &amp;&amp;  count &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数概述为就是快速查找所有的class、category里面是否包含<code>+load</code>方法。<br>(注：实现了<code>+load</code>方法的class才属于<code>NonlazyClass</code>)</p><h3 id="2-prepare-load-methods"><a href="#2-prepare-load-methods" class="headerlink" title="2. prepare_load_methods"></a>2. prepare_load_methods</h3><p>判断完之后就是查找所有的<code>+load</code>方法，<code>prepare_load_methods</code>函数的主要代码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> prepare_load_methods(<span class="keyword">const</span> headerType *mhdr)</span><br><span class="line">&#123;</span><br><span class="line">    size_t count, i;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertWriting();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历有+load的class，添加到'loadable_classes'中(有superclass的，先递归添加superclass)，把class标记为'RW_LOADED'</span></span><br><span class="line">    classref_t *classlist = </span><br><span class="line">        _getObjc2NonlazyClassList(mhdr, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        schedule_class_load(remapClass(classlist[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历有+load的category，做一些逻辑判断，然后添加到'loadable_categories'</span></span><br><span class="line">    category_t **categorylist = _getObjc2NonlazyCategoryList(mhdr, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        category_t *cat = categorylist[i];</span><br><span class="line">        Class cls = remapClass(cat-&gt;cls);</span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>;  <span class="comment">// category for ignored weak-linked class</span></span><br><span class="line">        realizeClass(cls);</span><br><span class="line">        assert(cls-&gt;ISA()-&gt;isRealized());</span><br><span class="line">        add_category_to_loadable_list(cat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个过程把包含有<code>+load</code>方法的class添加到数组<code>loadable_classes</code>中，把包含有<code>+load</code>方法的category添加到数组<code>loadable_categories</code>中。</p><p><code>prepare_load_methods</code>过程中，内部有一个<code>schedule_class_load</code>方法需要讲解一下，它的实现如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* prepare_load_methods</span></span><br><span class="line"><span class="comment">* Schedule +load for classes in this image, any un-+load-ed </span></span><br><span class="line"><span class="comment">* superclasses in other images, and any categories in this image.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="comment">// Recursively schedule +load for cls and any un-+load-ed superclasses.</span></span><br><span class="line"><span class="comment">// cls must already be connected.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> schedule_class_load(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span>;</span><br><span class="line">    assert(cls-&gt;isRealized());  <span class="comment">// _read_images should realize</span></span><br><span class="line">    <span class="comment">// 判断class结构体信息中是否加载的标记</span></span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;data()-&gt;flags &amp; RW_LOADED) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ensure superclass-first ordering，通过递归的方式先取出superclass</span></span><br><span class="line">    schedule_class_load(cls-&gt;superclass);</span><br><span class="line">    <span class="comment">// 添加到数组中保存起来</span></span><br><span class="line">    add_class_to_loadable_list(cls);</span><br><span class="line">    <span class="comment">// cls标记为已加载</span></span><br><span class="line">    cls-&gt;setInfo(RW_LOADED); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数内部有个递归调用，先去class的superclass添加到数组中，这就解释了<strong>子类<code>+load</code>方法调用时，会先调用父类的<code>+load</code>这一现象</strong>。</p><h3 id="3-call-load-methods"><a href="#3-call-load-methods" class="headerlink" title="3. call_load_methods"></a>3. call_load_methods</h3><p>添加到<code>loadable_classes</code>数组和数组<code>loadable_categories</code>后，就是遍历数组，调用数组元素的<code>+load</code>方法。函数主要内容如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* call_load_methods</span></span><br><span class="line"><span class="comment">* Call all pending class and category +load methods.</span></span><br><span class="line"><span class="comment">* Class +load methods are called superclass-first. </span></span><br><span class="line"><span class="comment">* Category +load methods are not called until after the parent class's +load.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="keyword">void</span> call_load_methods(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> loading = <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">bool</span> more_categories;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Re-entrant calls do nothing; the outermost call will finish the job.</span></span><br><span class="line">    <span class="keyword">if</span> (loading) <span class="keyword">return</span>;</span><br><span class="line">    loading = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *pool = objc_autoreleasePoolPush();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 1. Repeatedly call class +loads until there aren't any more</span></span><br><span class="line">        <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            call_class_loads();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. Call category +loads ONCE</span></span><br><span class="line">        more_categories = call_category_loads();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. Run more +loads if there are classes OR more untried categories</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>  ||  more_categories);</span><br><span class="line"></span><br><span class="line">    objc_autoreleasePoolPop(pool);</span><br><span class="line"></span><br><span class="line">    loading = <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察<code>call_load_methods</code>函数的实现我们得知，内部<strong>会先调用class的<code>+load</code>方法，之后才会调用category的<code>+load</code>方法</strong>。</p><p>接下来看下runtime是怎么自动调用<code>+load</code>方法的，在<code>call_class_loads</code>函数内部我们可以找到答案，<code>call_class_loads</code>的概要源码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> call_class_loads(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Detach current loadable list.</span></span><br><span class="line">    <span class="keyword">struct</span> loadable_class *classes = loadable_classes;</span><br><span class="line">    <span class="keyword">int</span> used = loadable_classes_used;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; used; i++) &#123;</span><br><span class="line">          <span class="comment">// 取出class</span></span><br><span class="line">        Class cls = classes[i].cls;</span><br><span class="line">        <span class="comment">// 拿到保存的'+load'方法</span></span><br><span class="line">        load_method_t load_method = (load_method_t)classes[i].method;</span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 直接手动调用'+load'方法</span></span><br><span class="line">        (*load_method)(cls, SEL_load);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Destroy the detached list.</span></span><br><span class="line">    <span class="keyword">if</span> (classes) free(classes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以我们可以得知，<strong><code>+load</code>方法是默认通过函数地址直接调用，而不是通过OC通用的runtime消息机制</strong></p><h2 id="load总结"><a href="#load总结" class="headerlink" title="+load总结"></a>+load总结</h2><ol><li>+load方法会在runtime加载类、分类时调用</li><li>每个类、分类的+load，在程序运行过程中只调用一次</li><li>调用顺序<ul><li>先调用类的+load<ul><li>按照编译先后顺序调用（先编译，先调用）</li><li>调用子类的+load之前会先调用父类的+load</li></ul></li><li>再调用分类的+load<ul><li>按照编译先后顺序调用（先编译，先调用）</li></ul></li></ul></li></ol><h2 id="initialize介绍"><a href="#initialize介绍" class="headerlink" title="+initialize介绍"></a>+initialize介绍</h2><p>关于<code>+initialize</code>，我们知道<strong>+initialize方法会在类第一次接收到消息时调用</strong>，apple文档中关于initialize介绍如下</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Summary</span><br><span class="line"></span><br><span class="line">Initializes the <span class="keyword">class</span> before it receives its first message.</span><br><span class="line"></span><br><span class="line">Declaration</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)initialize;</span><br><span class="line"></span><br><span class="line">Discussion</span><br><span class="line"></span><br><span class="line">The runtime sends initialize to each <span class="keyword">class</span> <span class="keyword">in</span> a program just before the <span class="keyword">class</span>, or any <span class="keyword">class</span> that inherits from it, is sent its first message from within the program. Superclasses receive <span class="keyword">this</span> message before their subclasses.</span><br><span class="line">The runtime sends the initialize message to classes <span class="keyword">in</span> a thread-safe manner. That is, initialize is run by the first thread to send a message to a <span class="keyword">class</span>, and any other thread that tries to send a message to that <span class="keyword">class</span> will block until initialize completes.</span><br><span class="line">The superclass implementation may be called multiple times <span class="keyword">if</span> subclasses <span class="keyword">do</span> not implement initialize—the runtime will call the inherited implementation—or <span class="keyword">if</span> subclasses explicitly call [<span class="keyword">super</span> initialize]. If you want to protect yourself from being run multiple times, you can structure your implementation along these lines:</span><br><span class="line">+ (<span class="keyword">void</span>)initialize &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">self</span> == [ClassName <span class="keyword">self</span>]) &#123;</span><br><span class="line">    <span class="comment">// ... do the initialization ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Because initialize is called <span class="keyword">in</span> a blocking manner, it’s important to limit method implementations to the minimum amount of work necessary possible. Specifically, any code that takes locks that might be required by other classes <span class="keyword">in</span> their initialize methods is liable to lead to deadlocks. Therefore, you should not rely on initialize <span class="keyword">for</span> complex initialization, and should instead limit it to straightforward, <span class="keyword">class</span> local initialization.</span><br></pre></td></tr></table></figure><p>结合文档和之前的知识我们知道</p><ol><li>+initialize方法会在类第一次接收到消息时调用</li><li>先调用父类的+initialize，再调用子类的+initialize</li><li>(先初始化父类，再初始化子类，每个类只会初始化1次)</li><li>+initialize方法是线程安全的，要注意防止+initialize死锁，不要再+initialize内做太复杂的事情</li></ol><h2 id="initialize原理"><a href="#initialize原理" class="headerlink" title="+initialize原理"></a>+initialize原理</h2><p>我们知道了<code>+initialize</code>的特性，接下来我们通过runtime源码分析<code>+initialize</code>的原理。我们已经知道<code>+initialize</code>是第一次接收到消息时调用，我们以此为切入点进行分析。</p><p><code>第一次接收到消息</code>，意味着第一次<code>objc_msgSend(cls, @selector(xxx))</code>，怎么知道是第一次呢，猜测应该是在<code>objc_msgSend</code>前先进行判断有没有<code>initialize</code>标记，没有的话先调用<code>+initialize</code>，然后再继续原有流程。</p><p>还有一个查找源码的切入点是<code>+initialize</code>调用之后的<strong>标记值</strong>，因为我们已经知道一个class只会<code>initialize</code>一次，<code>+load</code>也是只会调用一次。同时在前面学习<code>+load</code>调用流程时从源码中知道，load完成时会有一步做标记<code>cls-&gt;setInfo(RW_LOADED);</code>，我们猜测：<code>+initialize</code>也会有类似的标记，仿照格式应该为<code>RW_INITIALIZED</code>。我们去runtime源码中搜索，果真找到这个<code>RW_INITIALIZED</code>，它对应的函数如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> isInitialized() &#123;</span><br><span class="line">    <span class="keyword">return</span> getMeta()-&gt;data()-&gt;flags &amp; RW_INITIALIZED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过我们的目的是分析什么时候调用<code>+initialize</code>，已经知道了这个<code>initialize</code>前的判断方法<code>isInitialized()</code>，我们就可以<code>顺瓜摸藤</code>，通过在objc源码中搜索<code>isInitialized()</code>这个方法，同时知道这个方法应该在<code>objc_msgSend</code>前调用，所以我们可以进一步缩小搜索范围。</p><p>通过分析搜索结果，我们几乎可以确定唯一与结果相关的就是<code>lookUpImpOrForward</code>函数，该函数概要内容如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* lookUpImpOrForward.</span></span><br><span class="line"><span class="comment">* The standard IMP lookup. </span></span><br><span class="line"><span class="comment">* initialize==NO tries to avoid +initialize (but sometimes fails)</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line">IMP lookUpImpOrForward(Class cls, SEL sel, <span class="keyword">id</span> inst, </span><br><span class="line">                       <span class="keyword">bool</span> initialize, <span class="keyword">bool</span> cache, <span class="keyword">bool</span> resolver)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialize  &amp;&amp;  !cls-&gt;isInitialized()) &#123;</span><br><span class="line">        runtimeLock.unlockRead();</span><br><span class="line">        _class_initialize (_class_getNonMetaClass(cls, inst));</span><br><span class="line">        runtimeLock.read();</span><br><span class="line">        <span class="comment">// If sel == initialize, _class_initialize will send +initialize and </span></span><br><span class="line">        <span class="comment">// then the messenger will send +initialize again after this </span></span><br><span class="line">        <span class="comment">// procedure finishes. Of course, if this is not being called </span></span><br><span class="line">        <span class="comment">// from the messenger then it won't happen. 2778172</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数内部有个逻辑，就是判断有没有initialized，没有的话，就调用<code>_class_initialize</code>方法进行初始化。这样我们就从晦涩的源码中找到我们的线索，我们就通过这条线索来分析<code>+initialize</code>方法的底层原理。</p><p>我们通过搜索<code>lookUpImpOrForward</code>函数，发现是<code>class_getClassMethod</code>调用来<code>lookUpImpOrForward</code>的。我们正向分析一下。如果要对class发消息，肯定要判断消息对应的<code>Method</code>是否存在，这就需要<code>class_getClassMethod</code>这个函数来实现，正向推理也合理。</p><p>接下来我们继续分析<code>_class_initialize</code>的实现，探究initialize过程做了哪些事情。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* class_initialize.  Send the '+initialize' message on demand to any</span></span><br><span class="line"><span class="comment">* uninitialized class. Force initialization of superclasses first.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="keyword">void</span> _class_initialize(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    assert(!cls-&gt;isMetaClass());</span><br><span class="line"></span><br><span class="line">    Class supercls;</span><br><span class="line">    <span class="keyword">bool</span> reallyInitialize = <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure super is done initializing BEFORE beginning to initialize cls.</span></span><br><span class="line">    <span class="comment">// See note about deadlock above.</span></span><br><span class="line">    <span class="comment">// 先判断supercls是否初始化，没有的话通过递归先初始化supercls</span></span><br><span class="line">    supercls = cls-&gt;superclass;</span><br><span class="line">    <span class="keyword">if</span> (supercls  &amp;&amp;  !supercls-&gt;isInitialized()) &#123;</span><br><span class="line">        _class_initialize(supercls);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Try to atomically set CLS_INITIALIZING.</span></span><br><span class="line">    &#123;</span><br><span class="line">        monitor_locker_t lock(classInitLock);</span><br><span class="line">        <span class="keyword">if</span> (!cls-&gt;isInitialized() &amp;&amp; !cls-&gt;isInitializing()) &#123;</span><br><span class="line">            cls-&gt;setInitializing();</span><br><span class="line">            reallyInitialize = <span class="literal">YES</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (reallyInitialize) &#123;</span><br><span class="line">        <span class="comment">// We successfully set the CLS_INITIALIZING bit. Initialize the class.</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Record that we're initializing this class so we can message it.</span></span><br><span class="line">        _setThisThreadIsInitializingClass(cls);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (MultithreadedForkChild) &#123;</span><br><span class="line">            <span class="comment">// LOL JK we don't really call +initialize methods after fork().</span></span><br><span class="line">            performForkChildInitialize(cls, supercls);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Send the +initialize message.</span></span><br><span class="line">        <span class="comment">// Note that +initialize is sent to the superclass (again) if </span></span><br><span class="line">        <span class="comment">// this class doesn't implement +initialize. 2157218</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Exceptions: A +initialize call that throws an exception </span></span><br><span class="line">        <span class="comment">// is deemed to be a complete and successful +initialize.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Only __OBJC2__ adds these handlers. !__OBJC2__ has a</span></span><br><span class="line">        <span class="comment">// bootstrapping problem of this versus CF's call to</span></span><br><span class="line">        <span class="comment">// objc_exception_set_functions().</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __OBJC2__</span></span><br><span class="line">        <span class="keyword">@try</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 真正初始化的逻辑</span></span><br><span class="line">            callInitialize(cls);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (PrintInitializing) &#123;</span><br><span class="line">                _objc_inform(<span class="string">"INITIALIZE: thread %p: finished +[%s initialize]"</span>,</span><br><span class="line">                             pthread_self(), cls-&gt;nameForLogging());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __OBJC2__</span></span><br><span class="line">        <span class="keyword">@catch</span> (...) &#123;</span><br><span class="line">            <span class="keyword">if</span> (PrintInitializing) &#123;</span><br><span class="line">                _objc_inform(<span class="string">"INITIALIZE: thread %p: +[%s initialize] "</span></span><br><span class="line">                             <span class="string">"threw an exception"</span>,</span><br><span class="line">                             pthread_self(), cls-&gt;nameForLogging());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">@throw</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">@finally</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Done initializing.</span></span><br><span class="line">            lockAndFinishInitializing(cls, supercls);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合源码我们知道，<code>+initialize</code>时，<strong>先调用父类的+initialize，再调用子类的+initialize</strong></p><p>我们看下真正执行<code>+initialize</code>的代码<code>callInitialize</code>，源码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> callInitialize(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    ((<span class="keyword">void</span>(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>callInitialize</code>函数很简单，看源码我们得知，<strong><code>+initialize</code>是通过runtime的消息机制调用</strong>的(而<code>+load</code>是加载时通过函数地址直接调用)</p><h2 id="initialize总结"><a href="#initialize总结" class="headerlink" title="+initialize总结"></a>+initialize总结</h2><p>结合源码分析，我们可以分析apple是如何实现<strong>+initialize方法会在类第一次接收到消息时调用</strong>(Initializes the class before it receives its first message.)</p><ol><li>进行<code>objc_msgSend</code>前先进行方法查找(通过<code>class_getClassMethod</code>)</li><li><code>class_getClassMethod</code>内部调用<code>class_getInstanceMethod</code>，利用元类进行查找</li><li><code>class_getInstanceMethod</code>内部通过<code>lookUpImpOrNil</code>判断函数是否存在</li><li><code>lookUpImpOrNil</code>查找函数的实现或者进行消息转发<code>lookUpImpOrForward</code></li><li><code>lookUpImpOrForward</code>判断class是否初始化，没有的话进行初始化<code>_class_initialize</code></li><li><code>_class_initialize</code>内部先初始化superclass，之后调用初始化方法<code>callInitialize</code></li><li><code>callInitialize</code>内部就是<code>((void(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize);</code>，调用class的<code>initialize</code>方法。</li></ol><p><code>+initialize</code>整个流程完毕，接下来我们再对<code>+initialize</code>做一个总结</p><ol><li>+initialize方法会在类第一次接收到消息时调用</li><li>调用顺序<ul><li>先调用父类的+initialize，再调用子类的+initialize</li><li>(先初始化父类，再初始化子类，每个类只会初始化1次)</li></ul></li><li>虽有初始化只会一次，但是当子类没有实现<code>+initialize</code>时，父类的<code>+initialize</code>会被调用多次，但是父类仍然只会初始化1次，被调用多次是因为继承的原因(子类没有回去父类查找)</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综合全文，对<code>+load</code>和<code>+initialize</code>总结</p><p>load、initialize方法的区别什么？</p><ol><li><p>调用方式<br>1&gt; load是根据函数地址直接调用<br>2&gt; initialize是通过objc_msgSend调用</p></li><li><p>调用时机<br>1&gt; load是runtime加载类、分类的时候调用（只会调用1次）<br>2&gt; initialize是类第一次接收到消息的时候调用，每一个类只会initialize一次（父类的initialize方法可能会被调用多次）</p></li></ol><p>load、initialize的调用顺序？<br>1.load<br>1&gt; 先调用类的load<br>a) 先编译的类，优先调用load<br>b) 调用子类的load之前，会先调用父类的load</p><p>2&gt; 再调用分类的load<br>a) 先编译的分类，优先调用load</p><p>2.initialize<br>1&gt; 先初始化父类<br>2&gt; 再初始化子类（可能最终调用的是父类的initialize方法）</p><h2 id="参考和源码"><a href="#参考和源码" class="headerlink" title="参考和源码"></a>参考和源码</h2><p>Apple Source Browser - <a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">objc</a></p><div class="article_footer"><section class="widget copyright desktop mobile"><div class="content"><blockquote><p>博客内容遵循 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</p><p>本文永久链接是：<a href="https://ticsmatic.com/p/4235a91d/">https://ticsmatic.com/p/4235a91d/</a></p></blockquote></div></section><section class="widget qrcode desktop mobile"><div class="content article-entry"></div></section></div></div><section class="meta" id="footer-meta"><div class="new-meta-box"><div class="new-meta-item date" itemprop="dateUpdated" datetime="2020-05-08T19:00:30+08:00"><a class="notlink"><i class="fas fa-edit fa-fw" aria-hidden="true"></i><p>更新于：2020-05-08</p></a></div><div class="new-meta-item share -mob-share-list"><div class="-mob-share-list share-body"><a class="-mob-share-qq" rel="external nofollow noopener noreferrer noopener" href="http://connect.qq.com/widget/shareqq/index.html?url=https://ticsmatic.com/p/4235a91d/&title=load initialize的本质 - ticsmatic&summary=学习MJ的视频课程，整理总结知识点–load initialize的本质这一篇通过+load和+initialize的官方文档并结合Demo来介绍这两个方法。同时会依据runtime源码来介绍+load和+initialize底层的逻辑。" target="_blank"><img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/qq.png"> </a><a class="-mob-share-qzone" rel="external nofollow noopener noreferrer noopener" href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://ticsmatic.com/p/4235a91d/&title=load initialize的本质 - ticsmatic&summary=学习MJ的视频课程，整理总结知识点–load initialize的本质这一篇通过+load和+initialize的官方文档并结合Demo来介绍这两个方法。同时会依据runtime源码来介绍+load和+initialize底层的逻辑。" target="_blank"><img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/qzone.png"> </a><a class="-mob-share-weibo" rel="external nofollow noopener noreferrer noopener" href="http://service.weibo.com/share/share.php?url=https://ticsmatic.com/p/4235a91d/&title=load initialize的本质 - ticsmatic&summary=学习MJ的视频课程，整理总结知识点–load initialize的本质这一篇通过+load和+initialize的官方文档并结合Demo来介绍这两个方法。同时会依据runtime源码来介绍+load和+initialize底层的逻辑。" target="_blank"><img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/weibo.png"></a><div class="hoverbox"><a><img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/wechat.png"></a><div class="target"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAARgAAAEYCAAAAACi5bZQAAAC7UlEQVR42u3aQW7DMAwEwPz/0+0HWpha0oGZjG4JYsmcXBakXj/Wn+uFAAwYMGDAgFkD8wpXfPDF8/+dc/V5qh4wYMCAAQMGzD6YqcKqvz8FqJ7bfT8wYMCAAQMGzF6YywAUBq9uodXn2vWAAQMGDBgwYMAUA9508AMDBgwYMGDAgJk+OB3krQ94YMCAAQMGDJi3wRwPqIYuFqXB8bRR9rZJJBgwYMCAAQPmbTBpEHvq57geMGDAgAEDBswamO6ahkz3HasHDBgwYMCAAbMGJg1IaSMrbVRND/jAgAEDBgwYMPthqgVUC0sDX/f77n5gwIABAwYMmH0wUwV0oap/SApShgUDBgwYMGDArIGpNo5OG1KnL5iCTZ0DBgwYMGDAgPk8mGrA6ja0TgPiaWOq/BwYMGDAgAEDZj1MevHntLE0/X37fcGAAQMGDBgwa2DSA68OTgvoBrU08IEBAwYMGDBg9sG8q0F1V8CbGuCBAQMGDBgwYPbBTF3o6QbF6YbY6X5gwIABAwYMmH0wU4GsO2hLG09pQwsMGDBgwIABsx9muiGVFt4Naun+x40qMGDAgAEDBszjYNIGUnqR6DRQdt8rHriBAQMGDBgwYB4Pc7px96LQ1MWh9I/79/dgwIABAwYMmI+FOQ1i6YAs3b8LDgYMGDBgwIDZD9NtZKWDsrsGgWUoMGDAgAEDBsxamLsHZ2kDqjvYK/+hYMCAAQMGDJi1MN2GVTX4pQCvcJWDJRgwYMCAAQNmDcx0gEsDWdroOi786jMYMGDAgAEDZg3MdGC6a6BWhT8NlJcDNzBgwIABAwbM42HuKrBbcLVhNbYvGDBgwIABA2YtzHSASgPj6QBvKpiCAQMGDBgwYL4XpjoQ637fBS4P3MCAAQMGDBgwXwPTfdHTi0GnDazL88CAAQMGDBgwa2FOB27pi6UBr/scGDBgwIABA+bzYNLBVbeQeDDWDXLVi0NgwIABAwYMmMfCWGDAgAEDBgyYZesXSjRhyrQsTuIAAAAASUVORK5CYII="></div></div></div></div></div></section><div class="prev-next"><a class="prev" href="/p/95e305cc/"><p class="title"><i class="fas fa-chevron-left" aria-hidden="true"></i>block详解</p><p class="content">学习MJ的视频课程，整理总结知识点–block详解block是OC中实用频率很高的一个功能，同时在其它语言中也有相似的特性，比如swift中的闭包，Python中的闭包等。本文先通过简单介绍bl...</p></a><a class="next" href="/p/4bdf012b/"><p class="title">关联对象(Associated)详解<i class="fas fa-chevron-right" aria-hidden="true"></i></p><p class="content">学习MJ的视频课程，整理总结知识点–关联对象(Associated)详解本文通过runtime中objc_setAssociatedObject源码为切入点，同时结合category的底层结构(...</p></a></div></section></article><article class="post white-box comments shadow"><section class="article typo"><p ct><i class="fas fa-comments"></i> 评论</p><section id="comments"><div id="valine_container" class="valine_thread"><i class="fas fa-cog fa-spin fa-fw fa-2x"></i></div></section></section></article><script>window.subData={title:"load initialize的本质",tools:!0}</script></div><aside class="l_side"><section class="widget toc-wrapper shadow desktop mobile"><header><i class="fas fa-list fa-fw" aria-hidden="true"></i><span class="name">本文目录</span></header><div class="content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#load介绍"><span class="toc-text">+load介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#load调用原理"><span class="toc-text">+load调用原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-hasLoadMethods"><span class="toc-text">1. hasLoadMethods</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-prepare-load-methods"><span class="toc-text">2. prepare_load_methods</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-call-load-methods"><span class="toc-text">3. call_load_methods</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#load总结"><span class="toc-text">+load总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#initialize介绍"><span class="toc-text">+initialize介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#initialize原理"><span class="toc-text">+initialize原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#initialize总结"><span class="toc-text">+initialize总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考和源码"><span class="toc-text">参考和源码</span></a></li></ol></div></section></aside><footer class="clearfix"><br><br><br><div class="social-wrapper"><a href="/atom.xml" class="social fas fa-rss flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="mailto:ticsmatics@gmail.com" class="social fas fa-envelope flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="https://github.com/ticsmatic" class="social fab fa-github flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a></div><div class="copyright"><p><a href="https://ticsmatic.com">Copyright © 2016-2020 ticsmatic</a></p></div></footer><script>setLoadingBarProgress(80)</script><script>setLoadingBarProgress(60)</script></div><a class="s-top fas fa-arrow-up fa-fw" href="javascript:void(0)"></a></div><script src="https://cdn.jsdelivr.net/npm/jquery@3.4/dist/jquery.min.js"></script><script>var SEARCH_SERVICE="hexo",ROOT="/";ROOT.endsWith("/")||(ROOT+="/")</script><script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/instant_page.js" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script><script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script><script type="text/javascript">$(function(){Waves.attach(".flat-btn",["waves-button"]),Waves.attach(".float-btn",["waves-button","waves-float"]),Waves.attach(".float-btn-light",["waves-button","waves-float","waves-light"]),Waves.attach(".flat-box",["waves-block"]),Waves.attach(".float-box",["waves-block","waves-float"]),Waves.attach(".waves-image"),Waves.init()})</script><script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery-backstretch@2.1.18/jquery.backstretch.min.js"></script><script type="text/javascript">$(function(){var a=["https://cdn.ticsmatic.com/img/wallpaper/autumn-background-beautiful-bright-627823.jpg"];!function(a){for(var t=a.length;t--;){var r=Math.floor(Math.random()*t),c=a[r];a[r]=a[t],a[t]=c}}(a),$(".cover").backstretch(a,{duration:"20000",fade:"1500"})})</script><script src="https://cdn.ticsmatic.com/script/Valine.min.js"></script><script>var GUEST_INFO=["nick","mail","link"],meta="nick,mail,link".split(",").filter(function(i){return-1<GUEST_INFO.indexOf(i)}),valine=new Valine;valine.init({el:"#valine_container",meta:meta,appId:"VNmRxpFEai4571pMche8o8ir-gzGzoHsz",appKey:"x06wrMifXe5j784k7CEk9zNA",placeholder:"快来评论吧~",pageSize:"10",avatar:"mp",lang:"zh-cn",visitor:"false",highlight:"true",mathJax:"false"})</script><script src="/js/app.js"></script><script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.4/js/search.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script><script>function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="fas fa-copy"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-check-circle');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('fa-check-circle');
          $icon.addClass('fa-copy');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-times-circle');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('fa-times-circle');
          $icon.addClass('fa-copy');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);</script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script>let LAZY_LOAD_IMAGE = "";
  $(".article-entry").find("div.fancybox").find("img").each(function () {
      var element = document.createElement("a");
      $(element).attr("data-fancybox", "gallery");
      $(element).attr("href", $(this).attr("src"));
      /* 图片采用懒加载处理时,
       * 一般图片标签内会有个属性名来存放图片的真实地址，比如 data-original,
       * 那么此处将原本的属性名src替换为对应属性名data-original,
       * 修改如下
       */
       if (LAZY_LOAD_IMAGE) {
         $(element).attr("href", $(this).attr("data-original"));
       }
      $(this).wrap(element);
  });</script><script>setLoadingBarProgress(100)</script></body></html>
<!DOCTYPE html><html><head hexo-theme="https://volantis.js.org/#2.6.3"><meta charset="utf-8"><meta name="renderer" content="webkit"><meta name="force-rendering" content="webkit"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="HandheldFriendly" content="True"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><title>block的copy、访问对象类型变量的底层实现、__block的底层实现 - ticsmatic</title><meta name="description" content="学习MJ的视频课程，整理总结知识点–__block的底层实现本文根据前面所学的block的特性，结合Demo来讲解关于block的底层的一些东西。包括block的底层源码，"><link rel="alternate" href="/atom.xml" title="ticsmatic"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css"><link rel="shortcut icon" type="image/x-icon" href="https://cdn.ticsmatic.com/img/favicon.png"><link rel="stylesheet" href="/css/style.css"><script>function setLoadingBarProgress(e){document.getElementById("loading-bar").style.width=e+"%"}</script></head><body><div id="loading-bar-wrapper"><div id="loading-bar"></div></div><header class="l_header shadow blur"><div class="container"><div class="wrapper"><div class="nav-sub"><p class="title"></p><ul class="switcher nav-list-h"><li><a class="s-comment fas fa-comments fa-fw" target="_self" href="javascript:void(0)"></a></li><li><a class="s-toc fas fa-list fa-fw" target="_self" href="javascript:void(0)"></a></li></ul></div><div class="nav-main"><a class="title flat-box" target="_self" href="/">ticsmatic</a><div class="menu navigation"><ul class="nav-list-h"><li><a class="flat-box" href="/" id="home"><i class="fas fa-rss fa-fw"></i>博文</a></li><li><a class="flat-box" href="/archives/" id="archives"><i class="fas fa-archive fa-fw"></i>归档</a></li><li><a class="flat-box" href="/categories/" id="categories"><i class="fas fa-folder-open fa-fw"></i>分类</a></li><li><a class="flat-box" href="/tags/" id="tags"><i class="fas fa-tags fa-fw"></i>标签</a></li><li><a class="flat-box" href="/about/" id="about"><i class="fas fa-info-circle fa-fw"></i>关于</a></li></ul></div><div class="m_search"><form name="searchform" class="form u-search-form"><i class="icon fas fa-search fa-fw"></i> <input type="text" class="input u-search-input" placeholder="Search..."></form></div><ul class="switcher nav-list-h"><li><a class="s-search fas fa-search fa-fw" target="_self" href="javascript:void(0)"></a></li><li><a class="s-menu fas fa-bars fa-fw" target="_self" href="javascript:void(0)"></a><ul class="menu-phone list-v navigation white-box"><li><a class="flat-box" href="/" id="home"><i class="fas fa-rss fa-fw"></i>博文</a></li><li><a class="flat-box" href="/archives/" id="archives"><i class="fas fa-archive fa-fw"></i>归档</a></li><li><a class="flat-box" href="/categories/" id="categories"><i class="fas fa-folder-open fa-fw"></i>分类</a></li><li><a class="flat-box" href="/tags/" id="tags"><i class="fas fa-tags fa-fw"></i>标签</a></li><li><a class="flat-box" href="/about/" id="about"><i class="fas fa-info-circle fa-fw"></i>关于</a></li></ul></li></ul></div></div></div></header><script>setLoadingBarProgress(40)</script><div class="l_body nocover"><div class="body-wrapper"><div class="l_main"><article id="post" class="post white-box shadow article-type-post" itemscope itemprop="blogPost"><section class="meta"><div class="meta" id="header-meta"><h1 class="title"><a href="/p/5ee3d56b/">block的copy、访问对象类型变量的底层实现、__block的底层实现</a></h1><div class="new-meta-box"><div class="new-meta-item date"><a class="notlink"><i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i><p>2020-05-20</p></a></div><div class="new-meta-item browse busuanzi"><a class="notlink"><i class="fas fa-eye fa-fw" aria-hidden="true"></i><p><span id="busuanzi_value_page_pv"><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span></p></a></div></div><hr></div></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><p>学习MJ的视频课程，整理总结知识点–__block的底层实现</p><p>本文根据前面所学的block的特性，结合Demo来讲解关于<strong>block的底层的一些东西。包括</strong>block的底层源码，</p><a id="more"></a><h2 id="block"><a href="#block" class="headerlink" title="__block"></a>__block</h2><p>关于block还要一个比较常见的场景就是<strong>block修饰，这一部分参见[</strong>block底层-Demo](<a href="https://cdn.ticsmatic.com/source/2020-05-21/diceng/day09/Interview04-__block.zip" target="_blank" rel="noopener">https://cdn.ticsmatic.com/source/2020-05-21/diceng/day09/Interview04-__block.zip</a>)</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// __block int age = 10;</span></span><br><span class="line"><span class="keyword">void</span> (^block)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">    age = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%d"</span>, age);</span><br><span class="line">&#125;;</span><br><span class="line">block();</span><br></pre></td></tr></table></figure><p>我们知道如果不加__block，编译器是会报错。根据前面所学的block变量捕获，我们知道当block访问的外部变量是auto类型时，如果这个变量是基本类型，block会先把这个变量捕获到内部，所以block内部的age变量和外边的age此时已经不属于同一块内存空间了，自然就不能修改。</p><p>那怎么才能修改age的值，有以下两种方法<br>1.用static或全局变量修饰age变量<br>2.用__block修饰age变量</p><p>第1种方法我们我们知道此时block内部要么捕获age的指针地址，要么不捕获age，直接访问age，都是可以对age进行修改。<br>第2种加上__block后为什么也可以呢？我们通过源码进行分析这一过程，首先还是用clang导出block源码，如下</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line">  __Block_byref_age_0 *age; <span class="comment">// by ref</span></span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, __Block_byref_age_0 *_age, <span class="keyword">int</span> flags=<span class="number">0</span>) : age(_age-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而此时<code>__Block_byref_age_0</code>的结构如下</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __Block_byref_age_0 &#123;</span><br><span class="line">  <span class="keyword">void</span> *__isa;</span><br><span class="line">__Block_byref_age_0 *__forwarding;</span><br><span class="line"> <span class="keyword">int</span> __flags;</span><br><span class="line"> <span class="keyword">int</span> __size;</span><br><span class="line"> <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而此时block内部的代码如下</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  __Block_byref_age_0 *age = __cself-&gt;age; <span class="comment">// bound by ref</span></span><br><span class="line"></span><br><span class="line">            (age-&gt;__forwarding-&gt;age) = <span class="number">20</span>;</span><br><span class="line">            <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_k2_y136z2p908718gwl0q6xh92w0000gn_T_main_149db6_mi_0, (age-&gt;__forwarding-&gt;age));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>定义<code>__block int age = 10;</code>转化为源码如下</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__Block_byref_age_0 age = &#123;</span><br><span class="line">    (<span class="keyword">void</span>*)<span class="number">0</span>,</span><br><span class="line">    (__Block_byref_age_0 *)&amp;age,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="keyword">sizeof</span>(__Block_byref_age_0),</span><br><span class="line">    <span class="number">10</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们发现，用<strong>block修饰后，age被包装成`</strong>Block_byref_age_0 *age;<code>，变为结构体，而这个结构体内部存放的有age的值。block内部的age变为</code><strong>Block_byref_age_0 *age; // by ref<code>。 block函数实现部分</code>age-&gt;</strong>forwarding<code>指向自己的结构体地址，可以通过</code>(age-&gt;<strong>forwarding-&gt;age) = 20;`修改内部age的值。这也解释为什么</strong>block可以修改值的本质原因。</p><p>概述一下<strong>block修饰的作用：<br>__block修饰的变量会被包装成一个对象(`</strong>Block_byref_xx_0<code>)，这个对象的结构体内部有用于存储真实的变量的成员。block内部有</code>__Block_byref_xx_0<code>成员变量用来访问和修改变量</code>xx`。</p><p>__block修饰符小结：</p><ol><li>__block可以用于解决block内部无法修改auto变量值的问题</li><li>编译器会将<strong>block变量包装成一个对象(`</strong>Block_byref_xx_0`)</li><li>__block不能修饰全局变量、静态变量（static）</li></ol><p>再用一张图片做一下总结<br><img src="https://cdn.ticsmatic.com/img/2020-05-21/15900322500373.png" alt="__block修饰的变量"></p><h2 id="block修饰的变量的地址"><a href="#block修饰的变量的地址" class="headerlink" title="__block修饰的变量的地址"></a>__block修饰的变量的地址</h2><p>我们通过下面这段代码研究输出的<code>age</code>的地址</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">void</span> (^block)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">    age = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%d"</span>, age);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%p"</span>, &amp;age); <span class="comment">// p/x &amp;(blockImpl-&gt;age-&gt;age)</span></span><br></pre></td></tr></table></figure><p>这段代码的底层源码上面我们已经分析过了，block内部有一个<code>__Block_byref_age_0 *age; // by ref</code>的成员变量，而<code>__Block_byref_age_0</code>结构体内部有一个<code>int age;</code>的成员变量。那么上面的代码输出的age地址是<code>__Block_byref_age_0</code>的地址，还是<code>__Block_byref_age_0</code>内部的<code>int age</code>的地址？</p><p>其实我们分析也可以得知，输出的应该是<code>__Block_byref_age_0</code>内部的<code>int age</code>的地址。<br>一方面OC的语言设计者是不希望暴露block的内部细节给开发者，因为开发者平时没必要关注内部的细节。还有KVO动态生成子类，但是返回的class还是原来的类也是这样，为了屏蔽这个动态的子类。另一方面，我们在block内部给age赋值时，block源码内部也是通过结构体拿到<code>int age</code>进行赋值操作，所以读取的话，理论上应该也是返回这个<code>int age</code>。</p><p>我们可以通过实现block的源码来验证一个观点，参见<a href="https://cdn.ticsmatic.com/source/2020-05-21/diceng/day10/Interview01-__block.zip" target="_blank" rel="noopener">__block转结构体-Demo</a></p><h2 id="block内存管理"><a href="#block内存管理" class="headerlink" title="__block内存管理"></a><code>__block</code>内存管理</h2><p>如果认真看<code>__block</code>编译后的源码会发现，<strong>__block修饰的变量</strong>的底层源码和<strong>block访问对象类型的auto变量</strong>的底层源码有很多的相似之处。</p><blockquote><p>参见对比源码中<a href="https://cdn.ticsmatic.com/source/2020-05-21/diceng/day09/Interview04-__block.zip" target="_blank" rel="noopener">__block底层-Demo</a>中<code>main.cpp</code>文件</p></blockquote><p>比如__block的变量会被包装成对象，拥有这个对象，对这个对象进行内存管理。block源码内部都会有copy和dispose函数等。block内部都会通过<code>_Block_object_assign</code>函数引用者block要访问的外部变量。block销毁时，也都会调用<code>_Block_object_dispose</code>函数进行解除引用。</p><p>但是也是有一些不同点，对__block的内存管理可以总结如下：</p><ol><li><p>当block在栈上时，并不会对__block变量产生强引用</p></li><li><p>当block被copy到堆时</p><ul><li>会调用block内部的copy函数</li><li>copy函数内部会调用_Block_object_assign函数</li><li><strong>_Block_object_assign函数会对__block变量形成强引用（retain）</strong></li><li>当block拷贝到堆上时，内部访问的变量如果在栈上也会拷贝到，如果在堆上，引用计数会+1。这样来达到block来管理内部访问的变量<br><img src="https://cdn.ticsmatic.com/img/2020-05-21/15900698725809.png" alt="__block变量01">)<img src="https://cdn.ticsmatic.com/img/2020-05-21/15900698762232.png" alt="__block变量02"></li></ul></li><li><p>当block从堆中移除时</p><ul><li>会调用block内部的dispose函数</li><li>dispose函数内部会调用_Block_object_dispose函数</li><li>_Block_object_dispose函数会自动释放引用的<strong>block变量（release）<br>![</strong>block-dispose01](<a href="https://cdn.ticsmatic.com/img/2020-05-21/15900714319132.png" target="_blank" rel="noopener">https://cdn.ticsmatic.com/img/2020-05-21/15900714319132.png</a>)<br><img src="https://cdn.ticsmatic.com/img/2020-05-21/15900716940751.png" alt="__block-dispose02"></li></ul></li></ol><h2 id="forwarding"><a href="#forwarding" class="headerlink" title="__forwarding"></a><code>__forwarding</code></h2><p>我们获取在前面已经发现，<code>__block</code>变量内部默认有一个<code>__forwarding</code>指针，而且在block实现内部，比如上面我们修改<code>age</code>的值时，也是通过<code>__forwarding</code>来访问age的(<code>(age-&gt;__forwarding-&gt;age) = 20;</code>)。</p><p>为什么不直接通过结构体访问里面的<code>age</code>，而是间接通过<code>__forwarding</code>指针来访问<code>age</code>？</p><p><img src="https://cdn.ticsmatic.com/img/2020-05-21/15900717248002.png" alt="__forwarding01"><br><img src="https://cdn.ticsmatic.com/img/2020-05-21/15900720545743.png" alt="__forwarding02"></p><h2 id="对象类型的auto变量、-block变量小结"><a href="#对象类型的auto变量、-block变量小结" class="headerlink" title="对象类型的auto变量、__block变量小结"></a>对象类型的auto变量、__block变量小结</h2><p>当block在栈上时，对它们都不会产生强引用</p><p>当block拷贝到堆上时，都会通过copy函数来处理它们</p><ol><li>__block变量（假设变量名叫做a）<br><code>_Block_object_assign((void*)&amp;dst-&gt;a, (void*)src-&gt;a, 8/*BLOCK_FIELD_IS_BYREF*/);</code></li><li>对象类型的auto变量（假设变量名叫做p）<br><code>_Block_object_assign((void*)&amp;dst-&gt;p, (void*)src-&gt;p, 3/*BLOCK_FIELD_IS_OBJECT*/);</code></li></ol><p>当block从堆上移除时，都会通过dispose函数来释放它们<br>__block变量（假设变量名叫做a）<br><code>_Block_object_dispose((void*)src-&gt;a, 8/*BLOCK_FIELD_IS_BYREF*/);</code></p><p>对象类型的auto变量（假设变量名叫做p）<br><code>_Block_object_dispose((void*)src-&gt;p, 3/*BLOCK_FIELD_IS_OBJECT*/);</code></p><h2 id="block修饰对象类型"><a href="#block修饰对象类型" class="headerlink" title="__block修饰对象类型"></a>__block修饰对象类型</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__block MJPerson *weakPerson = person;</span><br><span class="line">__block __<span class="keyword">weak</span> MJPerson *weakPerson = person;</span><br></pre></td></tr></table></figure><p>当__block变量在栈上时，不会对指向的对象产生强引用</p><p>当__block变量被copy到堆时</p><ol><li>会调用__block变量内部的copy函数</li><li>copy函数内部会调用_Block_object_assign函数</li><li>_Block_object_assign函数会根据所指向对象的修饰符（<strong>strong、</strong>weak、__unsafe_unretained）做出相应的操作，形成强引用（retain）或者弱引用（<strong>注意：这里仅限于ARC时会retain，MRC时不会retain</strong>）</li></ol><p>如果<strong>block变量从堆上移除<br>会调用</strong>block变量内部的dispose函数<br>dispose函数内部会调用_Block_object_dispose函数<br>_Block_object_dispose函数会自动释放指向的对象（release）</p><h2 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h2><p>因为block默认会对访问的对象进行强引用，如果此时对象已经对这个block强引用了，很容易就造成循环引用，从而导致内存泄露。如下</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MJPerson *person = [[MJPerson alloc] init];</span><br><span class="line">person.age = <span class="number">10</span>;</span><br><span class="line">person.block = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"age is %d"</span>, person.age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这段测试代码就会有循环引用的问题，因为block内部访问对象类型的<code>person</code>的变量，block此时默认会强引用这个<code>person</code>对象，而这个block又是<code>person</code>的成员变量，所以person会强引用着block。这就出现了循环引用。</p><h3 id="ARC下循环引用的解决"><a href="#ARC下循环引用的解决" class="headerlink" title="ARC下循环引用的解决"></a>ARC下循环引用的解决</h3><h4 id="weak"><a href="#weak" class="headerlink" title="__weak"></a>__weak</h4><p>通常的解决方法就是不让block强引用<code>person</code>对象，用__weak修饰person对象，如下</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MJPerson *person = [[MJPerson alloc] init];</span><br><span class="line">person.age = <span class="number">10</span>;</span><br><span class="line">__<span class="keyword">weak</span> MJPerson *weakPerson = person;</span><br><span class="line"><span class="comment">// __weak typeof(person) weakPerson = person;</span></span><br><span class="line">person.block = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"age is %d"</span>, weakPerson.age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样就打破了循环引用了，对象就可以正常的释放了。</p><h4 id="unsafe-unretained"><a href="#unsafe-unretained" class="headerlink" title="__unsafe_unretained"></a>__unsafe_unretained</h4><p>解决循环引用还有另一种方法，就是使用<code>__unsafe_unretained</code>，如下</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">unsafe_unretained</span> <span class="keyword">typeof</span>(person) weakPerson = person;</span><br><span class="line">person.block = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"age is %d"</span>, weakPerson.age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用<code>__unsafe_unretained</code>，block就不会对<code>person</code>产生强引用。但是它不安全，体现在当block内的<code>weakPerson</code>销毁时，block内指针存储的地址值不变，此时访问<code>weakPerson</code>就可能出现坏内存访问的问题。而用__weak时，指向的对象销毁时，会自动让指针置为nil。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; __weak：不会产生强引用，指向的对象销毁时，会自动让指针置为nil</span><br><span class="line">&#x2F;&#x2F; __unsafe_unretained：不会产生强引用，不安全，指向的对象销毁时，指针存储的地址值不变</span><br></pre></td></tr></table></figure><h4 id="block-1"><a href="#block-1" class="headerlink" title="___block"></a><code>___block</code></h4><p>解决循环引用还有一种方法就是使用<code>___block</code>修饰，如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="keyword">typeof</span>(person) weakPerson = person;</span><br><span class="line">person.block = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"age is %d"</span>, weakPerson.age);</span><br><span class="line">    weakPerson = <span class="literal">nil</span>;</span><br><span class="line">&#125;;</span><br><span class="line">person.block();</span><br></pre></td></tr></table></figure><p>分析：<br>此时内部会有3个对象，分别是block对象、<strong>block对象、</strong>block对象内部的person对象。<br>其中block对象会强引用着<strong>block对象，</strong>block对象内部会强引用着person对象，但是我们上面的代码，在block的实现里面，当block内代码走完时，手动把内部的person指针置为nil，此时<strong>block就不会对person对象强引用，就可以打破循环引用了。<br>![使用</strong>block打破循环引用](<a href="https://cdn.ticsmatic.com/img/2020-05-21/15900751183030.png" target="_blank" rel="noopener">https://cdn.ticsmatic.com/img/2020-05-21/15900751183030.png</a>)</p><h3 id="MRC下循环引用的解决"><a href="#MRC下循环引用的解决" class="headerlink" title="MRC下循环引用的解决"></a>MRC下循环引用的解决</h3><p>MRC不支持__weak，</p><ol><li>可以使用__unsafe_unretained</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">unsafe_unretained</span> <span class="keyword">typeof</span>(person) weakPerson = person;</span><br><span class="line">person.block = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"age is %d"</span>, weakPerson.age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li>可以使用<strong>_block，因为</strong>block修饰对象类型的变量，在MRC下是不会自动持有对象的<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="keyword">typeof</span>(person) weakPerson = person;</span><br><span class="line">person.block = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"age is %d"</span>, weakPerson.age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2>在解决循环引用时，有一种常见的写法是在block内部使用__strong，我们看这段代码</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    <span class="keyword">self</span>.block = ^&#123;</span><br><span class="line">        __<span class="keyword">strong</span> <span class="keyword">typeof</span>(weakSelf) strongSelf = weakSelf;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"age is %d"</span>, strongSelf-&gt;_age);</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>解决循环引用时，使用<strong>weak类型的对象，但是当执行block内部的逻辑代码时，如果self被释放，此时block访问释放的self就会挂，在block里面使用的</strong>strong修饰的weakSelf是为了在函数生命周期中防止self提前释放。strongSelf是一个自动变量当block执行完毕就会释放自动变量，strongSelf不会对self进行一直进行强引用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>block本质上也是一个OC对象，它内部也有个isa指针</p><p>block是封装了函数调用以及函数调用环境的OC对象</p><p>block的底层结构如图所示<br><img src="https://cdn.ticsmatic.com/img/2020-05-20/15899515914959.jpeg" alt="block底层结构"></p><h2 id="参考和源码"><a href="#参考和源码" class="headerlink" title="参考和源码"></a>参考和源码</h2><p>Demo源码：<br><a href="https://cdn.ticsmatic.com/source/2020-05-21/diceng/day09/Interview04-__block.zip" target="_blank" rel="noopener">__block底层-Demo</a><br><a href="https://cdn.ticsmatic.com/source/2020-05-21/diceng/day10/Interview01-__block.zip" target="_blank" rel="noopener">__block转结构体-Demo</a></p><div class="article_footer"><section class="widget copyright desktop mobile"><div class="content"><blockquote><p>博客内容遵循 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</p><p>本文永久链接是：<a href="https://ticsmatic.com/p/5ee3d56b/">https://ticsmatic.com/p/5ee3d56b/</a></p></blockquote></div></section><section class="widget qrcode desktop mobile"><div class="content article-entry"></div></section></div></div><section class="meta" id="footer-meta"><div class="new-meta-box"><div class="new-meta-item date" itemprop="dateUpdated" datetime="2020-05-22T09:13:55+08:00"><a class="notlink"><i class="fas fa-edit fa-fw" aria-hidden="true"></i><p>更新于：2020-05-22</p></a></div><div class="new-meta-item share -mob-share-list"><div class="-mob-share-list share-body"><a class="-mob-share-qq" rel="external nofollow noopener noreferrer noopener" href="http://connect.qq.com/widget/shareqq/index.html?url=https://ticsmatic.com/p/5ee3d56b/&title=block的copy、访问对象类型变量的底层实现、__block的底层实现 - ticsmatic&summary=学习MJ的视频课程，整理总结知识点–__block的底层实现本文根据前面所学的block的特性，结合Demo来讲解关于block的底层的一些东西。包括block的底层源码，" target="_blank"><img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/qq.png"> </a><a class="-mob-share-qzone" rel="external nofollow noopener noreferrer noopener" href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://ticsmatic.com/p/5ee3d56b/&title=block的copy、访问对象类型变量的底层实现、__block的底层实现 - ticsmatic&summary=学习MJ的视频课程，整理总结知识点–__block的底层实现本文根据前面所学的block的特性，结合Demo来讲解关于block的底层的一些东西。包括block的底层源码，" target="_blank"><img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/qzone.png"> </a><a class="-mob-share-weibo" rel="external nofollow noopener noreferrer noopener" href="http://service.weibo.com/share/share.php?url=https://ticsmatic.com/p/5ee3d56b/&title=block的copy、访问对象类型变量的底层实现、__block的底层实现 - ticsmatic&summary=学习MJ的视频课程，整理总结知识点–__block的底层实现本文根据前面所学的block的特性，结合Demo来讲解关于block的底层的一些东西。包括block的底层源码，" target="_blank"><img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/weibo.png"></a><div class="hoverbox"><a><img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/wechat.png"></a><div class="target"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAARgAAAEYCAAAAACi5bZQAAAC7ElEQVR42u3aQW7DMAwEQP//0+29KGBxSbdhMrq5QW1rfFloeX1Zv64LARgwYMCAAbMG5grXz/+/u/7597vnn/5+er/j/YABAwYMGDBg1sEcB6AQIt1YOaB19wMGDBgwYMCAWQszHehOg1U1+FU/3PF+wIABAwYMGDAfA5MGwO7zqx8ODBgwYMCAAQNmCjINbqcFHhgwYMCAAQPm82DSQuvpDaaB8d+aSDBgwIABAwbMn8GkRdmrXsf7AQMGDBgwYMCsgZleVdA0kFX/7/j+YMCAAQMGDJg1MKeFWBqYntroYwUcGDBgwIABA2YNTBViqpCbvu4CggEDBgwYMGD2wXSDURdiKhB2gyoYMGDAgAED5v1gqr+n0PFGiuBgwIABAwYMmPeDSQNdWsRVD55S2PbgEBgwYMCAAQNmHUwaAKsg7YKsCQEGDBgwYMCA2Q+TFm7pC6YFWbcYvIUGAwYMGDBgwKyBSQd10gOtdMCoep+0IAQDBgwYMGDA7IPpDuZMB8UUJg12YMCAAQMGDJh9MN2Np4XZ1MBR+mFvAx4YMGDAgAED5uVhqsVYOmA0XeilALf3AQMGDBgwYMCsgUkf1C3qqkVZeiBVHkQCAwYMGDBgwKyFmVrdAaOnDtBugycYMGDAgAEDZh1MNZhNDQZ1g176HmODQ2DAgAEDBgyYl4PpHjylAN2CLS34wIABAwYMGDD7YaoPSouu6Y2evn95cAgMGDBgwIAB8/IwaTBqB6ridbXIKx+YgQEDBgwYMGDWwHTX9EZOn9Mt6sCAAQMGDBgw+2GucKXF2FPBbuy+YMCAAQMGDJh1MH8d6KYLvO7zwYABAwYMGDD7YdIBn6cLsau5jgMiGDBgwIABA+ZjYZ4aRKo+Lz4gAwMGDBgwYMB8DEw3kFWD41OBEAwYMGDAgAGzH6ZauJ2+ePV51Q8zNggFBgwYMGDAgFkH0y3G0gOnNEhW3+v4w4MBAwYMGDBg1sBYYMCAAQMGDJhl6xvETWhhPxBehQAAAABJRU5ErkJggg=="></div></div></div></div></div></section><div class="prev-next"><a class="prev" href="/p/a3ade774/"><p class="title"><i class="fas fa-chevron-left" aria-hidden="true"></i>block的copy、访问对象类型变量的底层实现</p><p class="content">学习MJ的视频课程，整理总结知识点–block的copy、访问对象类型变量的底层实现本文结合block的特性，探讨ARC下block自动copy的时机；以及block内访问外部的对象类型变量时底...</p></a><a class="next" href="/p/95e305cc/"><p class="title">block详解<i class="fas fa-chevron-right" aria-hidden="true"></i></p><p class="content">学习MJ的视频课程，整理总结知识点–block详解block是OC中实用频率很高的一个功能，同时在其它语言中也有相似的特性，比如swift中的闭包，Python中的闭包等。本文先通过简单介绍bl...</p></a></div></section></article><article class="post white-box comments shadow"><section class="article typo"><p ct><i class="fas fa-comments"></i> 评论</p><section id="comments"><div id="valine_container" class="valine_thread"><i class="fas fa-cog fa-spin fa-fw fa-2x"></i></div></section></section></article><script>window.subData={title:"block的copy、访问对象类型变量的底层实现、__block的底层实现",tools:!0}</script></div><aside class="l_side"><section class="widget toc-wrapper shadow desktop mobile"><header><i class="fas fa-list fa-fw" aria-hidden="true"></i><span class="name">本文目录</span></header><div class="content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#block"><span class="toc-text">__block</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#block修饰的变量的地址"><span class="toc-text">__block修饰的变量的地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#block内存管理"><span class="toc-text">__block内存管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#forwarding"><span class="toc-text">__forwarding</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象类型的auto变量、-block变量小结"><span class="toc-text">对象类型的auto变量、__block变量小结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#block修饰对象类型"><span class="toc-text">__block修饰对象类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#循环引用"><span class="toc-text">循环引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ARC下循环引用的解决"><span class="toc-text">ARC下循环引用的解决</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#weak"><span class="toc-text">__weak</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unsafe-unretained"><span class="toc-text">__unsafe_unretained</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#block-1"><span class="toc-text">___block</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MRC下循环引用的解决"><span class="toc-text">MRC下循环引用的解决</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#补充"><span class="toc-text">补充</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考和源码"><span class="toc-text">参考和源码</span></a></li></ol></div></section></aside><footer class="clearfix"><br><br><br><div class="social-wrapper"><a href="/atom.xml" class="social fas fa-rss flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="mailto:ticsmatics@gmail.com" class="social fas fa-envelope flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="https://github.com/ticsmatic" class="social fab fa-github flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a></div><div class="copyright"><p><a href="https://ticsmatic.com">Copyright © 2016-2020 ticsmatic</a></p></div></footer><script>setLoadingBarProgress(80)</script><script>setLoadingBarProgress(60)</script></div><a class="s-top fas fa-arrow-up fa-fw" href="javascript:void(0)"></a></div><script src="https://cdn.jsdelivr.net/npm/jquery@3.4/dist/jquery.min.js"></script><script>var SEARCH_SERVICE="hexo",ROOT="/";ROOT.endsWith("/")||(ROOT+="/")</script><script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/instant_page.js" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script><script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script><script type="text/javascript">$(function(){Waves.attach(".flat-btn",["waves-button"]),Waves.attach(".float-btn",["waves-button","waves-float"]),Waves.attach(".float-btn-light",["waves-button","waves-float","waves-light"]),Waves.attach(".flat-box",["waves-block"]),Waves.attach(".float-box",["waves-block","waves-float"]),Waves.attach(".waves-image"),Waves.init()})</script><script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery-backstretch@2.1.18/jquery.backstretch.min.js"></script><script type="text/javascript">$(function(){var a=["https://cdn.ticsmatic.com/img/wallpaper/autumn-background-beautiful-bright-627823.jpg"];!function(a){for(var t=a.length;t--;){var r=Math.floor(Math.random()*t),c=a[r];a[r]=a[t],a[t]=c}}(a),$(".cover").backstretch(a,{duration:"20000",fade:"1500"})})</script><script src="https://cdn.ticsmatic.com/script/Valine.min.js"></script><script>var GUEST_INFO=["nick","mail","link"],meta="nick,mail,link".split(",").filter(function(i){return-1<GUEST_INFO.indexOf(i)}),valine=new Valine;valine.init({el:"#valine_container",meta:meta,appId:"VNmRxpFEai4571pMche8o8ir-gzGzoHsz",appKey:"x06wrMifXe5j784k7CEk9zNA",placeholder:"快来评论吧~",pageSize:"10",avatar:"mp",lang:"zh-cn",visitor:"false",highlight:"true",mathJax:"false"})</script><script src="/js/app.js"></script><script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.4/js/search.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script><script>function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="fas fa-copy"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-check-circle');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('fa-check-circle');
          $icon.addClass('fa-copy');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-times-circle');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('fa-times-circle');
          $icon.addClass('fa-copy');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);</script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script>let LAZY_LOAD_IMAGE = "";
  $(".article-entry").find("div.fancybox").find("img").each(function () {
      var element = document.createElement("a");
      $(element).attr("data-fancybox", "gallery");
      $(element).attr("href", $(this).attr("src"));
      /* 图片采用懒加载处理时,
       * 一般图片标签内会有个属性名来存放图片的真实地址，比如 data-original,
       * 那么此处将原本的属性名src替换为对应属性名data-original,
       * 修改如下
       */
       if (LAZY_LOAD_IMAGE) {
         $(element).attr("href", $(this).attr("data-original"));
       }
      $(this).wrap(element);
  });</script><script>setLoadingBarProgress(100)</script></body></html>
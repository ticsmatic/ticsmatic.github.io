<!DOCTYPE html><html><head hexo-theme="https://volantis.js.org/#2.6.3"><meta charset="utf-8"><meta name="renderer" content="webkit"><meta name="force-rendering" content="webkit"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="HandheldFriendly" content="True"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><title>关联对象(Associated)详解 - ticsmatic</title><meta name="description" content="学习MJ的视频课程，整理总结知识点–关联对象(Associated)详解本文通过runtime中objc_setAssociatedObject源码为切入点，同时结合category的底层结构(struct category_t)、对象的底层结构(objc_object)，类的底层结构(objc_class)来讲..."><link rel="alternate" href="/atom.xml" title="ticsmatic"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css"><link rel="shortcut icon" type="image/x-icon" href="https://cdn.ticsmatic.com/img/favicon.png"><link rel="stylesheet" href="/css/style.css"><script>function setLoadingBarProgress(e){document.getElementById("loading-bar").style.width=e+"%"}</script></head><body><div id="loading-bar-wrapper"><div id="loading-bar"></div></div><header class="l_header shadow blur"><div class="container"><div class="wrapper"><div class="nav-sub"><p class="title"></p><ul class="switcher nav-list-h"><li><a class="s-comment fas fa-comments fa-fw" target="_self" href="javascript:void(0)"></a></li><li><a class="s-toc fas fa-list fa-fw" target="_self" href="javascript:void(0)"></a></li></ul></div><div class="nav-main"><a class="title flat-box" target="_self" href="/">ticsmatic</a><div class="menu navigation"><ul class="nav-list-h"><li><a class="flat-box" href="/" id="home"><i class="fas fa-rss fa-fw"></i>博文</a></li><li><a class="flat-box" href="/archives/" id="archives"><i class="fas fa-archive fa-fw"></i>归档</a></li><li><a class="flat-box" href="/categories/" id="categories"><i class="fas fa-folder-open fa-fw"></i>分类</a></li><li><a class="flat-box" href="/tags/" id="tags"><i class="fas fa-tags fa-fw"></i>标签</a></li><li><a class="flat-box" href="/about/" id="about"><i class="fas fa-info-circle fa-fw"></i>关于</a></li></ul></div><div class="m_search"><form name="searchform" class="form u-search-form"><i class="icon fas fa-search fa-fw"></i> <input type="text" class="input u-search-input" placeholder="Search..."></form></div><ul class="switcher nav-list-h"><li><a class="s-search fas fa-search fa-fw" target="_self" href="javascript:void(0)"></a></li><li><a class="s-menu fas fa-bars fa-fw" target="_self" href="javascript:void(0)"></a><ul class="menu-phone list-v navigation white-box"><li><a class="flat-box" href="/" id="home"><i class="fas fa-rss fa-fw"></i>博文</a></li><li><a class="flat-box" href="/archives/" id="archives"><i class="fas fa-archive fa-fw"></i>归档</a></li><li><a class="flat-box" href="/categories/" id="categories"><i class="fas fa-folder-open fa-fw"></i>分类</a></li><li><a class="flat-box" href="/tags/" id="tags"><i class="fas fa-tags fa-fw"></i>标签</a></li><li><a class="flat-box" href="/about/" id="about"><i class="fas fa-info-circle fa-fw"></i>关于</a></li></ul></li></ul></div></div></div></header><script>setLoadingBarProgress(40)</script><div class="l_body nocover"><div class="body-wrapper"><div class="l_main"><article id="post" class="post white-box shadow article-type-post" itemscope itemprop="blogPost"><section class="meta"><div class="meta" id="header-meta"><h1 class="title"><a href="/p/4bdf012b/">关联对象(Associated)详解</a></h1><div class="new-meta-box"><div class="new-meta-item date"><a class="notlink"><i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i><p>2020-05-03</p></a></div><div class="new-meta-item browse busuanzi"><a class="notlink"><i class="fas fa-eye fa-fw" aria-hidden="true"></i><p><span id="busuanzi_value_page_pv"><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span></p></a></div></div><hr></div></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><p>学习MJ的视频课程，整理总结知识点–关联对象(Associated)详解</p><p>本文通过runtime中<code>objc_setAssociatedObject</code>源码为切入点，同时结合category的底层结构(<code>struct category_t</code>)、对象的底层结构(<code>objc_object</code>)，类的底层结构(<code>objc_class</code>)来讲解OC中的对象关联对象。主要回答：1、为什么分类不能添加属性(根本原因)、2、分类中怎样才能添加属性(关联对象)、3、关联对象的原理。</p><a id="more"></a><h2 id="分类为什么不能添加属性"><a href="#分类为什么不能添加属性" class="headerlink" title="分类为什么不能添加属性"></a>分类为什么不能添加属性</h2><p>最初学习OC编程的时候，已经知道category中不能直接添加属性，当时很好奇为什么category这么方便的东西不能直接使用属性，后来查资料知道不能直接添加属性是因为底层结构设计导致不允许。当时也只是停留在概念阶段，对于底层原因不够明了，这次通过较系统的学习，有了一定的知识储备后，再来讲解分类为什么不能添加属性。</p><p>结合我之前的<code>Category的本质</code>文章，我们已经知道category的底层结构是<code>struct category_t</code>，它在编译阶段是结构体，在运行时，runtime会把category的结构体里面的信息加载到对应的class中去。同时，我们也知道<code>struct category_t</code>的结构体有保存的主要有实例方法列表<code>instanceMethods</code>、类方法列表<code>classMethods</code>、协议列表<code>protocols</code>、实例属性列表<code>instanceProperties</code>、类属性列表<code>_classProperties</code>等。但没有成员成员变量列表<code>ivars</code>。这就直接表明category中没有成员变量这个东西。所以即使利用<code>@property</code>关键字给分类增加属性，也只能增加set方法和get方法的声明，不会有实现，也会有对应的成员变量。</p><p>真实因为category的结构体中不能保存成员变量，就决定了在OC中category是没有成员变量的，这是直接原因。</p><p>下面，我们思考下category不能直接添加属性，根本原因是什么？为什么在设计category底层结构时不增加一个类似成员变量的东西? 下面我结合之前的文章，分析并解答。</p><p>结合我之前的<code>OC对象的本质</code>这篇文章可以知道，<strong>成员变量在内存中是存储在OC对象内部的</strong>，这一点很重要。而方法列表、属性列表、协议列表是存储在类的内部。同时，OC对象的大小和内存布局是在编译完后就决定的了。而category存储的信息是在运行时才添加到class上，但此时，对象的大小和 内存布局已确定，假如category中有成员变量，假如成员变量能添加到对象里，那么对象的结构和大小肯定要变化，两者相悖。所以category中的是不能有成员变量的。</p><p>毕竟category是Objective-C 2.0之后添加的语言特性，category的主要作用是为已经存在的类添加方法。同时，OC是基于C语言这门静态语言的扩展，虽然OC有小巧的runtime实现动态性，但它并不完全是一门动态语言。</p><p>在语言设计上，OC在1.0版本时，更多的是在C语言这门静态语言的扩展，然后加上Smalltalk的消息机制。在OC2.0时，优化了runtime，但是category的设计目的是为类增加方法，加上C语言这个底子及OC1.0设计时的历史原因，OC2.0中category增加成员变量比较困难，同时重要性不是很高，所以category不能直接成员变量。但是提供了 <em>第三方管理者</em> 来实现category间接添加属性。</p><p>这部分在objc源码中也能有所体现</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Class realizeClassWithoutSwift(Class cls, Class previously)</span><br><span class="line">&#123;</span><br><span class="line">    auto ro = (<span class="keyword">const</span> class_ro_t *)cls-&gt;data();</span><br><span class="line">    auto isMeta = ro-&gt;flags &amp; RO_META;</span><br><span class="line">    <span class="keyword">if</span> (ro-&gt;flags &amp; RO_FUTURE) &#123;</span><br><span class="line">        <span class="comment">// This was a future class. rw data is already allocated.</span></span><br><span class="line">        rw = cls-&gt;data();</span><br><span class="line">        ro = cls-&gt;data()-&gt;ro();</span><br><span class="line">        ASSERT(!isMeta);</span><br><span class="line">        cls-&gt;changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Normal class. Allocate writeable class data.</span></span><br><span class="line">        rw = objc::zalloc&lt;class_rw_t&gt;();</span><br><span class="line">        rw-&gt;set_ro(ro);</span><br><span class="line">        rw-&gt;flags = RW_REALIZED|RW_REALIZING|isMeta;</span><br><span class="line">        cls-&gt;setData(rw);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>类的方法、属性等在编译期保存在data()的位置，在运行期，直到<code>realizeClassWithoutSwift</code>执行之后，才放到了<code>class_rw_t</code>指向的只读区域<code>const class_ro_t</code>。</p><blockquote><p>ps：这块内容主要是自己结合源码分析进行的总结，有错误或不严谨的地方请指出</p></blockquote><h2 id="分类怎样才能添加属性"><a href="#分类怎样才能添加属性" class="headerlink" title="分类怎样才能添加属性"></a>分类怎样才能添加属性</h2><p>我们已经知道了分类不能添加属性的直接原因和根本，但是我们在使用category时，很多时候还是需要用属性的set和get方法的。接下来我们探讨分类中间接添加属性的方式。</p><p>默认情况下，因为分类底层结构的限制，不能添加成员变量到分类中。但可以通过关联对象来间接实现</p><p>关联对象提供了以下API</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加关联对象</span></span><br><span class="line"><span class="keyword">void</span> objc_setAssociatedObject(<span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> * key, <span class="keyword">id</span> value, objc_AssociationPolicy policy)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得关联对象</span></span><br><span class="line"><span class="keyword">id</span> objc_getAssociatedObject(<span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> * key)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除所有的关联对象</span></span><br><span class="line"><span class="keyword">void</span> objc_removeAssociatedObjects(<span class="keyword">id</span> object)</span><br></pre></td></tr></table></figure><h3 id="key的常见用法"><a href="#key的常见用法" class="headerlink" title="key的常见用法"></a>key的常见用法</h3><p>用于关联对象的key<code>const void * key</code>，说明只要求是个指向常量的指针，使用static时为了限制key的作用域。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *MyKey = &amp;MyKey;</span><br><span class="line">objc_setAssociatedObject(obj, MyKey, value, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">objc_getAssociatedObject(obj, MyKey);</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> MyKey;</span><br><span class="line">objc_setAssociatedObject(obj, &amp;MyKey, value, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">objc_getAssociatedObject(obj, &amp;MyKey);</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用属性名作为key</span></span><br><span class="line">bjc_setAssociatedObject(obj, <span class="string">@"property"</span>, value, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">objc_getAssociatedObject(obj, <span class="string">@"property"</span>);</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用get方法的@selecor作为key</span></span><br><span class="line">objc_setAssociatedObject(obj, <span class="keyword">@selector</span>(<span class="keyword">getter</span>), value, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">objc_getAssociatedObject(obj, <span class="keyword">@selector</span>(<span class="keyword">getter</span>));</span><br></pre></td></tr></table></figure><p>这里更推荐最后一种写法，原因如下</p><ol><li>明了是为哪个属性进行的绑定，比较接近属性set和get</li><li>不用额外定义key</li><li>自带语法提示</li></ol><h2 id="关联对象的原理"><a href="#关联对象的原理" class="headerlink" title="关联对象的原理"></a>关联对象的原理</h2><p>关联对象是runtime的一部分，所以我们直接看源码即可</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> objc_setAssociatedObject(<span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">id</span> value, objc_AssociationPolicy policy) &#123;</span><br><span class="line">    _object_set_associative_reference(object, (<span class="keyword">void</span> *)key, value, policy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置关联对象的核心源码</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _object_set_associative_reference(<span class="keyword">id</span> object, <span class="keyword">void</span> *key, <span class="keyword">id</span> value, uintptr_t policy) &#123;</span><br><span class="line">    <span class="comment">// retain the new value (if any) outside the lock.</span></span><br><span class="line">    ObjcAssociation old_association(<span class="number">0</span>, <span class="literal">nil</span>);</span><br><span class="line">    <span class="keyword">id</span> new_value = value ? acquireValue(value, policy) : <span class="literal">nil</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        AssociationsHashMap &amp;associations(manager.associations());</span><br><span class="line">        disguised_ptr_t disguised_object = DISGUISE(object);</span><br><span class="line">        <span class="keyword">if</span> (new_value) &#123;</span><br><span class="line">            <span class="comment">// break any existing association.</span></span><br><span class="line">            AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">            <span class="keyword">if</span> (i != associations.end()) &#123;</span><br><span class="line">                <span class="comment">// secondary table exists</span></span><br><span class="line">                ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">                <span class="keyword">if</span> (j != refs-&gt;end()) &#123;</span><br><span class="line">                    old_association = j-&gt;second;</span><br><span class="line">                    j-&gt;second = ObjcAssociation(policy, new_value);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    (*refs)[key] = ObjcAssociation(policy, new_value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// create the new association (first time).</span></span><br><span class="line">                ObjectAssociationMap *refs = new ObjectAssociationMap;</span><br><span class="line">                associations[disguised_object] = refs;</span><br><span class="line">                (*refs)[key] = ObjcAssociation(policy, new_value);</span><br><span class="line">                object-&gt;setHasAssociatedObjects();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// setting the association to nil breaks the association.</span></span><br><span class="line">            AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">            <span class="keyword">if</span> (i !=  associations.end()) &#123;</span><br><span class="line">                ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">                <span class="keyword">if</span> (j != refs-&gt;end()) &#123;</span><br><span class="line">                    old_association = j-&gt;second;</span><br><span class="line">                    refs-&gt;erase(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// release the old value (outside of the lock).</span></span><br><span class="line">    <span class="keyword">if</span> (old_association.hasValue()) ReleaseValue()(old_association);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以总结如下流程<br><img src="https://cdn.ticsmatic.com/img/2020-05-13/15893637992826.png" alt="关联对象"><br>得出如下结论：</p><ol><li>关联对象存储在全局的统一的一个AssociationsManager中</li><li>AssociationsManager里面有一个_map，管理每个对象的对象关联ObjectAssociationMap</li><li>ObjectAssociationMap的key保存的就是外界传递进来的参数<code>key</code>，value保存的就是关联值，里面包含<code>policy</code>、<code>value</code>。</li><li>设置关联对象为nil，就相当于是移除关联对象</li><li>AssociationsManager添加了锁，并自己做旧值的释放</li></ol><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>至于protocol，我们看它的源码</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> protocol_t : objc_object &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *mangledName;</span><br><span class="line">    <span class="keyword">struct</span> protocol_list_t *protocols;</span><br><span class="line">    method_list_t *instanceMethods;</span><br><span class="line">    method_list_t *classMethods;</span><br><span class="line">    method_list_t *optionalInstanceMethods;</span><br><span class="line">    method_list_t *optionalClassMethods;</span><br><span class="line">    property_list_t *instanceProperties;</span><br><span class="line">    uint32_t size;   <span class="comment">// sizeof(protocol_t)</span></span><br><span class="line">    uint32_t flags;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过源码可知，protocol的结构有一点类似category。<br>而且，protocol也是没有成员变量列表的，有getter、setter方法的声明，但是没有方法的实现。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>category不能直接添加属性的原因<br>直接原因：category内部没有用于存储ivar的地方<br>根本原因：</p><ol><li>OC是最初是基于C语言+Smalltalk，category是OC2.0才有的特性，当时的语言发展史已经决定了类在编译阶段就决定了对象的大小和内存布局。而且OC对象的成员变量是保存在对象中的。</li><li>category的设计初衷是为类添加方法。<br>这两个条件决定了为category添加变量的需求不是很高，相对于对OC底层大幅改动从而实现在category中直接添加变量，语言的设计者采取<code>第三方管理者(关联对象)</code>来间接实现添加成员变量</li></ol></li><li><p>关联对象使用<br>个人建议使用@selector(getter)作为关联对象的key</p></li><li><p>关联对象的原理<br>使用一个全局的AssociationsManager，它的内部有一个map，map的key对应要关联的对象，value保存的是ObjectAssociationMap，这个ObjectAssociationMap关联key和值信息。<br>这一部分看上面总结的图会更清晰</p></li></ol><h2 id="参考和源码"><a href="#参考和源码" class="headerlink" title="参考和源码"></a>参考和源码</h2><p>Apple Source Browser - <a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">objc</a></p><div class="article_footer"><section class="widget copyright desktop mobile"><div class="content"><blockquote><p>博客内容遵循 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</p><p>本文永久链接是：<a href="https://ticsmatic.com/p/4bdf012b/">https://ticsmatic.com/p/4bdf012b/</a></p></blockquote></div></section><section class="widget qrcode desktop mobile"><div class="content article-entry"></div></section></div></div><section class="meta" id="footer-meta"><div class="new-meta-box"><div class="new-meta-item date" itemprop="dateUpdated" datetime="2020-05-14T09:51:32+08:00"><a class="notlink"><i class="fas fa-edit fa-fw" aria-hidden="true"></i><p>更新于：2020-05-14</p></a></div><div class="new-meta-item share -mob-share-list"><div class="-mob-share-list share-body"><a class="-mob-share-qq" rel="external nofollow noopener noreferrer noopener" href="http://connect.qq.com/widget/shareqq/index.html?url=https://ticsmatic.com/p/4bdf012b/&title=关联对象(Associated)详解 - ticsmatic&summary=学习MJ的视频课程，整理总结知识点–关联对象(Associated)详解本文通过runtime中objc_setAssociatedObject源码为切入点，同时结合category的底层结构(struct category_t)、对象的底层结构(objc_object)，类的底层结构(objc_class)来讲解OC中的对象关联对象。主要回答：1、为什么分类不能添加属性(根本原因)、2、分类中怎样才能添加属性(关联对象)、3、关联对象的原理。" target="_blank"><img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/qq.png"> </a><a class="-mob-share-qzone" rel="external nofollow noopener noreferrer noopener" href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://ticsmatic.com/p/4bdf012b/&title=关联对象(Associated)详解 - ticsmatic&summary=学习MJ的视频课程，整理总结知识点–关联对象(Associated)详解本文通过runtime中objc_setAssociatedObject源码为切入点，同时结合category的底层结构(struct category_t)、对象的底层结构(objc_object)，类的底层结构(objc_class)来讲解OC中的对象关联对象。主要回答：1、为什么分类不能添加属性(根本原因)、2、分类中怎样才能添加属性(关联对象)、3、关联对象的原理。" target="_blank"><img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/qzone.png"> </a><a class="-mob-share-weibo" rel="external nofollow noopener noreferrer noopener" href="http://service.weibo.com/share/share.php?url=https://ticsmatic.com/p/4bdf012b/&title=关联对象(Associated)详解 - ticsmatic&summary=学习MJ的视频课程，整理总结知识点–关联对象(Associated)详解本文通过runtime中objc_setAssociatedObject源码为切入点，同时结合category的底层结构(struct category_t)、对象的底层结构(objc_object)，类的底层结构(objc_class)来讲解OC中的对象关联对象。主要回答：1、为什么分类不能添加属性(根本原因)、2、分类中怎样才能添加属性(关联对象)、3、关联对象的原理。" target="_blank"><img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/weibo.png"></a><div class="hoverbox"><a><img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/wechat.png"></a><div class="target"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAARgAAAEYCAAAAACi5bZQAAADB0lEQVR42u3aQXIbMQwEQP//08kDEpU4A0olyM2bXLvksn2ZAvDzx/rv+kEABgwYMGDArIH5Kdc/Gz74e/rco3Oe/b51HzBgwIABAwbMPpjjABQ+n+7zCOAW/NPzwIABAwYMGDBrYZ4GoDJ4TS96+t74PmDAgAEDBgyYXwfTAk0LVelzYMCAAQMGDBgwLUDbyFuffMGAAQMGDBgwL4eJG1QvasC9Kli+rRMJBgwYMGDAgHkbTD0w/KG/rw1AgwEDBgwYMGA+FuZ2MGsbYqcFqnTwKL4PGDBgwIABA2YNTBuQ0sbYFDA9pwUFAwYMGDBgwOyBeXWjLYU9BWuhjweHwIABAwYMGDDrYKYNrzQ4tvtMC2MP9wEDBgwYMGDArIFJg9e0wHSrsdZC1BNVYMCAAQMGDJiPh0kbWrcaYilYWpg6fg8MGDBgwIABsxbmNJi1haBpELx9PhgwYMCAAQPm+2Da4DcdJJoGtXGwBAMGDBgwYMCsgWkv0AbBaYMv3T++BxgwYMCAAQNmPUwbuG4FtbjAdKlgBgYMGDBgwIDZA9NueAqRPtcWxqYDRmDAgAEDBgyYvTDvGsx51SBQ29CLO5FgwIABAwYMmI+BSQ86vdhtuLSBVgdFMGDAgAEDBsw6mGmhp/3gNvil+x0HRDBgwIABAwbMGph2wKaFOf1HpIWra4UxMGDAgAEDBsw6mLRA1a5T+LhRNhx0AgMGDBgwYMDsh7k9KNQO8rTAaaA8DnhgwIABAwYMmLUwaZBqA9d0IGgcLMGAAQMGDBgwa2Cma/qBbQOtLWA9/Q0GDBgwYMCAWQNzKzC1hag2OJ6eFw8YgQEDBgwYMGDWwaSBbtqgmzbY2kZgHPDAgAEDBgwYMGtg2gCVBrZpY+1Woew44IEBAwYMGDBgvh7mVsHrNFi2wG8PeGDAgAEDBgyYj4VJG2lpoakteMWDRmDAgAEDBgyYtTBpw23aMGv3n34XGDBgwIABA+Z7YNoCU9tYS/e5HuQevQcGDBgwYMCAWQNjgQEDBgwYMGCWrb8VBGK7L/hLywAAAABJRU5ErkJggg=="></div></div></div></div></div></section><div class="prev-next"><a class="prev" href="/p/4235a91d/"><p class="title"><i class="fas fa-chevron-left" aria-hidden="true"></i>load initialize的本质</p><p class="content">学习MJ的视频课程，整理总结知识点–load initialize的本质这一篇通过+load和+initialize的官方文档并结合Demo来介绍这两个方法。同时会依据runtime源码来介绍+...</p></a><a class="next" href="/p/e15d38f8/"><p class="title">Category的本质<i class="fas fa-chevron-right" aria-hidden="true"></i></p><p class="content">学习MJ的视频课程，整理总结知识点–Category的本质[TOC]Category基本使用category 是对装饰模式的一种具体实现。它的主要作用是在不改变原有类的前提下，动态地给这个类添加...</p></a></div></section></article><article class="post white-box comments shadow"><section class="article typo"><p ct><i class="fas fa-comments"></i> 评论</p><section id="comments"><div id="valine_container" class="valine_thread"><i class="fas fa-cog fa-spin fa-fw fa-2x"></i></div></section></section></article><script>window.subData={title:"关联对象(Associated)详解",tools:!0}</script></div><aside class="l_side"><section class="widget toc-wrapper shadow desktop mobile"><header><i class="fas fa-list fa-fw" aria-hidden="true"></i><span class="name">本文目录</span></header><div class="content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#分类为什么不能添加属性"><span class="toc-text">分类为什么不能添加属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分类怎样才能添加属性"><span class="toc-text">分类怎样才能添加属性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#key的常见用法"><span class="toc-text">key的常见用法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#关联对象的原理"><span class="toc-text">关联对象的原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#拓展"><span class="toc-text">拓展</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考和源码"><span class="toc-text">参考和源码</span></a></li></ol></div></section></aside><footer class="clearfix"><br><br><br><div class="social-wrapper"><a href="/atom.xml" class="social fas fa-rss flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="mailto:ticsmatics@gmail.com" class="social fas fa-envelope flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="https://github.com/ticsmatic" class="social fab fa-github flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a></div><div class="copyright"><p><a href="https://ticsmatic.com">Copyright © 2016-2020 ticsmatic</a></p></div></footer><script>setLoadingBarProgress(80)</script><script>setLoadingBarProgress(60)</script></div><a class="s-top fas fa-arrow-up fa-fw" href="javascript:void(0)"></a></div><script src="https://cdn.jsdelivr.net/npm/jquery@3.4/dist/jquery.min.js"></script><script>var SEARCH_SERVICE="hexo",ROOT="/";ROOT.endsWith("/")||(ROOT+="/")</script><script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/instant_page.js" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script><script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script><script type="text/javascript">$(function(){Waves.attach(".flat-btn",["waves-button"]),Waves.attach(".float-btn",["waves-button","waves-float"]),Waves.attach(".float-btn-light",["waves-button","waves-float","waves-light"]),Waves.attach(".flat-box",["waves-block"]),Waves.attach(".float-box",["waves-block","waves-float"]),Waves.attach(".waves-image"),Waves.init()})</script><script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery-backstretch@2.1.18/jquery.backstretch.min.js"></script><script type="text/javascript">$(function(){var a=["https://cdn.ticsmatic.com/img/wallpaper/autumn-background-beautiful-bright-627823.jpg"];!function(a){for(var t=a.length;t--;){var r=Math.floor(Math.random()*t),c=a[r];a[r]=a[t],a[t]=c}}(a),$(".cover").backstretch(a,{duration:"20000",fade:"1500"})})</script><script src="https://cdn.ticsmatic.com/script/Valine.min.js"></script><script>var GUEST_INFO=["nick","mail","link"],meta="nick,mail,link".split(",").filter(function(i){return-1<GUEST_INFO.indexOf(i)}),valine=new Valine;valine.init({el:"#valine_container",meta:meta,appId:"VNmRxpFEai4571pMche8o8ir-gzGzoHsz",appKey:"x06wrMifXe5j784k7CEk9zNA",placeholder:"快来评论吧~",pageSize:"10",avatar:"mp",lang:"zh-cn",visitor:"false",highlight:"true",mathJax:"false"})</script><script src="/js/app.js"></script><script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.4/js/search.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script><script>function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="fas fa-copy"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-check-circle');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('fa-check-circle');
          $icon.addClass('fa-copy');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-times-circle');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('fa-times-circle');
          $icon.addClass('fa-copy');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);</script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script>let LAZY_LOAD_IMAGE = "";
  $(".article-entry").find("div.fancybox").find("img").each(function () {
      var element = document.createElement("a");
      $(element).attr("data-fancybox", "gallery");
      $(element).attr("href", $(this).attr("src"));
      /* 图片采用懒加载处理时,
       * 一般图片标签内会有个属性名来存放图片的真实地址，比如 data-original,
       * 那么此处将原本的属性名src替换为对应属性名data-original,
       * 修改如下
       */
       if (LAZY_LOAD_IMAGE) {
         $(element).attr("href", $(this).attr("data-original"));
       }
      $(this).wrap(element);
  });</script><script>setLoadingBarProgress(100)</script></body></html>
{"meta":{"title":"ticsmatic","subtitle":"路漫漫其修远兮 吾将上下而求索","description":"ticsmatic","author":"ticsmatic","url":"https://ticsmatic.com","root":"/"},"pages":[{"title":"404 Not Found","date":"2020-04-23T15:47:03.484Z","updated":"2020-04-23T15:47:03.481Z","comments":true,"path":"404.html","permalink":"https://ticsmatic.com/404.html","excerpt":"","text":"404很抱歉，您访问的页面不存在您可以邮件通知我"},{"title":"","date":"2020-04-23T08:57:26.688Z","updated":"2020-04-23T08:57:26.688Z","comments":true,"path":"baidu_verify_TchHVSjADz.html","permalink":"https://ticsmatic.com/baidu_verify_TchHVSjADz.html","excerpt":"","text":"TchHVSjADz"},{"title":"","date":"2020-04-23T08:57:43.168Z","updated":"2020-04-23T08:57:43.168Z","comments":true,"path":"baidu_verify_WIV2O9P8jO.html","permalink":"https://ticsmatic.com/baidu_verify_WIV2O9P8jO.html","excerpt":"","text":"WIV2O9P8jO"},{"title":"","date":"2020-04-23T08:58:24.349Z","updated":"2020-04-23T08:58:24.349Z","comments":true,"path":"google381672dcc63a6da1.html","permalink":"https://ticsmatic.com/google381672dcc63a6da1.html","excerpt":"","text":"google-site-verification: google381672dcc63a6da1.html"},{"title":"所有分类","date":"2020-04-20T14:24:30.315Z","updated":"2020-04-20T14:24:30.302Z","comments":true,"path":"categories/index.html","permalink":"https://ticsmatic.com/categories/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2020-04-23T09:41:51.643Z","updated":"2020-04-23T09:41:51.603Z","comments":true,"path":"tags/index.html","permalink":"https://ticsmatic.com/tags/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-04-20T14:24:02.843Z","updated":"2020-04-20T14:24:02.827Z","comments":true,"path":"about/index.html","permalink":"https://ticsmatic.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"Runloop","slug":"day17-Runloop基本认识、模式","date":"2020-05-30T06:09:14.000Z","updated":"2020-05-31T03:34:00.275Z","comments":true,"path":"p/d4d0b04c/","link":"","permalink":"https://ticsmatic.com/p/d4d0b04c/","excerpt":"学习MJ的视频课程，整理总结知识点–Runloop","text":"学习MJ的视频课程，整理总结知识点–Runloop[NSRunLoop mainRunLoop] CFRunLoopGetMain()基本认识CFRunLoopModeRef1234567891011121314151617181920212223242526struct __CFRunLoop &#123; CFRuntimeBase _base; pthread_mutex_t _lock; /* locked for accessing mode list */ __CFPort _wakeUpPort; // used for CFRunLoopWakeUp Boolean _unused; volatile _per_run_data *_perRunData; // reset for runs of the run loop pthread_t _pthread; uint32_t _winthread; CFMutableSetRef _commonModes; CFMutableSetRef _commonModeItems; CFRunLoopModeRef _currentMode; CFMutableSetRef _modes; struct _block_item *_blocks_head; struct _block_item *_blocks_tail; CFAbsoluteTime _runTime; CFAbsoluteTime _sleepTime; CFTypeRef _counterpart;&#125;;struct __CFRunLoop &#123; pthread_t _pthread; CFMutableSetRef _commonModes; CFMutableSetRef _commonModeItems; CFRunLoopModeRef _currentMode; CFMutableSetRef _modes;&#125;;NSRunloop是对CFRunloop的一层包装source0触摸事件 lldb: bt调试performSelector:onThread:source1基于Port的线程间通信的系统事件捕捉timersNSTimerperformSelector:withObject:afterDelay:observes监听Runloop的状态UI界面刷新(BeforeWaiting)(self.view.backgroundColor = color)AutoreleasePool(BeforeWaiting)Runloop循环处理某种模式下的source0、source1、timers、observesCFRunLoopObserverRef用observer监听RunLoop的运行状态beforeWaiting 即将睡觉afterWaiting 睡完醒了总结Runloop循环处理某种模式下的source0、source1、timers、observes参考和源码源码：","categories":[],"tags":[]},{"title":"Runloop","slug":"day19-多线程","date":"2020-05-30T06:09:14.000Z","updated":"2020-06-03T00:45:58.668Z","comments":true,"path":"p/d4d0b04c/","link":"","permalink":"https://ticsmatic.com/p/d4d0b04c/","excerpt":"学习MJ的视频课程，整理总结知识点–Runloop","text":"学习MJ的视频课程，整理总结知识点–Runloop介绍GCD使用sync同步意味着只能在当前线程执行，不具备开启线程的能力async可能在新开的线程执行（特列：异步主队列主执行，不能开新线程）并发队列、串行队列队列的类型，决定了任务的执行方式（并发、串行）总结死锁面试题面试题1、gcd产生死锁1234567891011121314- (void)interview01 &#123; // 问题：以下代码是在主线程执行的，会不会产生死锁？会！ NSLog(@\"执行任务1\"); // 主队列里已经有任务，有添加了一个任务，FIFO串行执行，旧的任务interview01没执行完，还要立马执行新任务@\"执行任务2\"，两者之间互相死等 dispatch_queue_t queue = dispatch_get_main_queue(); dispatch_sync(queue, ^&#123; NSLog(@\"执行任务2\"); &#125;); NSLog(@\"执行任务3\"); // dispatch_sync立马在当前线程同步执行任务&#125;队列：排队 FIFO从主队类取任务，得等上一个任务执行完，sync要求立马在当前线程执行任务，执行完毕才能继续往下走。面试题212345678910111213- (void)interview02 &#123; // 问题：以下代码是在主线程执行的，会不会产生死锁？不会！ NSLog(@\"执行任务1\"); dispatch_queue_t queue = dispatch_get_main_queue(); dispatch_async(queue, ^&#123; NSLog(@\"执行任务2\"); &#125;); NSLog(@\"执行任务3\"); // dispatch_async不要求立马在当前线程同步执行任务&#125;异步主队类执行，不会死锁async：不要求里面在当前线程同步执行执行时已经出了函数栈面试题3123456789101112131415161718- (void)interview03&#123; // 问题：以下代码是在主线程执行的，会不会产生死锁？会！ NSLog(@\"执行任务1\"); dispatch_queue_t queue = dispatch_queue_create(\"myqueu\", DISPATCH_QUEUE_SERIAL); dispatch_async(queue, ^&#123; // 0 NSLog(@\"执行任务2\"); dispatch_sync(queue, ^&#123; // 1 NSLog(@\"执行任务3\"); &#125;); NSLog(@\"执行任务4\"); &#125;); NSLog(@\"执行任务5\");&#125;很重要的结论：sync当前的串行队列都会死锁面试题4sync在其它队列，木问题面试题5并发队列，内部sync木问题，队列中的任务会并发执行12345678910111213141516171819- (void)interview05&#123; // 问题：以下代码是在主线程执行的，会不会产生死锁？不会！ NSLog(@\"执行任务1\"); dispatch_queue_t queue = dispatch_queue_create(\"myqueu\", DISPATCH_QUEUE_CONCURRENT); dispatch_async(queue, ^&#123; // 0 NSLog(@\"执行任务2\"); dispatch_sync(queue, ^&#123; // 1 NSLog(@\"执行任务3\"); &#125;); NSLog(@\"执行任务4\"); &#125;); NSLog(@\"执行任务5\");&#125;全局并发队列、自定义并发队列的区别dispatch_queue_t queue1 = dispatch_get_global_queue(0, 0);两个全局并发队列的内存地址一样，位域内存中的Global区dispatch_queue_t queue3 = dispatch_queue_create(&quot;queu3&quot;, DISPATCH_QUEUE_CONCURRENT);每个自定义并发队列的内存地址不一样，位域内存中的堆区总结参考和源码源码：","categories":[],"tags":[]},{"title":"GCD定时器、内存布局、Tagged Pointer","slug":"day24-GCD定时器、内存布局、Tagged Pointer","date":"2020-05-30T06:09:14.000Z","updated":"2020-06-09T14:25:57.233Z","comments":true,"path":"p/24a6731c/","link":"","permalink":"https://ticsmatic.com/p/24a6731c/","excerpt":"学习MJ的视频课程，整理总结知识点–GCD定时器、内存布局、Tagged Pointer","text":"学习MJ的视频课程，整理总结知识点–GCD定时器、内存布局、Tagged PointerGCD定时器timer是添加到RunLoop中处理的，RunLoop每跑一圈检测一次timer是否满足触发条件，所以每一圈的时间是不确定的。NSTimer依赖于RunLoop，如果RunLoop的任务过于繁重，可能会导致NSTimer不准时GCD的定时器是直接与内核挂钩的，与RunLoop无关，所以是比较精确的GCD定时器的封装内存布局堆空间内存对齐，最后位肯定是0Tagged Pointer从64bit开始，iOS引入了Tagged Pointer技术，用于优化NSNumber、NSDate、NSString等小对象的存储在没有使用Tagged Pointer之前， NSNumber等对象需要动态分配内存、维护引用计数等，NSNumber指针存储的是堆中NSNumber对象的地址值使用Tagged Pointer之后，NSNumber指针里面存储的数据变成了：Tag + Data，也就是将数据直接存储在了指针中当指针不够存储数据时，才会使用动态分配内存的方式来存储数据objc_msgSend能识别Tagged Pointer，比如NSNumber的intValue方法，直接从指针提取数据，节省了以前的调用开销如何判断一个指针是否为Tagged Pointer？iOS平台，最高有效位是1（第64bit）Mac平台，最低有效位是11234567891011121314151617// 不加锁的话会崩溃 多线程setter内部会重复调用对象的release方法dispatch_queue_t queue = dispatch_get_global_queue(0, 0);for (int i = 0; i &lt; 1000; i++) &#123; dispatch_async(queue, ^&#123; // 加锁 self.name = [NSString stringWithFormat:@\"abcdefghijk\"]; // 解锁 &#125;);&#125;// 不会崩溃，因为是tagged pointer，直接指针赋值，不存在release、retaindispatch_queue_t queue = dispatch_get_global_queue(0, 0);for (int i = 0; i &lt; 1000; i++) &#123; dispatch_async(queue, ^&#123; self.name = [NSString stringWithFormat:@\"abc\"]; &#125;);&#125;总结参考和源码源码：","categories":[],"tags":[]},{"title":"MRC、copy","slug":"day25-MRC、copy","date":"2020-05-30T06:09:14.000Z","updated":"2020-06-10T13:41:07.131Z","comments":true,"path":"p/bff81d76/","link":"","permalink":"https://ticsmatic.com/p/bff81d76/","excerpt":"学习MJ的视频课程，整理总结知识点–MRC、copy","text":"学习MJ的视频课程，整理总结知识点–MRC、copyMRC人、狗狗属于人，人存在狗就要存在，人死了，狗也得死。狗的内存管理交给人有两个狗，人换狗了，老狗要先释放set方法：release旧值，retain新值要判断是不是同一个狗，同一个狗的话就跳过，因为此时release旧值，导致狗的retaincount为0，狗会释放123456- (void)setDog:(MJDog *)dog &#123; if (_dog != dog) &#123; [_dog release]; _dog = [dog retain]; &#125;&#125;升级版使用@property@property， 编译器自动生成synthesize：自动生成成员变量和属性的setter、getter实现123456@property (nonatomic, retain) MJDog *dog;- (void)dealloc &#123; self.dog = nil; [super dealloc];&#125;MRC编程NSMutableArray的alloc方法，需要自己release，不是alloc或new或copy初始化的，比如[NSMutableArray array]初始化的，就不需要调用release，这个类方法内部实现会有类似autorelease函数的调用工厂方法，里面封装autoreleasecopy拷贝123456789101112131415根本// 拷贝的目的：产生一个副本对象，跟源对象互不影响// 修改了源对象，不会影响副本对象// 修改了副本对象，不会影响源对象/* iOS提供了2个拷贝方法 1.copy，不可变拷贝，产生不可变副本 2.mutableCopy，可变拷贝，产生可变副本 深拷贝和浅拷贝 1.深拷贝：内容拷贝，产生新的对象 2.浅拷贝：指针拷贝，没有产生新的对象 */不可变对象的copy，大家都是不可变，干脆指向同一块内容，所以生成的还是不可变对象可变对象的copy，都是深拷贝，生成不可变副本总结参考和源码源码：","categories":[],"tags":[]},{"title":"atomic、读写安全、定时器","slug":"day23-atomic、读写安全、定时器","date":"2020-05-30T06:09:14.000Z","updated":"2020-06-09T10:01:11.368Z","comments":true,"path":"p/63797d9b/","link":"","permalink":"https://ticsmatic.com/p/63797d9b/","excerpt":"学习MJ的视频课程，整理总结知识点–atomic、读写安全、定时器","text":"学习MJ的视频课程，整理总结知识点–atomic、读写安全、定时器atomicatomic：原子，不可再分割的单位保证setter和getter内部实现是线程同步的但是不能保证同时setter、getter时线程同步，要想实现setter、getter的安全，这两个函数内部要重写并自己加锁，或者在调用这两个函数的地方加锁。iPhone不适用：调用频率高，都加锁解锁耗性能1、atomic不能保证安全（同步锁），为何；如何保证Atomic使用的是自旋锁，在setter和getter加锁spinlock_t，不能保证真正的线程安全，如果多个线程同时读写这个值，某个线程就会获取到错误的值读写安全多读单写：读时可并发读、写仍然是单线程；读写之间也是互斥12pthread_rwlock：读写锁dispatch_barrier_async：异步栅栏调用pthread_rwlock等待锁的线程会进入休眠runtime源码中有不少地方用到pthread_rwlockdispatch_barrier_async这个函数传入的并发队列必须是自己通过dispatch_queue_cretate创建的如果传入的是一个串行或是一个全局的并发队列，那这个函数便等同于dispatch_async函数的效果1234567891011121314151617181920212223242526- (void)viewDidLoad &#123; [super viewDidLoad]; self.queue = dispatch_queue_create(\"rw_queue\", DISPATCH_QUEUE_CONCURRENT); for (int i = 0; i &lt; 10; i++) &#123; [self read]; [self read]; [self read]; [self write]; &#125;&#125;- (void)read &#123; dispatch_async(self.queue, ^&#123; sleep(1); NSLog(@\"read\"); &#125;);&#125;- (void)write &#123; dispatch_barrier_async(self.queue, ^&#123; sleep(1); NSLog(@\"write\"); &#125;);&#125;定时器CADisplayLinkNSTimer解决循环引用1、timer的block初始化方式2、自定义target，通过消息转发给原targetNSProxy特殊的类存在的意义：解决代理转发行为做消息转发的话相比NSObject效率更高，少了去父类搜索的流程和动态方法解析的阶段12345678910111213141516@implementation MJProxy+ (instancetype)proxyWithTarget:(id)target &#123; // NSProxy对象不需要调用init，因为它本来就没有init方法 MJProxy *proxy = [MJProxy alloc]; proxy.target = target; return proxy;&#125;- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel &#123; return [self.target methodSignatureForSelector:sel];&#125;- (void)forwardInvocation:(NSInvocation *)invocation &#123; [invocation invokeWithTarget:self.target];&#125;@endNSProxy大部分方法底层都没有实现，调用时很容易就消息转发了，会调用Target的方法总结参考和源码源码：","categories":[],"tags":[]},{"title":"weak指针、autorelease原理","slug":"day26-weak指针、autorelease原理","date":"2020-05-30T06:09:14.000Z","updated":"2020-06-11T01:36:09.590Z","comments":true,"path":"p/1abf6ce/","link":"","permalink":"https://ticsmatic.com/p/1abf6ce/","excerpt":"学习MJ的视频课程，整理总结知识点–weak指针、autorelease原理","text":"学习MJ的视频课程，整理总结知识点–weak指针、autorelease原理引用计数的存储存储位置对象释放weak指针的原理weak引用是存储在哈希表（弱引用表SideTable-&gt;weak_table），当对象dealloc时，dealloc方法会清除哈希表中对应的值关联对象表、引用计数表ARC帮我们做了什么LLVM+Runtime相互协作的结果利用LLVM自动帮我们生成release、retain、autorelease等内存管理相关的代码，弱引用的清除利用了Runtime运行时自动处理。autorelease原理clang源代码，发现__AtAutoreleasePool的两个关键的函数runtime中查看这两个函数的实现，发现调用的是AutoreleasePoolPage类的方法调用了autorelease的对象最终都是通过AutoreleasePoolPage对象来管理的研究AutoreleasePoolPage的结构多个pool，之间是通过双向链表联系知道每个pool内空间的分布调用push方法会将一个POOL_BOUNDARY入栈（插入边界标记），并且返回其存放的内存地址调用pop方法时传入一个POOL_BOUNDARY的内存地址，会从最后一个入栈的对象开始发送release消息，直到遇到这个POOL_BOUNDARYid *next指向了下一个能存放autorelease对象地址的区域查看的函数_objc_autoreleasePoolPrint();push流程，压边界标记，添加autorelease对象到page里pop流程，查找直到边界标记token，releaseautorelease总结对象存储在AutoreleasePoolPage，每个自动释放池插入自动释放对象前先插入POOL_BOUNDARY作为边界标记RunLoop与autoreleaseautorelease对象在什么时候会被释放1、被autoreleasepool包围的，出了括号就被释放2、在iOS项目中测试，并不是被main函数的autoreleasepool管理的，因为main函数里的autoreleasepool包围着主线程的RunLoop，是一直走不到autoreleasepool大括号结尾的1234567891011- (void)viewDidLoad &#123; [super viewDidLoad]; // 这个Person什么时候调用release，是由RunLoop来控制的 // 它可能是在某次RunLoop循环中，RunLoop休眠之前调用了release // MJPerson *person = [[[MJPerson alloc] init] autorelease]; MJPerson *person = [[MJPerson alloc] init]; NSLog(@\"%s\", __func__);&#125;123456789101112131415161718192021222324/* typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123; kCFRunLoopEntry = (1UL &lt;&lt; 0), 1 kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), 2 kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), 4 kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), 32 kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), 64 kCFRunLoopExit = (1UL &lt;&lt; 7), 128 kCFRunLoopAllActivities = 0x0FFFFFFFU &#125;; */ /* kCFRunLoopEntry push &lt;CFRunLoopObserver 0x60000013f220 [0x1031c8c80]&gt;&#123;valid = Yes, activities = 0x1, repeats = Yes, order = -2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x103376df2), context = &lt;CFArray 0x60000025aa00 [0x1031c8c80]&gt;&#123;type = mutable-small, count = 1, values = (\\n\\t0 : &lt;0x7fd0bf802048&gt;\\n)&#125;&#125; kCFRunLoopBeforeWaiting | kCFRunLoopExit kCFRunLoopBeforeWaiting pop、push kCFRunLoopExit pop &lt;CFRunLoopObserver 0x60000013f0e0 [0x1031c8c80]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x103376df2), context = &lt;CFArray 0x60000025aa00 [0x1031c8c80]&gt;&#123;type = mutable-small, count = 1, values = (\\n\\t0 : &lt;0x7fd0bf802048&gt;\\n)&#125;&#125; */总结参考和源码源码：","categories":[],"tags":[]},{"title":"性能优化-耗电、架构设计","slug":"day28-性能优化-耗电、架构设计","date":"2020-05-30T06:09:14.000Z","updated":"2020-06-14T15:16:29.312Z","comments":true,"path":"p/34aa13dd/","link":"","permalink":"https://ticsmatic.com/p/34aa13dd/","excerpt":"学习MJ的视频课程，整理总结知识点–性能优化-耗电、架构设计","text":"学习MJ的视频课程，整理总结知识点–性能优化-耗电、架构设计耗电优化APP的启动架构设计MVC结构图：Apple的结构， UITableViewControllerModel和View之间互相不知道，View和Model复用方便，Controller臃肿MVC变种结构图：项目迭代频繁，业务复杂，View和Model的成本很低，减少控制器业务逻辑优点：对Controller进行瘦身，将View内部的细节封装起来了，外界不知道View内部的具体实现缺点：View依赖于ModelMVP结构图：把MVC架构下，控制器的一部分功能挪到presenter里一个控制器可以有多个presenter，每个presenter封装处理一部分业务去网上再找找资料MVVM结构图核心：属性监听，View和ViewMode是双向绑定的View监听ViewModel属性的改变监听的方案：RAC、KVO、KVOController一个控制器可以有多个ViewMode，每个ViewMode封装处理一部分业务MVVM+RACVIPPERCDD分层架构界面层业务层数据层设计模式简介创建：结构：行为：delegate并不是代理模式，NSProxy更像代理模式总结参考和源码源码：","categories":[],"tags":[]},{"title":"性能优化-卡顿","slug":"day27-性能优化-卡顿","date":"2020-05-30T06:09:14.000Z","updated":"2020-06-14T15:11:18.653Z","comments":true,"path":"p/a073543c/","link":"","permalink":"https://ticsmatic.com/p/a073543c/","excerpt":"学习MJ的视频课程，整理总结知识点–性能优化-卡顿","text":"学习MJ的视频课程，整理总结知识点–性能优化-卡顿CPU和GPUCPU是处理器，GPU是了解屏幕的屏幕成像原理先垂直同步信号、再水平同步信号卡顿产生的原因垂直信号来了，就要显示，发现GPU还没渲染完，此时就会把上次GPU渲染的帧显示上去，当前GPU渲染的帧就会丢失，等待下一次垂直信号达到时渲染。按照60FPS的刷帧率，每隔16ms（1000/60）就会有一次VSync信号，所以要尽可能减少CPU和GPU的资源消耗。卡顿优化图片异步解码透明需要混合计算离屏渲染卡顿检测监听RunLoop状态切换的耗时LXDAppFluencyMonitor总结参考和源码源码：","categories":[],"tags":[]},{"title":"Runloop","slug":"day18-Runloop源码分析、线程保活、线程的封装","date":"2020-05-30T06:09:14.000Z","updated":"2020-06-02T13:52:58.580Z","comments":true,"path":"p/d4d0b04c/","link":"","permalink":"https://ticsmatic.com/p/d4d0b04c/","excerpt":"学习MJ的视频课程，整理总结知识点–Runloop","text":"学习MJ的视频课程，整理总结知识点–RunloopRunLoop的运行逻辑RunLoop 循环等待处理sources、timers，处理完睡觉MJ流程图介绍（熟悉）切换模式、线程销毁会推出Loop；循环2-10的步骤实践RunLoop的调用流程1234- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123; // 函数调用栈 LLDB中使用backtrace命令: bt NSLog(@\"111111\");&#125;1234567891011121314(lldb) bt* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 2.1 * frame #0: 0x00000001040f3571 Interview01-runloop流程`__29-[ViewController viewDidLoad]_block_invoke_2(.block_descriptor=0x00000001040f50c0) at ViewController.m:32:9 frame #1: 0x000000010440ddf0 libdispatch.dylib`_dispatch_call_block_and_release + 12 frame #2: 0x000000010440ed64 libdispatch.dylib`_dispatch_client_callout + 8 frame #3: 0x000000010441ce1c libdispatch.dylib`_dispatch_main_queue_callback_4CF + 1500 frame #4: 0x00007fff23afb699 CoreFoundation`__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__ + 9 frame #5: 0x00007fff23af62f9 CoreFoundation`__CFRunLoopRun + 2329 frame #6: 0x00007fff23af56b6 CoreFoundation`CFRunLoopRunSpecific + 438 frame #7: 0x00007fff3815cbb0 GraphicsServices`GSEventRunModal + 65 frame #8: 0x00007fff47162a67 UIKitCore`UIApplicationMain + 1621 frame #9: 0x00000001040f3680 Interview01-runloop流程`main(argc=1, argv=0x00007ffeebb0bc68) at main.m:14:16 frame #10: 0x00007fff5123bcf5 libdyld.dylib`start + 1 frame #11: 0x00007fff5123bcf5 libdyld.dylib`start + 1打印函数调用栈 btRunLoop执行流程源码分析，从CFRunLoopRunSpecific开始，在CFRunLoop.c中搜索CFRunLoopRunSpecific，找打对应的函数1234567891011121314151617181920212223242526SInt32 CFRunLoopRunSpecific(CFRunLoopRef rl, CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled) &#123; /* DOES CALLOUT */ CHECK_FOR_FORK(); if (__CFRunLoopIsDeallocating(rl)) return kCFRunLoopRunFinished; __CFRunLoopLock(rl); CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, modeName, false); if (NULL == currentMode || __CFRunLoopModeIsEmpty(rl, currentMode, rl-&gt;_currentMode)) &#123; Boolean did = false; if (currentMode) __CFRunLoopModeUnlock(currentMode); __CFRunLoopUnlock(rl); return did ? kCFRunLoopRunHandledSource : kCFRunLoopRunFinished; &#125; volatile _per_run_data *previousPerRun = __CFRunLoopPushPerRunData(rl); CFRunLoopModeRef previousMode = rl-&gt;_currentMode; rl-&gt;_currentMode = currentMode; int32_t result = kCFRunLoopRunFinished; if (currentMode-&gt;_observerMask &amp; kCFRunLoopEntry ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry); result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode); if (currentMode-&gt;_observerMask &amp; kCFRunLoopExit ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit); __CFRunLoopModeUnlock(currentMode); __CFRunLoopPopPerRunData(rl, previousPerRun); rl-&gt;_currentMode = previousMode; __CFRunLoopUnlock(rl); return result;&#125;调用细节CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION_CFRUNLOOP_IS_CALLING_OUT_TO…GCD的很多流程是不依赖RunLoop的，除了dispatch_async(dispatch_get_main_queue(), ^{});休眠细节线程休眠，操作系统内核层面API才能实现，实现：mach_msg函数用户态、内核态（操作系统的知识稍微补一下）等待消息没有消息就让线程休眠有消息就唤醒线程状态活动名状态模式两种，执行时互相隔离，互不影响应用控制线程的生命周期（线程保活）线程是默认执行完里面的任务后就会被自动销毁，有些场景需要经常在子线程做事情，但是一做完就销毁了，再次使用还要创建，频繁的创建销毁时比较浪费的。AFN避免线程频繁创建销毁，使用RunLoop来使线程做完事情后以休眠态阻塞线程，避免被销毁，达到保活的效果。保活基础代码如果Mode里没有任何Source0/Source1/Timer/Observer，RunLoop会立马退出123// 往RunLoop里面添加Source\\Timer\\Observer[[NSRunLoop currentRunLoop] addPort:[[NSPort alloc] init] forMode:NSDefaultRunLoopMode];[[NSRunLoop currentRunLoop] run];touchesBegan时让子线程做事情，完整代码如下1234567891011121314151617181920212223242526272829303132@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; MJThread *thread = [[MJThread alloc] initWithTarget:self selector:@selector(run) object:nil]; [thread start]; self.thread = thread;&#125;- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123; // 让线程做事情，RunLoop检测到performSelector:onThread:withObject会醒过来干活 [self performSelector:@selector(test) onThread:self.thread withObject:nil waitUntilDone:YES]; // 在子线程调用stop（waitUntilDone设置为YES，代表子线程的代码执行完毕后，这个方法才会往下走）&#125;#pragma mark - Action- (void)run &#123; NSLog(@\"start --%s\", __func__); // 往RunLoop里面添加Source\\Timer\\Observer [[NSRunLoop currentRunLoop] addPort:[[NSPort alloc] init] forMode:NSDefaultRunLoopMode]; [[NSRunLoop currentRunLoop] run]; NSLog(@\"end --%s\", __func__);&#125;// 子线程需要执行的任务- (void)test &#123; NSLog(@\"%s\", __func__);&#125;@end优化上面的代码，[MJThread alloc] initWithTarget:self thread会强引用target123456789MJThread *thread = [[MJThread alloc] initWithBlock:^&#123; NSLog(@\"start --%s\", __func__); // 往RunLoop里面添加Source\\Timer\\Observer [[NSRunLoop currentRunLoop] addPort:[[NSPort alloc] init] forMode:NSDefaultRunLoopMode]; [[NSRunLoop currentRunLoop] run]; NSLog(@\"end --%s\", __func__); &#125;];此时控制器可以正常销毁，但是线程还没销毁因为线程里面的block任务还没执行完毕，NSLog(@&quot;end --%s&quot;, __func__);还没执行run的注释run是个无限循环，想停止的话只能使用如下方法解决如下：123456789101112MJThread *thread = [[MJThread alloc] initWithBlock:^&#123; NSLog(@\"start --%s\", __func__); // 往RunLoop里面添加Source\\Timer\\Observer NSRunLoop *theRL = [NSRunLoop currentRunLoop]; [theRL addPort:[[NSPort alloc] init] forMode:NSDefaultRunLoopMode]; while (weakSelf.shouldKeepRunning) &#123; [theRL runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]]; &#125; NSLog(@\"end --%s\", __func__);&#125;];[thread start];在需要销毁时把shouldKeepRunning修改为NO12345678- (IBAction)stop:(id)sender &#123; [self performSelector:@selector(stopRunLoop) onThread:self.thread withObject:nil waitUntilDone:NO];&#125;- (void)stopRunLoop &#123; self.shouldKeepRunning = NO; CFRunLoopStop(CFRunLoopGetCurrent());&#125;封装12345 // 创建上下文（要初始化一下结构体）CFRunLoopSourceContext context = &#123;0&#125;; // 创建sourceCFRunLoopSourceRef source = CFRunLoopSourceCreate(kCFAllocatorDefault, 0, &amp;context);这就是封装后的1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677@implementation MJPermenantThread#pragma mark - public methods- (instancetype)init&#123; if (self = [super init]) &#123; self.innerThread = [[MJThread alloc] initWithBlock:^&#123; NSLog(@\"begin----\"); // 创建上下文（要初始化一下结构体） CFRunLoopSourceContext context = &#123;0&#125;; // 创建source CFRunLoopSourceRef source = CFRunLoopSourceCreate(kCFAllocatorDefault, 0, &amp;context); // 往Runloop中添加source CFRunLoopAddSource(CFRunLoopGetCurrent(), source, kCFRunLoopDefaultMode); // 销毁source CFRelease(source); // 启动 CFRunLoopRunInMode(kCFRunLoopDefaultMode, 1.0e10, false); // while (weakSelf &amp;&amp; !weakSelf.isStopped) &#123;// // 第3个参数：returnAfterSourceHandled，设置为true，代表执行完source后就会退出当前loop// CFRunLoopRunInMode(kCFRunLoopDefaultMode, 1.0e10, true);// &#125; NSLog(@\"end----\"); &#125;]; [self.innerThread start]; &#125; return self;&#125;//- (void)run//&#123;// if (!self.innerThread) return;//// [self.innerThread start];//&#125;- (void)executeTask:(MJPermenantThreadTask)task&#123; if (!self.innerThread || !task) return; [self performSelector:@selector(__executeTask:) onThread:self.innerThread withObject:task waitUntilDone:NO];&#125;- (void)stop&#123; if (!self.innerThread) return; [self performSelector:@selector(__stop) onThread:self.innerThread withObject:nil waitUntilDone:YES];&#125;- (void)dealloc&#123; NSLog(@\"%s\", __func__); [self stop];&#125;#pragma mark - private methods- (void)__stop&#123; CFRunLoopStop(CFRunLoopGetCurrent()); self.innerThread = nil;&#125;- (void)__executeTask:(MJPermenantThreadTask)task&#123; task();&#125;@end解决NSTimer在滑动时停止工作的问题RunLoop只能处于某一种模式，默认模式，拖拽时切换到另一种模式，所以NSTimer的默认模式消失NSRunLoopCommonModes并不是一个真的模式，它只是一个标记，timer能在_commonModes数组中存放的模式下工作RunLoop里面放的有模式，模式里面放的有timers，timer设置为commonmodes时会添加到runloop的_commonModeitemstimer工作：在runloop的执行流程中工作，timer能唤醒RunLoop监控应用卡顿性能优化总结Runloop循环处理当前模式下的source0、source1、timers、observes参考和源码源码：CF源码参考：iOS Runloop与线程保活深入理解RunLoop","categories":[],"tags":[]},{"title":"队列组、自旋锁","slug":"day20-队列组、自旋锁","date":"2020-05-30T06:09:14.000Z","updated":"2020-06-09T01:44:30.888Z","comments":true,"path":"p/9aa1f76b/","link":"","permalink":"https://ticsmatic.com/p/9aa1f76b/","excerpt":"学习MJ的视频课程，整理总结知识点–队列组、自旋锁","text":"学习MJ的视频课程，整理总结知识点–队列组、自旋锁面试题一：子线程添加timer会不执行1234567891011121314- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123; dispatch_queue_t queue = dispatch_get_global_queue(0, 0); dispatch_async(queue, ^&#123; NSLog(@\"%@\", @\"1\"); // 这句代码的本质是往Runloop中添加定时器 [self performSelector:@selector(log2func) withObject:nil afterDelay:.0]; NSLog(@\"%@\", @\"3\"); // [[NSRunLoop currentRunLoop] run]; 子线程默认不启动RunLoop，需要启动RunLoop，log2func才会执行 &#125;);&#125;- (void)log2func &#123; NSLog(@\"%@\", @\"2\");&#125;运行结果：打印“1 3”一句话概括原因：performSelector:withObject:afterDelay是RunLoop中的代码，依靠RunLoop来执行，而子线程没有RunLoop或者子线程RunLoop没有启动performSelector:withObject:afterDelay是RunLoop中的代码底层用到了定时器、定时器添加到RunLoop里的，RunLoop被唤醒时才会处理timer任务，异步线程不执行timer是因为子线程RunLoop没有启动（需要启动RunLoop）[[NSRunLoop currentRunLoop] run];面试题二：没有RunLoop，子线程执行完就会自动退出1234567891011NSThread *thread = [[NSThread alloc] initWithBlock:^&#123; NSLog(@\"1\"); // 为RunLoop添加Source1 // [[NSRunLoop currentRunLoop] addPort:[[NSPort alloc] init] forMode:NSDefaultRunLoopMode]; // 启动RunLoop保证线程不退出 // [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]]; &#125;]; [thread start]; [self performSelector:@selector(test) onThread:thread withObject:nil waitUntilDone:YES];performSelector:onThread:withObject:waitUntilDone:是通过RunLoop来处理的，子线程默认没有RunLoop，此时子线程内任务执行完就自动退出了，再执行test函数会崩溃。除非子线程内启动了RunLoop两个函数的对比：performSelector:withObject: 调用的底层msgSendperformSelector:withObject:afterDelay 调用的底层是RunLoop中的API两者调用的本质不太一样RunLoop源码不开放，但是有组织用自己的方式实现了一遍Cocoa的源码，就是GNUstep1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950GNUstep是GNU计划的项目之一，它将Cocoa的OC库重新开源实现了一遍源码地址：http:&#x2F;&#x2F;www.gnustep.org&#x2F;resources&#x2F;downloads.php虽然GNUstep不是苹果官方源码，但还是具有一定的参考价值&#96;&#96;&#96; ## 队列组的使用思考：如何用gcd实现以下功能：异步并发执行任务：1、任务2，等任务1、任务2都执行完毕后，再回到主线程执行任务3&#96;&#96;&#96;objc&#x2F;&#x2F; 创建队列组dispatch_group_t group &#x3D; dispatch_group_create();&#x2F;&#x2F; 创建并发队列dispatch_queue_t queue &#x3D; dispatch_queue_create(&quot;my_queue&quot;, DISPATCH_QUEUE_CONCURRENT); &#x2F;&#x2F; 添加异步任务dispatch_group_async(group, queue, ^&#123; for (int i &#x3D; 0; i &lt; 5; i++) &#123; NSLog(@&quot;任务1-%@&quot;, [NSThread currentThread]); &#125;&#125;); dispatch_group_async(group, queue, ^&#123; for (int i &#x3D; 0; i &lt; 5; i++) &#123; NSLog(@&quot;任务2-%@&quot;, [NSThread currentThread]); &#125;&#125;); &#x2F;&#x2F; 等前面的任务执行完毕后，会自动执行这个任务dispatch_group_notify(group, queue, ^&#123; dispatch_async(dispatch_get_main_queue(), ^&#123; for (int i &#x3D; 0; i &lt; 5; i++) &#123; NSLog(@&quot;任务3-%@&quot;, [NSThread currentThread]); &#125; &#125;);&#125;); dispatch_group_notify(group, queue, ^&#123; for (int i &#x3D; 0; i &lt; 5; i++) &#123; NSLog(@&quot;任务3-%@&quot;, [NSThread currentThread]); &#125;&#125;); dispatch_group_notify(group, queue, ^&#123; for (int i &#x3D; 0; i &lt; 5; i++) &#123; NSLog(@&quot;任务4-%@&quot;, [NSThread currentThread]); &#125;&#125;);线程安全问题卖票问题、存取钱问题解决方案：使用线程同步技术（同步，就是协同步调，按预定的先后次序进行）常见的线程同步技术是：加锁线程安全问题解决解决方案：加锁iOS中常用的锁有OSSpinLockos_unfair_lockpthread_mutexdispatch_semaphoredispatch_queue(DISPATCH_QUEUE_SERIAL)NSLockNSRecursiveLockNSConditionNSConditionLock@synchronizedOSSpinLock123456789101112static OSSpinLock moneyLock = OS_SPINLOCK_INIT;- (void)saveMoney &#123; OSSpinLockLock(&amp;moneyLock); NSInteger oldMoney = money; sleep(.2); oldMoney += 50; money = oldMoney; NSLog(@\"存50，还剩%ld元 - %@\", oldMoney, [NSThread currentThread]); OSSpinLockUnlock(&amp;moneyLock);&#125;要用同一把锁（锁被加了的标记，有标记就不进去执行了，等待这个锁被解标记后才能进去执行）等待锁的线程会处于忙等，一致占用cpu资源，while等待thread1thread2thread3线程的调度时间片轮训线程优先级高的话，会分配的时间片更多导致OSSpinLock的问题问题：优先级反转如果等待锁的线程优先级较高，它会一直占用着CPU资源，优先级低的线程就无法释放锁（因为它是占用cpu忙等，所以执行效率是比较高的）底层实现通过汇编查看stepinstruction、stepi、sios_unfair_lockiOS10 API_AVAILABLE和OSSpinLock的使用方式非常像Low-level lock 等待过程中会休眠，自旋锁不是，等待时是一直占用cpu等通过汇编查看stepinstruction、stepi、sipthread_mutexmutex叫做”互斥锁”，等待锁的线程会处于休眠状态递归锁一个函数内加锁，内部调用另一个函数，这个函数内也加同样的锁，结果会出现死锁递归函数也会出现同样的问题解决：使用递归锁递归锁：允许同一个线程对一把锁进行重复加锁12345678// 初始化属性pthread_mutexattr_t attr;pthread_mutexattr_init(&amp;attr);pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE);// 初始化锁pthread_mutex_init(mutex, &amp;attr);// 销毁属性pthread_mutexattr_destroy(&amp;attr);递归锁可以对同一把锁重复加锁，但是重复加锁仅限同一个线程，重复加锁最终也都会做同样次数的释放锁。当第二个线程进来发现已经加锁时，就等待之前的线程释放锁条件锁// 等待pthread_cond_wait(&amp;_cond, &amp;_mutex);// 信号pthread_cond_signal(&amp;_cond);执行流程：pthread_cond_wait睡眠等待、释放锁，等signal条件唤醒signal条件唤醒，解锁完成，等待的线程重新加锁，继续往下执行，完成后解锁使用场景：线程依赖的实现NSLock、NSRecursiveLockNSLock是对mutex普通锁的封装NSRecursiveLock也是对mutex递归锁的封装，API跟NSLock基本一致NSCondition条件锁NSCondition是对mutex和cond的封装NSConditionLockNSConditionLock是对NSCondition的进一步封装，可以设置具体的条件值可以设置只有满足条件才加锁，真正使用的场景不多dispatch_queue(DISPATCH_QUEUE_SERIAL)串行队列，让队列中的任务串行执行，防止并发访问的安全问题。也就是多线程中的任务串行执行1234567891011121314151617181920- (instancetype)init &#123; if (self = [super init]) &#123; self.ticketQueue = dispatch_queue_create(\"ticketQueue\", DISPATCH_QUEUE_SERIAL); self.moneyQueue = dispatch_queue_create(\"moneyQueue\", DISPATCH_QUEUE_SERIAL); &#125; return self;&#125;- (void)__drawMoney &#123; dispatch_sync(self.moneyQueue, ^&#123; [super __drawMoney]; &#125;);&#125;- (void)__saveMoney &#123; dispatch_sync(self.moneyQueue, ^&#123; [super __saveMoney]; &#125;);&#125;semaphoresemaphore叫做”信号量”信号量的初始值，可以用来控制线程并发访问的最大数量信号量的初始值为1，代表同时只允许1条线程访问资源，保证线程同步12345678static dispatch_semaphore_t semaphore;static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123; semaphore = dispatch_semaphore_create(1);&#125;);dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);// ...dispatch_semaphore_signal(semaphore);@synchronized@synchronized是对mutex递归锁的封装源码查看：objc4中的objc-sync.mm文件@synchronized(obj)内部会生成obj对应的递归锁，然后进行加锁、解锁操作选择对象self、类对象、oncelock对象iOS线程同步方案性能比较性能从高到低排序os_unfair_lockOSSpinLockdispatch_semaphorepthread_mutexdispatch_queue(DISPATCH_QUEUE_SERIAL)NSLockNSConditionpthread_mutex(recursive)NSRecursiveLockNSConditionLock@synchronized自旋锁、互斥锁比较什么情况使用自旋锁比较划算？预计线程等待锁的时间很短加锁的代码（临界区）经常被调用，但竞争情况很少发生CPU资源不紧张多核处理器什么情况使用互斥锁比较划算？预计线程等待锁的时间较长单核处理器临界区有IO操作临界区代码复杂或者循环量大临界区竞争非常激烈总结os_unfair_lock iOS10dispatch_semaphore 多样性pthread_mutex 跨平台 多样性参考和源码源码：","categories":[],"tags":[]},{"title":"Runtime API","slug":"day16-Runtime API","date":"2020-05-27T06:09:14.000Z","updated":"2020-05-30T15:20:15.569Z","comments":true,"path":"p/78c95faf/","link":"","permalink":"https://ticsmatic.com/p/78c95faf/","excerpt":"学习MJ的视频课程，整理总结知识点–Runtime API本文主要简单介绍Runtime常用的一些API，相关的API包括类、成员变量、属性、方法等。另，文章前面已介绍不少Runtime的API，这里不再重复","text":"学习MJ的视频课程，整理总结知识点–Runtime API本文主要简单介绍Runtime常用的一些API，相关的API包括类、成员变量、属性、方法等。另，文章前面已介绍不少Runtime的API，这里不再重复中间代码先补充一些知识点，关于查看OC代码转换后的底层实现的手段通过clang转换为cpp文件用于查看OC代码转化的C、C++代码，导出的一般是编译阶段的代码，和运行时真实调用的底层代码可能会有细小的差异，可以用于参考，但是代码逻辑基本上一致，可以用于分析OC的底层实现。12345objc_msgSendSuper(&#123;self, class_getSuperclass(objc_getClass(\"MJPerson\"))&#125;, @selector(forwardInvocation:), anInvocation);int a = 10;int b = 20;int c = a + b;test(c);Xcode断点Debug选择Always Show Disassembly查看运行阶段的汇编代码123456780x100000e8e &lt;+62&gt;: movq 0x29b(%rip), %rdx ; \"forwardInvocation:\"0x100000e95 &lt;+69&gt;: leaq -0x28(%rbp), %rdi0x100000e99 &lt;+73&gt;: movq %rsi, -0x40(%rbp)0x100000e9d &lt;+77&gt;: movq %rdx, %rsi0x100000ea0 &lt;+80&gt;: movq -0x40(%rbp), %rdx0x100000ea4 &lt;+84&gt;: callq 0x100000ef0 ; symbol stub for: objc_msgSendSuper20x100000ea9 &lt;+89&gt;: movl $0xa, -0x2c(%rbp)0x100000eb0 &lt;+96&gt;: movl $0x14, -0x30(%rbp)Xcode选择Product -&gt; Assembly xx文件，转成汇编12345678910.loc 2 29 5 ## Interview01-super/MJPerson.m:29:5movq %rdx, -40(%rbp)movq L_OBJC_CLASSLIST_SUP_REFS_$_(%rip), %rdxmovq %rdx, -32(%rbp)movq L_OBJC_SELECTOR_REFERENCES_.2(%rip), %rdxleaq -40(%rbp), %rdimovq %rsi, -64(%rbp) ## 8-byte Spillmovq %rdx, %rsimovq -64(%rbp), %rdx ## 8-byte Reloadcallq _objc_msgSendSuper24、clang导出中间代码苹果是通过LLVM把OC代码转成最终执行的机器码，大致过程OC -&gt; 中间代码 -&gt; 机器码LLVM跨平台的，汇编、机器码是区分平台的1234567891011121314151617181920212223242526272829303132define internal void @\"\\01-[MJPerson forwardInvocation:]\"(%0*, i8*, %1*) #1 &#123;%4 = alloca %0*, align 8%5 = alloca i8*, align 8%6 = alloca %1*, align 8%7 = alloca %struct._objc_super, align 8%8 = alloca i32, align 4%9 = alloca i32, align 4%10 = alloca i32, align 4store %0* %0, %0** %4, align 8store i8* %1, i8** %5, align 8store %1* %2, %1** %6, align 8%11 = load %0*, %0** %4, align 8%12 = load %1*, %1** %6, align 8%13 = bitcast %0* %11 to i8*%14 = getelementptr inbounds %struct._objc_super, %struct._objc_super* %7, i32 0, i32 0store i8* %13, i8** %14, align 8%15 = load %struct._class_t*, %struct._class_t** @\"OBJC_CLASSLIST_SUP_REFS_$_\", align 8%16 = bitcast %struct._class_t* %15 to i8*%17 = getelementptr inbounds %struct._objc_super, %struct._objc_super* %7, i32 0, i32 1store i8* %16, i8** %17, align 8%18 = load i8*, i8** @OBJC_SELECTOR_REFERENCES_, align 8, !invariant.load !8call void bitcast (i8* (%struct._objc_super*, i8*, ...)* @objc_msgSendSuper2 to void (%struct._objc_super*, i8*, %1*)*)(%struct._objc_super* %7, i8* %18, %1* %12)store i32 10, i32* %8, align 4store i32 20, i32* %9, align 4%19 = load i32, i32* %8, align 4%20 = load i32, i32* %9, align 4%21 = add nsw i32 %19, %20store i32 %21, i32* %10, align 4%22 = load i32, i32* %10, align 4call void @test(i32 %22)ret void&#125;Objective-C在变为机器代码之前，会被LLVM编译器转换为中间代码（Intermediate Representation）可以使用以下命令行指令生成中间代码clang -emit-llvm -S main.m语法简介@ - 全局变量% - 局部变量alloca - 在当前执行的函数的堆栈帧中分配内存，当该函数返回到其调用者时，将自动释放内存i32 - 32位4字节的整数align - 对齐load - 读出，store 写入icmp - 两个整数值比较，返回布尔值br - 选择分支，根据条件来转向label，不根据条件跳转的话类似gotolabel - 代码标签call - 调用函数具体可以参考官方文档：https://llvm.org/docs/LangRef.htmlRuntime API - 类动态创建一个类，添加属性，添加方法，注册类12345678910111213141516171819202122MJPerson *person = [[MJPerson alloc] init];[person run]; object_setClass(person, [MJCar class]);[person run]; NSLog(@\"%d %d %d\", object_isClass(person), object_isClass([MJPerson class]), object_isClass(object_getClass([MJPerson class])) ); // 创建类Class newClass = objc_allocateClassPair([NSObject class], \"MJDog\", 0);class_addIvar(newClass, \"_age\", 4, 1, @encode(int));class_addIvar(newClass, \"_weight\", 4, 1, @encode(int));class_addMethod(newClass, @selector(run), (IMP)run, \"v@:\");// 注册类objc_registerClassPair(newClass); // 在不需要这个类时释放objc_disposeClassPair(newClass);Runtime API - 成员变量应用-找textfiledIvar *ivarsC语言取数据时数组和指针没什么区别Ivar ivar = *(ivars + i)Runtime实现字典转模型ivarlistRuntime API – 方法拦截所有按钮的点击事件方法交换，交换的是class_rw_t-&gt;methods-&gt;method_lsit(method_t)-&gt;imp12345678910111213141516@implementation UIControl (Extension)+ (void)load &#123; // hook：钩子函数 Method method1 = class_getInstanceMethod(self, @selector(sendAction:to:forEvent:)); Method method2 = class_getInstanceMethod(self, @selector(mj_sendAction:to:forEvent:)); method_exchangeImplementations(method1, method2);&#125;- (void)mj_sendAction:(SEL)action to:(id)target forEvent:(UIEvent *)event &#123; NSLog(@\"%@-%@-%@\", self, target, NSStringFromSelector(action)); // 调用系统原来的实现 [self mj_sendAction:action to:target forEvent:event];&#125;@endNSMutableArray数据插空处理类簇：NSString、NSArray、NSDictionary，真实类型是其他类型12345678910111213141516171819@implementation NSMutableArray (Extension)+ (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; // 类簇：NSString、NSArray、NSDictionary，真实类型是其他类型 Class cls = NSClassFromString(@\"__NSArrayM\"); Method method1 = class_getInstanceMethod(cls, @selector(insertObject:atIndex:)); Method method2 = class_getInstanceMethod(cls, @selector(mj_insertObject:atIndex:)); method_exchangeImplementations(method1, method2); &#125;);&#125;- (void)mj_insertObject:(id)anObject atIndex:(NSUInteger)index &#123; if (anObject == nil) return; [self mj_insertObject:anObject atIndex:index];&#125;@end字典123456789101112131415161718192021222324252627282930@implementation NSMutableDictionary (Extension)+ (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; Class cls = NSClassFromString(@\"__NSDictionaryM\"); Method method1 = class_getInstanceMethod(cls, @selector(setObject:forKeyedSubscript:)); Method method2 = class_getInstanceMethod(cls, @selector(mj_setObject:forKeyedSubscript:)); method_exchangeImplementations(method1, method2); Class cls2 = NSClassFromString(@\"__NSDictionaryI\"); Method method3 = class_getInstanceMethod(cls2, @selector(objectForKeyedSubscript:)); Method method4 = class_getInstanceMethod(cls2, @selector(mj_objectForKeyedSubscript:)); method_exchangeImplementations(method3, method4); &#125;);&#125;- (void)mj_setObject:(id)obj forKeyedSubscript:(id&lt;NSCopying&gt;)key &#123; if (!key) return; [self mj_setObject:obj forKeyedSubscript:key];&#125;- (id)mj_objectForKeyedSubscript:(id)key &#123; if (!key) return nil; return [self mj_objectForKeyedSubscript:key];&#125;@endfishhook总结什么是Runtime？平时项目中有用过么？OC是一门动态性比较强的编程语言，允许很多操作推迟到程序运行时再进行OC的动态性就是由Runtime来支撑和实现的，Runtime是一套C语言的API，封装了很多动态性相关的函数平时编写的OC代码，底层都是转换成了Runtime API进行调用应用关联对象给分类添加属性获取遍历类的成员变量，修改私有变量字典转模型、自动归档解档交换方法实现（交换系统的方法，导航栏样式）利用消息转发机制解决方法找不到的异常问题参考和源码源码：","categories":[],"tags":[]},{"title":"super、class面试题","slug":"day14-super","date":"2020-05-23T06:09:14.000Z","updated":"2020-05-27T05:44:03.324Z","comments":true,"path":"p/a123b137/","link":"","permalink":"https://ticsmatic.com/p/a123b137/","excerpt":"学习MJ的视频课程，整理总结知识点–super、class面试题本文讲解super、class相关的一些面试题，利用底层的知识来分析讲解","text":"学习MJ的视频课程，整理总结知识点–super、class面试题本文讲解super、class相关的一些面试题，利用底层的知识来分析讲解面试题01-super先看一段代码，同时附上了分析时的DemoInterview05-super12345678910111213141516171819@interface MJPerson : NSObject@end@interface MJStudent : MJPerson@end- (instancetype)init&#123; if (self = [super init]) &#123; NSLog(@\"[self class] = %@\", [self class]); NSLog(@\"[self superclass] = %@\", [self superclass]); NSLog(@\"[super class] = %@\", [super class]); NSLog(@\"[super superclass] = %@\", [super superclass]); &#125; return self;&#125;问：打印结果是什么？验证后的输出结果如下1234NSLog(@\"[self class] = %@\", [self class]); // MJStudentNSLog(@\"[self superclass] = %@\", [self superclass]);// MJPersonNSLog(@\"[super class] = %@\", [super class]); // MJStudentNSLog(@\"[super superclass] = %@\", [super superclass]);// MJPerson对于[self class]、[self superclass]的结果我们基本上没什么疑问，对于[super class]的结果，可能会觉得意外。下面结合Demo以及编译后的源码分析为什么是这样。先从简答的super调用分析，代码如下123456@implementation MJStudent- (void)run &#123; [super run]; NSLog(@\"MJStudet.......\");&#125;@end利用clang编译对应部分的源码，结果如下1234567((void (*)(__rw_objc_super *, SEL))(void *)objc_msgSendSuper)((__rw_objc_super)&#123;(id)self, (id)class_getSuperclass(objc_getClass(\"MJStudent\"))&#125;, sel_registerName(\"run\"));// 代码进行格式优化后objc_msgSendSuper((__rw_objc_super)&#123; (id)self, (id)class_getSuperclass(objc_getClass(\"MJStudent\"))&#125;, @selector(run));我们发现，objc_msgSendSuper的参数有两个，一个是结构体，一个是SEL，我们搜索源码发现这个结构体相关的代码12345/// Specifies the superclass of an instance. struct objc_super &#123; __unsafe_unretained _Nonnull id receiver; __unsafe_unretained _Nonnull Class super_class;&#125;;objc_super的结构和__rw_objc_super是一致的，其实它们两个也是等价的，只不过是程序在不同阶段的表现不同而已。所以，可以整理出super方法调用对应的源码1234567891011struct objc_super &#123; __unsafe_unretained _Nonnull id receiver; // 消息接收者 __unsafe_unretained _Nonnull Class super_class; // 消息接收者的父类&#125;;- (void)run &#123; [super run]; // 等价源码如下 // struct objc_super arg = &#123;self, [MJPerson class]&#125;; // objc_msgSendSuper(arg, @selector(run));&#125;objc_super中的receiver消息接受者是self，即[super run]中super调用的receiver仍然是MJStudent对象。下面的关键就是看objc_msgSendSuper的实现，但是这部分是汇编代码，不过能看到它的注释，写的也很清晰，如下1234567891011121314151617&#x2F;** * Sends a message with a simple return value to the superclass of an instance of a class. * * @param super A pointer to an \\c objc_super data structure. Pass values identifying the * context the message was sent to, including the instance of the class that is to receive the * message and the superclass at which to start searching for the method implementation. * @param op A pointer of type SEL. Pass the selector of the method that will handle the message. * @param ... * A variable argument list containing the arguments to the method. * * @return The return value of the method identified by \\e op. * * @see objc_msgSend *&#x2F;OBJC_EXPORT id _Nullableobjc_msgSendSuper(struct objc_super * _Nonnull super, SEL _Nonnull op, ...) OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0);这段注释也说明[super message]的底层实现原理消息接收者仍然是子类对象从父类开始查找方法的实现分析完后，继续回到[super class]这段代码1NSLog(@\"[super class] = %@\", [super class]);结合上面的super分析，我们可知[super class]这个方法的接受者仍然是当前的子类对象(MJStudent)。对于-class方法，结合我们在object_getClass所学的知识，它的实现如下1234567- (Class)class &#123; return object_getClass(self);&#125;- (Class)superclass &#123; return [self class]-&gt;superclass;&#125;所以[super class]的消息接收者是当前的子类对象，而-class方法就是返回方法调用者的class，也就是MJStudent类型总结[super message]转化的底层源码struct objc_super {__unsafe_unretained _Nonnull id receiver; // 消息接收者__unsafe_unretained _Nonnull Class super_class; // 消息接收者的父类};struct objc_super arg = {self, 父类};objc_msgSendSuper(arg, SEL);[super message]的底层实现消息接收者仍然是子类对象从父类开始查找方法的实现[super message], [self message]这两个函数的实现差别挺大，一个调用objc_msgSendSuper，一个调用objc_msgSend，不要被它们两个表面迷惑；-class的底层实现返回的是消息接收者的类，而恰好super的消息接收者是子类对象，就解释了[super class]的结果是子类了。参考和源码源码：Interview05-super","categories":[],"tags":[]},{"title":"Runtime-objc_msgSend","slug":"day13-Runtime-objc_msgSend","date":"2020-05-23T06:09:14.000Z","updated":"2020-05-26T15:11:02.370Z","comments":true,"path":"p/e8e2068/","link":"","permalink":"https://ticsmatic.com/p/e8e2068/","excerpt":"学习MJ的视频课程，整理总结知识点–objc_msgSend本文主要从Class结构体出发，讲解class_rw_t的结构及class_rw_t中的methods，及Class中的cache_t cache。","text":"学习MJ的视频课程，整理总结知识点–objc_msgSend本文主要从Class结构体出发，讲解class_rw_t的结构及class_rw_t中的methods，及Class中的cache_t cache。objc_msgSend简介OC中的方法调用，其实都是转换为objc_msgSend函数的调用123456789MJPerson *person = [MJPerson alloc] init];[person personTest];// 编译后对应的源码MJPerson *person = objc_msgSend(objc_msgSend(objc_getClass(\"MJPerson\"), sel_registerName(\"alloc\")), sel_registerName(\"init\"));// 等价于 objc_msgSend(person, @selector(personTest));objc_msgSend(person, sel_registerName(\"personTest\"));可以看到，OC的函数调用转成消息发送我们可以测试sel_registerName(&quot;personTest&quot;)、@selector(personTest)两个函数的地址是相等的，其实它们两个确实是等价的，只不过是在不同环境的不同表现形式。所以我们可以认为OC的方法调用：消息机制，给方法调用者发消息objc_msgSend的执行流程可以分为3大阶段消息发送动态方法解析允许动态创建一个方法出来消息转发消息转发给另外的对象调用objc_msgSend消息发送关于消息发送，我们从objc_msgSend的源码开始解读，这一部分是汇编代码，可能是因为objc_msgSend的调用频率比较高，为了性能的考虑，使用了更底层的汇编来实现。在objc-msg-arm64.s中12345678910111213141516171819202122232425262728293031323334353637383940414243ENTRY _objc_msgSend UNWIND _objc_msgSend, NoFrame MESSENGER_START cmp x0, #0 // nil check and tagged pointer check b.le LNilOrTagged // (MSB tagged pointer looks negative) nil的话跳转到LNilOrTagged ldr x13, [x0] // x13 = isa and x16, x13, #ISA_MASK // x16 = class LGetIsaDone: CacheLookup NORMAL // calls imp or objc_msgSend_uncached 缓存查找 参数 为NORMALLNilOrTagged: b.eq LReturnZero // nil check nil的话直接return // tagged mov x10, #0xf000000000000000 cmp x0, x10 b.hs LExtTag adrp x10, _objc_debug_taggedpointer_classes@PAGE add x10, x10, _objc_debug_taggedpointer_classes@PAGEOFF ubfx x11, x0, #60, #4 ldr x16, [x10, x11, LSL #3] b LGetIsaDoneLExtTag: // ext tagged adrp x10, _objc_debug_taggedpointer_ext_classes@PAGE add x10, x10, _objc_debug_taggedpointer_ext_classes@PAGEOFF ubfx x11, x0, #52, #8 ldr x16, [x10, x11, LSL #3] b LGetIsaDone LReturnZero: // x0 is already zero mov x1, #0 movi d0, #0 movi d1, #0 movi d2, #0 movi d3, #0 MESSENGER_END_NIL ret END_ENTRY _objc_msgSendENTRY是入口的意思，_objc_msgSend先判断对象是否为空，为空时，直接return，不为空继续往下走。先难道isa去对应位置的缓存中找CacheLookup NORMAL12345678910111213141516171819202122232425262728293031323334353637383940.macro CacheLookup // x1 = SEL, x16 = isa ldp x10, x11, [x16, #CACHE] // x10 = buckets, x11 = occupied|mask and w12, w1, w11 // x12 = _cmd &amp; mask add x12, x10, x12, LSL #4 // x12 = buckets + ((_cmd &amp; mask)&lt;&lt;4) ldp x9, x17, [x12] // &#123;x9, x17&#125; = *bucket1: cmp x9, x1 // if (bucket-&gt;sel != _cmd) b.ne 2f // scan more CacheHit $0 // call or return imp 2: // not hit: x12 = not-hit bucket CheckMiss $0 // miss if bucket-&gt;sel == 0 cmp x12, x10 // wrap if bucket == buckets b.eq 3f ldp x9, x17, [x12, #-16]! // &#123;x9, x17&#125; = *--bucket b 1b // loop3: // wrap: x12 = first bucket, w11 = mask add x12, x12, w11, UXTW #4 // x12 = buckets+(mask&lt;&lt;4) // Clone scanning loop to miss instead of hang when cache is corrupt. // The slow path may detect any corruption and halt later. ldp x9, x17, [x12] // &#123;x9, x17&#125; = *bucket1: cmp x9, x1 // if (bucket-&gt;sel != _cmd) b.ne 2f // scan more CacheHit $0 // call or return imp 2: // not hit: x12 = not-hit bucket CheckMiss $0 // miss if bucket-&gt;sel == 0 cmp x12, x10 // wrap if bucket == buckets b.eq 3f ldp x9, x17, [x12, #-16]! // &#123;x9, x17&#125; = *--bucket b 1b // loop3: // double wrap JumpMiss $0 .endmacroCacheLookup的汇编代码看不懂，但是它的注释写的挺详细，以及一些关键词，我们呢也能分析出大致的流程。拿着isa在对应的class里面找cache及里面的buckets根据哈希计算(_cmd &amp; mask)的结果去buckets里面找找到了调用CacheHit，返回imp没找到的话调CheckMiss，用loop循环找最终还没找到的话JumpMiss因为参数是NORMAL，JumpMiss的处理流程会调用__objc_msgSend_uncached因为是未缓存的方法，__objc_msgSend_uncached流程内会调用MethodTableLookup，也就是方法列表查找方法列表查找内部调用__class_lookupMethodAndLoadCache3我们搜索__class_lookupMethodAndLoadCache3发现找不到匹配的关键字，因为在OC中，函数转到汇编函数时会多一个_，我们去掉下划线，搜索_class_lookupMethodAndLoadCache3，就来到了runtime的api12345IMP _class_lookupMethodAndLoadCache3(id obj, SEL sel, Class cls)&#123; return lookUpImpOrForward(cls, sel, obj, YES/*initialize*/, NO/*cache*/, YES/*resolver*/);&#125;12345678910111213141516171819202122232425262728293031323334IMP lookUpImpOrForward(Class cls, SEL sel, id inst, bool initialize, bool cache, bool resolver)&#123; &#x2F;&#x2F; Optimistic cache lookup &#x2F;&#x2F; 需要从缓存中取 if (cache) &#123; &#x2F;&#x2F; 从缓存中取 imp &#x3D; cache_getImp(cls, sel); &#x2F;&#x2F; 取到了直接返回 if (imp) return imp; &#125; &#x2F;&#x2F; cls未初始化要先初始化 &#x2F;&#x2F; 从当前cls取，取到了直接返回 &#x2F;&#x2F; 说明缓存中没取到，去当前cls的方法列表找&#96;getMethodNoSuper_nolock&#96; &#123; Method meth &#x3D; getMethodNoSuper_nolock(cls, sel); if (meth) &#123; &#x2F;&#x2F; 找到了把此方法填入当前cls的缓存中 log_and_fill_cache(cls, meth-&gt;imp, sel, inst, cls); imp &#x3D; meth-&gt;imp; goto done; &#125; &#125; &#x2F;&#x2F; 当前cls没找到，回通过superclass指针去父类里面找，流程很类似，也是先从父类的缓存中找，没找到会去父类的方法列表中找 &#x2F;&#x2F; 还是没找到，尝试动态解析 &#x2F;&#x2F; No implementation found. Try method resolver once. _class_resolveMethod(cls, sel, inst); &#x2F;&#x2F; goto retry;&#125;12345678910111213141516static method_t *search_method_list(const method_list_t *mlist, SEL sel)&#123; int methodListIsFixedUp = mlist-&gt;isFixedUp(); int methodListHasExpectedSize = mlist-&gt;entsize() == sizeof(method_t); if (__builtin_expect(methodListIsFixedUp &amp;&amp; methodListHasExpectedSize, 1)) &#123; // 有序的话就用二分查找 return findMethodInSortedMethodList(sel, mlist); &#125; else &#123; // Linear search of unsorted method list // 无序的话就用线性遍历查找 for (auto&amp; meth : *mlist) &#123; if (meth.name == sel) return &amp;meth; &#125; &#125;&#125;核心点就是先去当前类的缓存中找，找不到去当前类的方法列表中找，还找不到去父类缓存中找，找不到去父类的方法列表中找，还找不到尝试走动态解析。思路很清晰，没什么难点，可以通过一个图来表示这个过程消息方法objc_msgSend动态方法解析(resolve)在lookUpImpOrForward函数内先走消息查找逻辑，找不到时会走到动态方法解析阶段，这部分代码如下1234567891011// No implementation found. Try method resolver once.if (resolver &amp;&amp; !triedResolver) &#123; runtimeLock.unlockRead(); _class_resolveMethod(cls, sel, inst); runtimeLock.read(); // Don't cache the result; we don't hold the lock so it may have // changed already. Re-do the search from scratch instead. triedResolver = YES; goto retry; &#125;方法找不到时，动态方法解析阶段内部会调用resolveInstanceMethod或resolveClassMethod方法，可以在这两个方法内部做动态添加函数。1234567891011121314151617void _class_resolveMethod(Class cls, SEL sel, id inst)&#123; if (! cls-&gt;isMetaClass()) &#123; // try [cls resolveInstanceMethod:sel] _class_resolveInstanceMethod(cls, sel, inst); &#125; else &#123; // try [nonMetaClass resolveClassMethod:sel] // and [cls resolveInstanceMethod:sel] _class_resolveClassMethod(cls, sel, inst); if (!lookUpImpOrNil(cls, sel, inst, NO/*initialize*/, YES/*cache*/, NO/*resolver*/)) &#123; _class_resolveInstanceMethod(cls, sel, inst); &#125; &#125;&#125;假如我们调用一个未实现的对象方法[person test]，程序运行时，调用test方法时会走动态方法解析，我们实现resolveInstanceMethod方法，并在此方法内部动态添加test函数的实现，即可让程序继续正常执行。当走到动态方法方法解析阶段时，lookUpImpOrForward函数接续往下走，会goto retry，也就是重新走消息发送流程。如果程序正确的动态添加了方法，那么消息发送流程会继续正确的执行，如果没有，会走到消息转发流程。1234567891011121314151617181920- (void)other &#123; NSLog(@\"%s\", __func__);&#125;+ (BOOL)resolveInstanceMethod:(SEL)sel &#123; if (sel == @selector(test)) &#123; // 获取其他方法 Method method = class_getInstanceMethod(self, @selector(other)); // 动态添加test方法的实现 // class_addMethod会把函数添加到Class里面的class_rw_t里面的methods class_addMethod(self, sel, method_getImplementation(method), method_getTypeEncoding(method)); // 返回YES代表有动态添加方法 return YES; &#125; return [super resolveInstanceMethod:sel];&#125;此时调用test函数，实际上内部调用的是other函数如果是调用为实现的类方法，即给类发送消息，也会走同样的流程，不过在动态解析的时候，要记得是给类的元类动态添加方法。动态方法解析objc_msgSend消息转发(forward)如果动态方法解析阶段没有找到方法的实现，会走到消息转发阶段1234// No implementation found, and method resolver didn't help. // Use forwarding.imp = (IMP)_objc_msgForward_impcache;_objc_msgForward具体流程不开源，我们在objc-msg-arm64.s文件中搜索到如下汇编代码1234567ENTRY __objc_msgForwardadrp x17, __objc_forward_handler@PAGEldr x17, [x17, __objc_forward_handler@PAGEOFF]br x17 END_ENTRY __objc_msgForward但是在_objc_forward_handler没有找到消息转发的相关实现。同时，如果我们调用一个未实现的方法时，运行时会报错，类似如下13 CoreFoundation 0x00007fff3077c8ef ___forwarding___ + 1485关于___forwarding___，也就是调用消息转发流程的关键，有人根据汇编写出C语言的伪代码。forwarding.c___forwarding___.c简化的伪代码如下1234567891011121314151617181920212223242526272829303132333435int __forwarding__(void *frameStackPointer, int isStret) &#123; id receiver = *(id *)frameStackPointer; SEL sel = *(SEL *)(frameStackPointer + 8); const char *selName = sel_getName(sel); Class receiverClass = object_getClass(receiver); // 调用 forwardingTargetForSelector: if (class_respondsToSelector(receiverClass, @selector(forwardingTargetForSelector:))) &#123; id forwardingTarget = [receiver forwardingTargetForSelector:sel]; if (forwardingTarget &amp;&amp; forwardingTarget != receiver) &#123; return objc_msgSend(forwardingTarget, sel, ...); &#125; &#125; // 调用 methodSignatureForSelector 获取方法签名后再调用 forwardInvocation if (class_respondsToSelector(receiverClass, @selector(methodSignatureForSelector:))) &#123; NSMethodSignature *methodSignature = [receiver methodSignatureForSelector:sel]; if (methodSignature &amp;&amp; class_respondsToSelector(receiverClass, @selector(forwardInvocation:))) &#123; NSInvocation *invocation = [NSInvocation _invocationWithMethodSignature:methodSignature frame:frameStackPointer]; [receiver forwardInvocation:invocation]; void *returnValue = NULL; [invocation getReturnValue:&amp;value]; return returnValue; &#125; &#125; if (class_respondsToSelector(receiverClass,@selector(doesNotRecognizeSelector:))) &#123; [receiver doesNotRecognizeSelector:sel]; &#125; // The point of no return. kill(getpid(), 9);&#125;我们可以根据C的伪代码分析调用流程。先判断是否实现forwardingTargetForSelector，如果实现了此方法，且返回一个对象，那么会同时把这个消息转发到这个对象上去。123456- (id)forwardingTargetForSelector:(SEL)aSelector &#123; if (aSelector == @selector(test)) &#123; return [[MJCat alloc] init]; &#125; return [super forwardingTargetForSelector:aSelector];&#125;这个Demo中，是吧test方法这个消息，转发到MJCat的实例对象，也就是去调用MJCat对象的test方法。这就是消息转发的由来。如果没有实现forwardingTargetForSelector方法，或者这个方法返回的对象为空，消息转发流程会继续走到methodSignatureForSelector，拿方法的签名，拿到对象的方法签名后，会调用forwardInvocation方法，返回值为空时，此时才调用doesNotRecognizeSelector方法，抛出错误。12345678910111213141516171819// 方法签名：返回值类型、参数类型- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123; if (aSelector == @selector(test)) &#123; NSMethodSignature *methodSign = [NSMethodSignature signatureWithObjCTypes:\"v@:\"]; return methodSign; &#125; return [super methodSignatureForSelector:aSelector];&#125;// NSInvocation封装了一个方法调用，包括：方法调用者、方法名、方法参数// anInvocation.target 方法调用者// anInvocation.selector 方法名// [anInvocation getArgument:NULL atIndex:0]- (void)forwardInvocation:(NSInvocation *)anInvocation &#123; // 这个函数内部可以根据业务场景实现，没有具体要求 // anInvocation.target = [[MJCat alloc] init]; // [anInvocation invoke]; // [anInvocation invokeWithTarget:[[MJCat alloc] init]];&#125;不仅实例方法支持动态方法解析、消息转发阶段，类方法也是支持的，因为消息发送的本质是要求接受者、方法名。类对象也是属于对象，当然也是支持这个流程的。前面也提到过，实例方法、类方法其实没有本质区别，只不过存储的位置不一样而已。消息转发这一部分可以参考消息转发-Demo进行试验。总结简介OC的消息机制：OC中的方法调用其实都转成了objc_msgSend函数的调用，给receiver（方法调用者）发送了一条消息（selector方法名）objc_msgSend有3大阶段消息发送（去类、父类中查找）、动态方法解析、消息转发消息转发机制流程先判断是否实现了forwardingTargetForSelector:方法，如果实现了此方法且此方法的返回值不为nil，那么就会给返回值对象发送对应的消息SE如果forwardingTargetForSelector返回值为nil，那么会调用methodSignatureForSelector:方法，如果此方法返回值不为nil，那么会调用forwardInvocation:方法，否则调用doesNotRecognizeSelector:方法。参考和源码objc4源码：forwarding.c消息转发-Demo","categories":[],"tags":[]},{"title":"class","slug":"day15-class、super","date":"2020-05-23T06:09:14.000Z","updated":"2020-06-01T09:31:57.821Z","comments":true,"path":"p/ed4b199f/","link":"","permalink":"https://ticsmatic.com/p/ed4b199f/","excerpt":"学习MJ的视频课程，整理总结知识点–class、super","text":"学习MJ的视频课程，整理总结知识点–class、superisKindOfClass 和 isMemberOfClassisKindOfClass和isMemberOfClass的源码如下1234567891011121314151617181920212223242526272829303132- (Class)class &#123; return object_getClass(self);&#125;+ (BOOL)isMemberOfClass:(Class)cls &#123; return object_getClass((id)self) == cls;&#125;- (BOOL)isMemberOfClass:(Class)cls &#123; return [self class] == cls;&#125;+ (BOOL)isKindOfClass:(Class)cls &#123; for (Class tcls = object_getClass((id)self); tcls; tcls = tcls-&gt;superclass) &#123; if (tcls == cls) return YES; &#125; return NO;&#125;- (BOOL)isKindOfClass:(Class)cls &#123; for (Class tcls = [self class]; tcls; tcls = tcls-&gt;superclass) &#123; if (tcls == cls) return YES; &#125; return NO;&#125;+ (BOOL)isSubclassOfClass:(Class)cls &#123; for (Class tcls = self; tcls; tcls = tcls-&gt;superclass) &#123; if (tcls == cls) return YES; &#125; return NO;&#125;打印结果如下123456789id person = [[MJPerson alloc] init];NSLog(@\"%d\", [person isMemberOfClass:[MJPerson class]]); // 1NSLog(@\"%d\", [person isMemberOfClass:[NSObject class]]); // 0NSLog(@\"%d\", [person isKindOfClass:[MJPerson class]]); // 1NSLog(@\"%d\", [person isKindOfClass:[NSObject class]]); // 1NSLog(@\"%d\", [MJPerson isMemberOfClass:object_getClass([MJPerson class])]); // 1NSLog(@\"%d\", [MJPerson isKindOfClass:object_getClass([NSObject class])]); // 1super面试题这里有一道面试题，如下，相应的DemoInterview02-super123456789101112131415161718192021@interface MJPerson : NSObject@property (copy, nonatomic) NSString *name;- (void)print;@end@implementation MJPerson- (void)print &#123; NSLog(@\"my name is %@\", self-&gt;_name);&#125;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; id cls = [MJPerson class]; void *obj = &amp;cls; [(__bridge id)obj print];&#125;@end问[(__bridge id)obj print]执行结果？从viewDidLoad函数内开始分析：123id cls = [MJPerson class]; // 栈中定义一个变量cls，cls指向MJPerson这个类void *obj = &amp;cls; // 栈中定义一个变量obj，obj指向cls的地址[(__bridge id)obj print]; // 给变量obj发送print消息我们先分析一个正常的调用场景的过程，如下12id person = [[MJPerson alloc] init];[person print];person指针指向MJPerson的一个实例对象，当调用print方法时，结合我们前面所学的Class的底层结构知道，会先通过person的isa指针拿到MJPerson这个类，在类中查找print方法并调用。person指向的实例对象的底层结构是一个结构体，这个结构体的第一个成员是isa指针，也就意味着person指针指向的实例对象地址，同时也是实例对象的isa的地址，而实例对象isa的指向的地址是MJPerson这个类的地址，内部就会有类似如下的指针指向关系。person ----&gt; isa ----&gt; MJPerson我们再回过去分析上面的问题，它的指针指向关系如下：obj ----&gt; cls ----&gt; MJPerson两者虽然内容不一样，但指向关系相同。所以我们可以分析[(__bridge id)obj print];的流程，首先取obj指针指向的地址，为cls，等价于正常方法调用的流程的取isa指针；然后取isa指向的对象地址，正常流程是MJPerson，而cls指针指向的地址也是MJPerson，所以能正常调用print方法。那么打印的self.name结果是什么呢123- (void)print &#123; NSLog(@\"my name is %@\", self.name);&#125;上面我们可以分析出，[(__bridge id)obj print]这段代码可以正确的执行，我们知道，_name是MJPerson实例对象里面的一个属性，而实例对象结构体第一个成员是isa指针，接下来是_name，也就是print函数的self.name是isa地址后面8个字节的空间的内容。而obj是存储在栈空间的一个变量，栈空间是从高地址-&gt;低地址依次分配内存的，我们先从简单的分析入手，把代码改成如下这样：123456789- (void)viewDidLoad &#123; [super viewDidLoad]; NSString *str = @\"123\"; id cls = [MJPerson class]; void *obj = &amp;cls; [(__bridge id)obj print];&#125;此时打印的的结果是my name is 123，我们分析下此时栈空间的内存地址结构低地址-&gt;高地址指针指向的内存区域obj指针指向clscls指针指向MJPersonstr指针指向”123”我们回到函数[(__bridge id)obj print]的调用流程进行分析，调用过程中会取obj的isa，并且把isa的地址增加_name的大小作为偏移量，也就是8字节。也就是会取obj指向的cls，并把cls的地址增加8个字节的偏移量作为_name的内存地址，此时便宜后刚好是str的内存区域。就解释了打印的结果是123。那么我们回到原本的问题，如下1234567- (void)viewDidLoad &#123; [super viewDidLoad]; id cls = [MJPerson class]; void *obj = &amp;cls; [(__bridge id)obj print];&#125;此时cls的地址增加8字节是谁呢，这里有一个[super viewDidLoad];调用，我们之前的文章分析过，[super message];用clang重写会生成如下代码12struct objc_super arg = &#123;self, [UIViewController class]&#125;;objc_msgSendSuper(arg, sel_registerName(\"viewDidLoad\"));这个过程会生成一个objc_super类型的结构体，结构体的第一个成员是self，也就是ViewController的实例对象。此时的函数内栈内存地址图如下低地址-&gt;高地址指针指向的内存区域obj指针指向clscls指针指向MJPersonself指针指向ViewController实例对象类指针指针指向[UIViewController class]所以根据偏移量计算，_name的位置刚好是self对象，所以程序运行的结果如下1[(__bridge id)obj print]; // my name is &lt;ViewController: 0x600002eade10&gt;super本质对于[super message]这里有一些知识要补充。[super message]的底层本质，我们上面也总结过，我们是根据源码导出的编译环境下的C++代码总结的，实际上并不能完全代表运行时的样子。时机上运行时，真正调用的和编译时是不一样的，我们通过断点调试[super viewDidLoad]的执行过程，选择Xcode-&gt;Debug-&gt;Debug Workflow-&gt;Always Show Disassembly，来查看真实调用时转化的汇编代码，关键部分如下1230x10b457383 &lt;+35&gt;: movq 0x2b9e(%rip), %rsi ; \"viewDidLoad\"0x10b45738a &lt;+42&gt;: leaq -0x20(%rbp), %rdi0x10b45738e &lt;+46&gt;: callq 0x10b4578f4 ; symbol stub for: objc_msgSendSuper2我们看到[super message]真实调用的底层函数是objc_msgSendSuper2，我们在苹果开源的objc4没有找到objc_msgSendSuper2的C实现，不过有汇编实现，如下12345678910111213OBJC_EXPORT id _Nullableobjc_msgSendSuper2(struct objc_super * _Nonnull super, SEL _Nonnull op, ...) OBJC_AVAILABLE(10.6, 2.0, 9.0, 1.0, 2.0); ENTRY _objc_msgSendSuper2UNWIND _objc_msgSendSuper2, NoFrameMESSENGER_STARTldp x0, x16, [x0] &#x2F;&#x2F; x0 &#x3D; real receiver, x16 &#x3D; classldr x16, [x16, #SUPERCLASS] &#x2F;&#x2F; x16 &#x3D; class-&gt;superclassCacheLookup NORMALEND_ENTRY _objc_msgSendSuper2我们可以分析出objc_msgSendSuper2函数的第1个参数是receiver，第2个参数是class，但是它会通过class-&gt;superclass获取父类。我们编译阶段导出的源码第2个参数直接是superclass。两者还是有一些细微差别的。验证_objc_msgSendSuper2的实现上面关于_objc_msgSendSuper2的实现是我们根据汇编代码推出来的，实际上我们还可以通过运行时进行调试来验证我们推到的结论。我们在[(__bridge id)obj print];添加断点，进行Debug，如下12345678910111213(lldb) p obj(MJPerson *) $0 &#x3D; 0x00007ffee94da4e8(lldb) x&#x2F;4g 0x00007ffee94da4e80x7ffee94da4e8: 0x0000000106725010 0x00007ff7957048000x7ffee94da4f8: 0x0000000106724f48 0x00007fff516daaa8(lldb) po 0x0000000106725010MJPerson(lldb) po 0x00007ff795704800&lt;ViewController: 0x7ff795704800&gt;(lldb) po 0x0000000106724f48ViewController我们发现obj紧挨着的下一个内存指向的是MJPerson，接下来指向的是ViewController的实例对象，再接下来指向的是ViewController的类。如下表所示，验证了我们的猜想低地址-&gt;高地址指针指向的内存区域obj 0x00007ffee94da4e8指针指向clscls 0x0000000106725010指针指向MJPersonself 0x00007ff795704800指针指向ViewController实例对象类指针 0x0000000106724f48指针指向ViewController总结关于super面试题的分析，我们要知道这结构要点熟悉OC的消息发送；拿到receiver，取receiver的isa，根据isa找class熟悉实例对象的内存结构；isa后面跟着成员变量栈空间是从高地址-&gt;低地址依次分配内存[super message]会先生生成一个objc_super的结构体，然后转化为objc_msgSendSuper(结构体, SEL)进行调用super调用，底层会转换为objc_msgSendSuper2函数的调用，接收2个参数struct objc_super2SEL1234struct objc_super2 &#123; id receiver; // receiver是消息接收者 Class current_class; // current_class是receiver的Class对象&#125;;参考和源码源码：Interview02-super","categories":[],"tags":[]},{"title":"block的copy、访问对象类型变量的底层实现","slug":"day09-block的copy、访问对象类型变量的底层实现","date":"2020-05-20T06:09:14.000Z","updated":"2020-05-21T04:18:31.171Z","comments":true,"path":"p/a3ade774/","link":"","permalink":"https://ticsmatic.com/p/a3ade774/","excerpt":"学习MJ的视频课程，整理总结知识点–block的copy、访问对象类型变量的底层实现本文结合block的特性，探讨ARC下block自动copy的时机；以及block内访问外部的对象类型变量时底层实现；","text":"学习MJ的视频课程，整理总结知识点–block的copy、访问对象类型变量的底层实现本文结合block的特性，探讨ARC下block自动copy的时机；以及block内访问外部的对象类型变量时底层实现；block的copy在上一节的block学习中我们遇到，在ARC环境下，block有时会被自动拷贝到堆空间去，我们可以分析一下原因。常见的场景就是block里面访问一个局部变量，根据上一节所学，MRC下访问auto变量的block是存储在栈上的，但是我们在ARC环境下演练测试发现它是存储在堆空间上。因为栈空间内存是系统自动做处理的，堆空间才是开发者手动控制。如果让block保留在栈空间，很可能当我们调用block的时候，它已经被系统自动回收了，肯定不是我们想要的结果，所以在ARC下block会被自动copy到堆空间上，有开发者控制它的释放时机(不过这些工作实际是由ARC机制处理了)ARC下block进行自动copy的根本目的是为了防止block在栈空间上被不合时宜的自动释放，而此时调用被释放的block就会出错，而copy到堆空间就不会自动释放。从这个根本原因出发，我们可以总结一下在ARC环境下，block在哪些场景会被自动copy到堆上。首先，我们知道需要copy操作的一般是NSStackBlock类型的block，而NSStackBlock类型的block的产生是因为block访问了auto变量。所以我们可以推出一个关键点：在ARC下，访问了auto变量的block，默认都会进行copy操作，防止它在栈上被自动释放。包括以下几种：block作为函数返回值时(Masonry中)将block赋值给__strong指针时block作为一些函数的参数时(cocoa API useringBlock参数)、（GCD API block参数）对象类型的auto变量在之前的测试中，我们更多的是用block访问基本类型的auto变量，现在我们研究block访问对象类型的auto变量的底层。参见Demo，新建一个自定义类，研究它的实例对象释放时机12345678910int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; &#123; MJPerson *person = [[MJPerson alloc] init]; person.age = 10; &#125; // person dealloc &#125; return 0;&#125;默认情况下，person对象在出了大括号后，就会调用自己的dealloc方法进行释放。当我们用一个block访问person的属性时12345678910MJBlock block;&#123; MJPerson *person = [[MJPerson alloc] init]; person.age = 10; block = ^&#123; NSLog(@\"---------%d\", person.age); &#125;;&#125;// person not dealloc此时发现person出了大括号的作用域，没有调用dealloc，直到block销毁时，person才销毁。我们简化一下代码如下123456MJBlock block;MJPerson *person = [[MJPerson alloc] init]; person.age = 10;block = ^&#123; NSLog(@\"---------%d\", person.age);&#125;;我们研究此时的block源码，分析为什么会是这样。clang编译后的block源码如下1234567891011struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; MJPerson *person; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, MJPerson *_person, int flags=0) : person(_person) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;block结构体里面有person的指针，而block在堆空间，在ARC下，block会强引用着person，所以当block销毁时person才会销毁。我们还可以验证在MRC环境下person的释放时机，此时block是在栈空间的。会发现在MRC下，person出了自己的大括号作用域后，就销毁了。我们可与得出一个结论：栈空间上的block是不会对对象类型的auto变量强引用，堆空间上的block会对对象类型的auto变量强引用。我们再使用weak类型的person实验一下此时person的释放时机1234567891011MJBlock block;&#123; MJPerson *person = [[MJPerson alloc] init]; person.age = 10; __weak MJPerson *weakPerson = person; block = ^&#123; NSLog(@\"---------%d\", person.age); &#125;;&#125;NSLog(@\"------\");会发现person在出了自己的大括号作用域后就销毁了，说明此时block是没有强引用着person对象，我们看下使用__weak时的block源码此时用clang命令会报错cannot create __weak reference because the current deployment target does因为__weak是属于运行时的特性，clang默认是编译期，我们要指定clang的runtime环境才能导出源文件。修改clang命令如下：1clang -rewrite-objc -fobjc-arc -fobjc-runtime&#x3D;ios-9.0.0 main.m -o main2.cpp我们看此时的block源码如下1234567891011struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; MJPerson *__weak weakPerson; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, MJPerson *__weak _weakPerson, int flags=0) : weakPerson(_weakPerson) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;会发现block里面的person对象是MJPerson *__weak weakPerson;类型，从字面意思上理解就是block不强引用这个person对象了，这也就解释了为什么__weak的person对象在出了自己的大括号作用域后就销毁了，因为没有别的对象对它强引用了。我们再看下此时block的desc结构体123456static struct __main_block_desc_0 &#123; size_t reserved; size_t Block_size; void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*); void (*dispose)(struct __main_block_impl_0*);&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;会发现此时的__main_block_desc_0结构体，相对于访问基本类型的auto变量时多了两个函数指针void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*); void (*dispose)(struct __main_block_impl_0*);而这两个函数的实现如下1234567static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123; _Block_object_assign((void*)&amp;dst-&gt;weakPerson, (void*)src-&gt;weakPerson, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123; _Block_object_dispose((void*)src-&gt;weakPerson, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;说明当BLOCK_FIELD_IS_OBJECT时，会多两个函数实现，分别是_Block_object_assign、_Block_object_dispose。实际上_Block_object_assign就是block决定是否引用person对象的关键，当block内部的person是MJPerson *__weak weakPerson;，_Block_object_assign就也是用__weak关联这个person小结关于block访问对象类型的auto变量，做一个总结如果block是在栈上，将不会对auto变量产生强引用如果block被拷贝到堆上会调用block内部的copy函数copy函数内部会调用_Block_object_assign函数_Block_object_assign函数会根据auto变量的修饰符（strong、weak、__unsafe_unretained）做出相应的操作，形成强引用（retain）或者弱引用如果block从堆上移除会调用block内部的dispose函数dispose函数内部会调用_Block_object_dispose函数_Block_object_dispose函数会自动释放引用的auto变量（release）参考和源码Demo源码：Block底层-Demo","categories":[],"tags":[]},{"title":"block的copy、访问对象类型变量的底层实现、__block的底层实现","slug":"day10-__block的底层、block的循环引用","date":"2020-05-20T06:09:14.000Z","updated":"2020-05-22T01:13:55.114Z","comments":true,"path":"p/5ee3d56b/","link":"","permalink":"https://ticsmatic.com/p/5ee3d56b/","excerpt":"学习MJ的视频课程，整理总结知识点–__block的底层实现本文根据前面所学的block的特性，结合Demo来讲解关于block的底层的一些东西。包括block的底层源码，","text":"学习MJ的视频课程，整理总结知识点–__block的底层实现本文根据前面所学的block的特性，结合Demo来讲解关于block的底层的一些东西。包括block的底层源码，__block关于block还要一个比较常见的场景就是block修饰，这一部分参见[block底层-Demo](https://cdn.ticsmatic.com/source/2020-05-21/diceng/day09/Interview04-__block.zip)1234567int age = 10;// __block int age = 10;void (^block)(void) = ^&#123; age = 20; NSLog(@\"%d\", age);&#125;;block();我们知道如果不加__block，编译器是会报错。根据前面所学的block变量捕获，我们知道当block访问的外部变量是auto类型时，如果这个变量是基本类型，block会先把这个变量捕获到内部，所以block内部的age变量和外边的age此时已经不属于同一块内存空间了，自然就不能修改。那怎么才能修改age的值，有以下两种方法1.用static或全局变量修饰age变量2.用__block修饰age变量第1种方法我们我们知道此时block内部要么捕获age的指针地址，要么不捕获age，直接访问age，都是可以对age进行修改。第2种加上__block后为什么也可以呢？我们通过源码进行分析这一过程，首先还是用clang导出block源码，如下1234567891011struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; __Block_byref_age_0 *age; // by ref __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_age_0 *_age, int flags=0) : age(_age-&gt;__forwarding) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;而此时__Block_byref_age_0的结构如下1234567struct __Block_byref_age_0 &#123; void *__isa;__Block_byref_age_0 *__forwarding; int __flags; int __size; int age;&#125;;而此时block内部的代码如下123456static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; __Block_byref_age_0 *age = __cself-&gt;age; // bound by ref (age-&gt;__forwarding-&gt;age) = 20; NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_k2_y136z2p908718gwl0q6xh92w0000gn_T_main_149db6_mi_0, (age-&gt;__forwarding-&gt;age)); &#125;定义__block int age = 10;转化为源码如下1234567__Block_byref_age_0 age = &#123; (void*)0, (__Block_byref_age_0 *)&amp;age, 0, sizeof(__Block_byref_age_0), 10&#125;;我们发现，用block修饰后，age被包装成`Block_byref_age_0 *age;，变为结构体，而这个结构体内部存放的有age的值。block内部的age变为Block_byref_age_0 *age; // by ref。 block函数实现部分age-&gt;forwarding指向自己的结构体地址，可以通过(age-&gt;forwarding-&gt;age) = 20;`修改内部age的值。这也解释为什么block可以修改值的本质原因。概述一下block修饰的作用：__block修饰的变量会被包装成一个对象(`Block_byref_xx_0)，这个对象的结构体内部有用于存储真实的变量的成员。block内部有__Block_byref_xx_0成员变量用来访问和修改变量xx`。__block修饰符小结：__block可以用于解决block内部无法修改auto变量值的问题编译器会将block变量包装成一个对象(`Block_byref_xx_0`)__block不能修饰全局变量、静态变量（static）再用一张图片做一下总结__block修饰的变量的地址我们通过下面这段代码研究输出的age的地址123456__block int age = 10;void (^block)(void) = ^&#123; age = 20; NSLog(@\"%d\", age);&#125;;NSLog(@\"%p\", &amp;age); // p/x &amp;(blockImpl-&gt;age-&gt;age)这段代码的底层源码上面我们已经分析过了，block内部有一个__Block_byref_age_0 *age; // by ref的成员变量，而__Block_byref_age_0结构体内部有一个int age;的成员变量。那么上面的代码输出的age地址是__Block_byref_age_0的地址，还是__Block_byref_age_0内部的int age的地址？其实我们分析也可以得知，输出的应该是__Block_byref_age_0内部的int age的地址。一方面OC的语言设计者是不希望暴露block的内部细节给开发者，因为开发者平时没必要关注内部的细节。还有KVO动态生成子类，但是返回的class还是原来的类也是这样，为了屏蔽这个动态的子类。另一方面，我们在block内部给age赋值时，block源码内部也是通过结构体拿到int age进行赋值操作，所以读取的话，理论上应该也是返回这个int age。我们可以通过实现block的源码来验证一个观点，参见__block转结构体-Demo__block内存管理如果认真看__block编译后的源码会发现，__block修饰的变量的底层源码和block访问对象类型的auto变量的底层源码有很多的相似之处。参见对比源码中__block底层-Demo中main.cpp文件比如__block的变量会被包装成对象，拥有这个对象，对这个对象进行内存管理。block源码内部都会有copy和dispose函数等。block内部都会通过_Block_object_assign函数引用者block要访问的外部变量。block销毁时，也都会调用_Block_object_dispose函数进行解除引用。但是也是有一些不同点，对__block的内存管理可以总结如下：当block在栈上时，并不会对__block变量产生强引用当block被copy到堆时会调用block内部的copy函数copy函数内部会调用_Block_object_assign函数_Block_object_assign函数会对__block变量形成强引用（retain）当block拷贝到堆上时，内部访问的变量如果在栈上也会拷贝到，如果在堆上，引用计数会+1。这样来达到block来管理内部访问的变量)当block从堆中移除时会调用block内部的dispose函数dispose函数内部会调用_Block_object_dispose函数_Block_object_dispose函数会自动释放引用的block变量（release）![block-dispose01](https://cdn.ticsmatic.com/img/2020-05-21/15900714319132.png)__forwarding我们获取在前面已经发现，__block变量内部默认有一个__forwarding指针，而且在block实现内部，比如上面我们修改age的值时，也是通过__forwarding来访问age的((age-&gt;__forwarding-&gt;age) = 20;)。为什么不直接通过结构体访问里面的age，而是间接通过__forwarding指针来访问age？对象类型的auto变量、__block变量小结当block在栈上时，对它们都不会产生强引用当block拷贝到堆上时，都会通过copy函数来处理它们__block变量（假设变量名叫做a）_Block_object_assign((void*)&amp;dst-&gt;a, (void*)src-&gt;a, 8/*BLOCK_FIELD_IS_BYREF*/);对象类型的auto变量（假设变量名叫做p）_Block_object_assign((void*)&amp;dst-&gt;p, (void*)src-&gt;p, 3/*BLOCK_FIELD_IS_OBJECT*/);当block从堆上移除时，都会通过dispose函数来释放它们__block变量（假设变量名叫做a）_Block_object_dispose((void*)src-&gt;a, 8/*BLOCK_FIELD_IS_BYREF*/);对象类型的auto变量（假设变量名叫做p）_Block_object_dispose((void*)src-&gt;p, 3/*BLOCK_FIELD_IS_OBJECT*/);__block修饰对象类型12__block MJPerson *weakPerson = person;__block __weak MJPerson *weakPerson = person;当__block变量在栈上时，不会对指向的对象产生强引用当__block变量被copy到堆时会调用__block变量内部的copy函数copy函数内部会调用_Block_object_assign函数_Block_object_assign函数会根据所指向对象的修饰符（strong、weak、__unsafe_unretained）做出相应的操作，形成强引用（retain）或者弱引用（注意：这里仅限于ARC时会retain，MRC时不会retain）如果block变量从堆上移除会调用block变量内部的dispose函数dispose函数内部会调用_Block_object_dispose函数_Block_object_dispose函数会自动释放指向的对象（release）循环引用因为block默认会对访问的对象进行强引用，如果此时对象已经对这个block强引用了，很容易就造成循环引用，从而导致内存泄露。如下12345MJPerson *person = [[MJPerson alloc] init];person.age = 10;person.block = ^&#123; NSLog(@\"age is %d\", person.age);&#125;;这段测试代码就会有循环引用的问题，因为block内部访问对象类型的person的变量，block此时默认会强引用这个person对象，而这个block又是person的成员变量，所以person会强引用着block。这就出现了循环引用。ARC下循环引用的解决__weak通常的解决方法就是不让block强引用person对象，用__weak修饰person对象，如下1234567MJPerson *person = [[MJPerson alloc] init];person.age = 10;__weak MJPerson *weakPerson = person;// __weak typeof(person) weakPerson = person;person.block = ^&#123; NSLog(@\"age is %d\", weakPerson.age);&#125;;这样就打破了循环引用了，对象就可以正常的释放了。__unsafe_unretained解决循环引用还有另一种方法，就是使用__unsafe_unretained，如下1234__unsafe_unretained typeof(person) weakPerson = person;person.block = ^&#123; NSLog(@\"age is %d\", weakPerson.age);&#125;;使用__unsafe_unretained，block就不会对person产生强引用。但是它不安全，体现在当block内的weakPerson销毁时，block内指针存储的地址值不变，此时访问weakPerson就可能出现坏内存访问的问题。而用__weak时，指向的对象销毁时，会自动让指针置为nil。12&#x2F;&#x2F; __weak：不会产生强引用，指向的对象销毁时，会自动让指针置为nil&#x2F;&#x2F; __unsafe_unretained：不会产生强引用，不安全，指向的对象销毁时，指针存储的地址值不变___block解决循环引用还有一种方法就是使用___block修饰，如下：123456__block typeof(person) weakPerson = person;person.block = ^&#123; NSLog(@\"age is %d\", weakPerson.age); weakPerson = nil;&#125;;person.block();分析：此时内部会有3个对象，分别是block对象、block对象、block对象内部的person对象。其中block对象会强引用着block对象，block对象内部会强引用着person对象，但是我们上面的代码，在block的实现里面，当block内代码走完时，手动把内部的person指针置为nil，此时block就不会对person对象强引用，就可以打破循环引用了。![使用block打破循环引用](https://cdn.ticsmatic.com/img/2020-05-21/15900751183030.png)MRC下循环引用的解决MRC不支持__weak，可以使用__unsafe_unretained1234__unsafe_unretained typeof(person) weakPerson = person;person.block = ^&#123; NSLog(@\"age is %d\", weakPerson.age);&#125;;可以使用_block，因为block修饰对象类型的变量，在MRC下是不会自动持有对象的1234__block typeof(person) weakPerson = person;person.block = ^&#123; NSLog(@\"age is %d\", weakPerson.age);&#125;;补充在解决循环引用时，有一种常见的写法是在block内部使用__strong，我们看这段代码12345__weak typeof(self) weakSelf = self; self.block = ^&#123; __strong typeof(weakSelf) strongSelf = weakSelf; NSLog(@\"age is %d\", strongSelf-&gt;_age); &#125;;解决循环引用时，使用weak类型的对象，但是当执行block内部的逻辑代码时，如果self被释放，此时block访问释放的self就会挂，在block里面使用的strong修饰的weakSelf是为了在函数生命周期中防止self提前释放。strongSelf是一个自动变量当block执行完毕就会释放自动变量，strongSelf不会对self进行一直进行强引用。总结block本质上也是一个OC对象，它内部也有个isa指针block是封装了函数调用以及函数调用环境的OC对象block的底层结构如图所示参考和源码Demo源码：__block底层-Demo__block转结构体-Demo","categories":[],"tags":[]},{"title":"block详解","slug":"day08-block详解","date":"2020-05-14T02:53:04.000Z","updated":"2020-06-01T03:48:32.232Z","comments":true,"path":"p/95e305cc/","link":"","permalink":"https://ticsmatic.com/p/95e305cc/","excerpt":"学习MJ的视频课程，整理总结知识点–block详解block是OC中实用频率很高的一个功能，同时在其它语言中也有相似的特性，比如swift中的闭包，Python中的闭包等。本文先通过简单介绍block的使用，然后通过clang重新编译导出block的一些源码来了解block的底层结构，随后会介绍block中的重要知识点1. block中的变量捕获，2. block的类型","text":"学习MJ的视频课程，整理总结知识点–block详解block是OC中实用频率很高的一个功能，同时在其它语言中也有相似的特性，比如swift中的闭包，Python中的闭包等。本文先通过简单介绍block的使用，然后通过clang重新编译导出block的一些源码来了解block的底层结构，随后会介绍block中的重要知识点1. block中的变量捕获，2. block的类型block的使用在OC中使用block，大致如下1234567891011121314151617181920// 实现一个最简单的block^&#123;&#125;;// 实现并调用^&#123;&#125;();// 声明并指向一个blockvoid (^block)(void) = ^&#123;&#125;;void (^block2)(int, int) = ^(int a, int b)&#123;&#125;;// 调用block();block2(1, 2);// 先声明blockvoid (^block3)(int);// 实现blockblock3 = ^(int a)&#123; &#125;;// 调用block3(1);我们要明白，哪些是block声明、哪些是实现、哪些是调用，使用上就不会弄混了。block源码解析下面我们通过一个Demo分析block的底层源码思路是把包含block代码的文件通过clang命令重写导出，就可以看到block的源码了。12345678910int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; void (^block)(void) = ^&#123; NSLog(@\"Hello, World!\"); &#125;; block(); &#125; return 0;&#125;通过clang命令重写导出为cpp文件1clang -rewrite-objc main.m -o main0.cpp我们观察生成的main0.cpp文件中main函数部分，去掉里面不重要的类型转转换代码后，如下12345678910// 定义block变量void (*block)(void) = &amp;__main_block_impl_0( __main_block_func_0, &amp;__main_block_desc_0_DATA );// 执行block内部的代码// ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);// 因为__block_impl是第一个变量，所以和__main_block_impl_0的地址相同，所以__main_block_impl_0可以强转为__block_impl进行block-&gt;FuncPtr(block);__main_block_impl_0我们从定义block变量入手分析，我们查看__main_block_impl_0，发现这一步是结构体有返回值，查看它的定义如下：1234567891011struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; // c++构造函数（类似于OC的init方法），返回结构体对象 __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;__main_block_impl_0的内部有__block_impl、__main_block_desc_0、以及一个构造函数__main_block_impl_0，类似OC的init方法，通过构造函数给结构体的变量赋值，最后返回结构体。__block_impl接下来分析__block_impl，它的定义如下：123456struct __block_impl &#123; void *isa; int Flags; int Reserved; void *FuncPtr;&#125;;__block_impl是一个结构体，它的内部两个地方需要注意，void *isa和void *FuncPtr。isa很像之前学习的OC对象，我们知道OC对象中的isa是指向类的，我们可以提出一个疑问：block是OC对象吗，它的isa指向哪里。另外，void *FuncPtr是个指针，它指向哪里？我们在下面的文章中再讲解这两个问题。__main_block_func_0回到主题，已经明白了__main_block_func_0的结构，那么接下来可以查看__main_block_func_0的的接口，如下：1234// 封装了block执行逻辑的函数static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_2r__m13fp2x2n9dvlr8d68yry500000gn_T_main_c60393_mi_0);&#125;这个__main_block_func_0内部其实就是我们在OC中写的下面这段代码123^&#123; NSLog(@\"Hello, World!\");&#125;;所以我们可以知道__main_block_func_0实际上就是block内执行的函数代码。还有一个地方就是__main_block_desc_0，它的定义如下：1234static struct __main_block_desc_0 &#123; size_t reserved; size_t Block_size;&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;从这里我们可以了解到，__main_block_desc_0_DATA是获取block结构体的大小，其中reserved是扩展保留字。我们回到__main_block_impl_0的构造函数，我们发现FuncPtr是指向__main_block_func_0，也是就block的执行逻辑的函数，故可以理解为FuncPtr指向block的执行函数地址。通过block的源码学习我们可以得知：block本质是结构体，且有isa指针(实际上block本质也是一个OC对象)__main_block_impl_0是block的结构体的主要信息根据block的底层源码学习，可以总结更直观的的图示，如下block变量捕获通过上面的雨那么分析，我们了解了block的底层结构，下面我们分析一下block中经常用到的变量捕获，同样使用上面的Demo进行分析当在block内访问外部变量时，可能会触发变量捕获。12345678910int age = 10;static int height = 10;void (^block)(void) = ^&#123; // age的值捕获进来（capture） NSLog(@\"age is %d, height is %d\", age, height); // age is 10, height is 20&#125;;age = 20;height = 20;block();根据经验我们知道，当调用block时，输出的结果为age is 10, height is 20，下面我们分析为什么会是这样，并总结规律。首先，我们对这部分代码用clang重写导出为cpp文件，观察源码中block相关的部分，我们发现123456789101112struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; int age; int *height; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _age, int *_height, int flags=0) : age(_age), height(_height) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;我们发现，结构体__main_block_impl_0里面多了两个字段int age、int *height，其中age是数值型，height是指针型。我们分析调用顺序123456789int age = 10;static int height = 10; void (*block)(void) = &amp;__main_block_impl_0( __main_block_func_0, &amp;__main_block_desc_0_DATA, age, &amp;height );可以发现age的值，直接被传递到__main_block_impl_0结构体中，这个结构体的构造函数会保存这个age的值，而height是指针传递，结构体中也有对应的height，但是是一个指针类型的。所以，结构体内部仅持有static类型变量的指针，当外接height的值发生改变时，block内获取到的height也会相应改变。在block结构体内部创建age、height保存访问的外部变量的过程，我们称之为变量捕获。变量捕获是为了保证block内部能正常访问外部变量。什么情况不需要变量捕获呢，其实我们可以推断一下，变量捕获的目的是为了保证block内部能正常访问外部的变量。假如访问的外部变量是一个全局变量，那么block随时都可以访问到这个全局变量，此时block就不需要捕获，而是直接访问这个全局变量。总结：局部变量，block要访问的话就会捕获全局变量，不会捕获，直接访问还有一种比较常见的场景，比如在一个方法中，block访问self的属性12345678@implementation MJPerson- (void)test &#123; void (^block)(void) = ^&#123; NSLog(@\"-------%@\", self.name); &#125;; block();&#125;@end此时block是够会捕获self变量或者self.name变量呢，答案是会，我们可以查看clang导出的对应源码，如下1234567891011struct __MJPerson__test_block_impl_0 &#123; struct __block_impl impl; struct __MJPerson__test_block_desc_0* Desc; MJPerson *self; __MJPerson__test_block_impl_0(void *fp, struct __MJPerson__test_block_desc_0 *desc, MJPerson *_self, int flags=0) : self(_self) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;看到确实是捕获了，而且捕获的是self这个变量。我们可以分析一下原因：以为self是test函数的默认参数（self和cmd），而self又不是全局变量，根据上面的总结，block访问局部变量都会进行捕获，而要访问的name属于self的对象的一个属性，所以block就不捕获self，通过self访问其中的name。block类型我们知道block有isa，那么这个isa是否来自NSObject，block的isa是否代表它是对象类型的结构可以先假设block是对象类型，那么调用[block class]时，必然会返回对应的类型，通过下面这段代码进行测试12345678void (^block)(void) = ^&#123; NSLog(@\"Hello\");&#125;; NSLog(@\"%@\", [block class]); // __NSGlobalBlock__NSLog(@\"%@\", [[block class] superclass]); // __NSGlobalBlockNSLog(@\"%@\", [[[block class] superclass] superclass]); // NSBlockNSLog(@\"%@\", [[[[block class] superclass] superclass] superclass]); // NSObject通过上面代码可以确认block确实是有class的，isa指针是来自NSObject。我们可以进一步总结：block本质上也是一个OC对象，它内部也有个isa指针block是封装了函数调用以及函数调用环境的OC对象实际上，block有3种类型，可以通过调用class方法或者isa指针查看具体类型，最终都是继承自NSBlockNSGlobalBlock （ NSConcreteGlobalBlock ）_NSStackBlock （ NSConcreteStackBlock ）_NSMallocBlock （ _NSConcreteMallocBlock ）12345678910111213// 堆：动态分配内存,需要程序员申请申请，也需要程序员自己管理内存void (^block1)(void) = ^&#123; NSLog(@\"Hello\");&#125;; int age = 10;void (^block2)(void) = ^&#123; NSLog(@\"Hello - %d\", age);&#125;; NSLog(@\"%@ %@ %@\", [block1 class], [block2 class], [^&#123; NSLog(@\"%d\", age); // __NSGlobalBlock__ __NSMallocBlock__ __NSStackBlock__&#125; class]);我们现在知道了block有3种类型，那么它们的区别是什么？其实从名字分析，我们就看会发现一些特点Global，Stack，Malloc，实际上它们对应是在内存中的区域。如下程序区域：一般存放的是函数数据区域：一般存放的是全局变量堆区：动态分配内存，比如我们alloc出来的对象，需要开发者申请，释放对应的内存栈区：自动分配内存局，系统自动管理，存放局部变量，函数中变量等block存储在不同的内存区域，是根据什么来划分的？我们先给出总结的结果block类型环境NSGlobalBlock没有访问auto变量NSStackBlock访问了auto变量NSMallocBlockNSStackBlock调用了copy实际上我们现在在项目中很少遇到__NSStackBlock__类型的block，因为在ARC环境下，__NSStackBlock__类型的block在使用的是否，系统会自动把它copy到堆上去，成为__NSMallocBlock__类型，所以我们在测试的时候，需要把ARC环境关闭(Automatic Reference Counting改为NO)才能验证copy到堆上是为了不让程序自动管理，交由开发者管理它的释放时机每一种类型的block调用copy后的结果如下所示关于判断存储的内存区域，我们有一个简单的方法，就是看内存地址和哪一个已知区域的地址接近123456789int age = 10;void test() &#123; int a = 10; NSLog(@\"数据段：age %p\", &amp;age); NSLog(@\"数据段：class %p\", [MJPerson class]); NSLog(@\"堆：obj %p\", [[NSObject alloc] init]); NSLog(@\"栈：a %p\", &amp;a); // 同一个内存区域的内存地址值比较接近&#125;总结根据本节所学的block知识，我们可以总结一下block本质上也是一个OC对象，它内部也有个isa指针block是封装了函数调用以及函数调用环境的OC对象block的底层结构如右图所示auto变量的捕获block有3种类型，可以通过调用class方法或者isa指针查看具体类型，最终都是继承自NSBlock类型NSGlobalBlock （ NSConcreteGlobalBlock ）_NSStackBlock （ NSConcreteStackBlock ）_NSMallocBlock （ _NSConcreteMallocBlock ）block类型环境NSGlobalBlock没有访问auto变量NSStackBlock访问了auto变量NSMallocBlockNSStackBlock调用了copy每一种类型的block调用copy后的结果如下所示参考和源码Demo源码：Block底层-Demo","categories":[],"tags":[]},{"title":"load initialize的本质","slug":"day06-load initialize的本质","date":"2020-05-07T10:10:44.000Z","updated":"2020-05-08T11:00:30.000Z","comments":true,"path":"p/4235a91d/","link":"","permalink":"https://ticsmatic.com/p/4235a91d/","excerpt":"学习MJ的视频课程，整理总结知识点–load initialize的本质这一篇通过+load和+initialize的官方文档并结合Demo来介绍这两个方法。同时会依据runtime源码来介绍+load和+initialize底层的逻辑。","text":"学习MJ的视频课程，整理总结知识点–load initialize的本质这一篇通过+load和+initialize的官方文档并结合Demo来介绍这两个方法。同时会依据runtime源码来介绍+load和+initialize底层的逻辑。[TOC]+load介绍关于+load，我们知道+load方法会在runtime加载类、分类时调用，apple文档中关于load介绍如下1234567891011121314151617181920212223SummaryInvoked whenever a class or category is added to the Objective-C runtime; implement this method to perform class-specific behavior upon loading.Declaration+ (void)load;DiscussionThe load message is sent to classes and categories that are both dynamically loaded and statically linked, but only if the newly loaded class or category implements a method that can respond.The order of initialization is as follows:All initializers in any framework you link to.All +load methods in your image.All C++ static initializers and C/C++ __attribute__(constructor) functions in your image.All initializers in frameworks that link to you.In addition:A class’s +load method is called after all of its superclasses’ +load methods.A category +load method is called after the class’s own +load method.In a custom implementation of load you can therefore safely message other unrelated classes from the same image, but any load methods implemented by those classes may not have run yet.ImportantCustom implementations of the load method for Swift classes bridged to Objective-C are not called automatically.结合文档我们知道+load方法会在runtime加载类、分类时调用每个类、分类的+load，在程序运行过程中只调用一次先调用类的+load，再调用分类的+load调用子类的+load之前会先调用父类的+load+load调用原理我们知道+load是在runtime添加到运行时的时候调用，所以我们可以从runtime源码入手，查找并分析+load的调用原理结合上一篇文章，我们知道runtime的初始化方法是_objc_init，这个函数内部有这个方法_dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);，其中，load_images就是我们剖析+load机制的入口。我们看一下load_images函数的源码：123456789101112131415161718192021222324/************************************************************************ load_images* Process +load in the given images which are being mapped in by dyld.** Locking: write-locks runtimeLock and loadMethodLock**********************************************************************/voidload_images(const char *path __unused, const struct mach_header *mh)&#123; // Return without taking locks if there are no +load methods here. if (!hasLoadMethods((const headerType *)mh)) return; recursive_mutex_locker_t lock(loadMethodLock); // Discover load methods &#123; rwlock_writer_t lock2(runtimeLock); prepare_load_methods((const headerType *)mh); &#125; // Call +load methods (without runtimeLock - re-entrant) call_load_methods();&#125;这个函数内部主要分3步（判断、查找并添加、调用），我们对这3个步骤用通俗易懂的语言进行概述：判断有没有+load方法，没有的话直接return；有的话就添加到一个数据保存起来；遍历这个数据，调用每个元素的+load方法。下面进行每一步的介绍。1. hasLoadMethods12345678// Quick scan for +load methods that doesn't take a lock.bool hasLoadMethods(const headerType *mhdr)&#123; size_t count; if (_getObjc2NonlazyClassList(mhdr, &amp;count) &amp;&amp; count &gt; 0) return true; if (_getObjc2NonlazyCategoryList(mhdr, &amp;count) &amp;&amp; count &gt; 0) return true; return false;&#125;这个函数概述为就是快速查找所有的class、category里面是否包含+load方法。(注：实现了+load方法的class才属于NonlazyClass)2. prepare_load_methods判断完之后就是查找所有的+load方法，prepare_load_methods函数的主要代码如下：123456789101112131415161718192021222324void prepare_load_methods(const headerType *mhdr)&#123; size_t count, i; runtimeLock.assertWriting(); // 遍历有+load的class，添加到'loadable_classes'中(有superclass的，先递归添加superclass)，把class标记为'RW_LOADED' classref_t *classlist = _getObjc2NonlazyClassList(mhdr, &amp;count); for (i = 0; i &lt; count; i++) &#123; schedule_class_load(remapClass(classlist[i])); &#125; // 遍历有+load的category，做一些逻辑判断，然后添加到'loadable_categories' category_t **categorylist = _getObjc2NonlazyCategoryList(mhdr, &amp;count); for (i = 0; i &lt; count; i++) &#123; category_t *cat = categorylist[i]; Class cls = remapClass(cat-&gt;cls); if (!cls) continue; // category for ignored weak-linked class realizeClass(cls); assert(cls-&gt;ISA()-&gt;isRealized()); add_category_to_loadable_list(cat); &#125;&#125;这个过程把包含有+load方法的class添加到数组loadable_classes中，把包含有+load方法的category添加到数组loadable_categories中。prepare_load_methods过程中，内部有一个schedule_class_load方法需要讲解一下，它的实现如下：123456789101112131415161718192021/************************************************************************ prepare_load_methods* Schedule +load for classes in this image, any un-+load-ed * superclasses in other images, and any categories in this image.**********************************************************************/// Recursively schedule +load for cls and any un-+load-ed superclasses.// cls must already be connected.static void schedule_class_load(Class cls)&#123; if (!cls) return; assert(cls-&gt;isRealized()); // _read_images should realize // 判断class结构体信息中是否加载的标记 if (cls-&gt;data()-&gt;flags &amp; RW_LOADED) return; // Ensure superclass-first ordering，通过递归的方式先取出superclass schedule_class_load(cls-&gt;superclass); // 添加到数组中保存起来 add_class_to_loadable_list(cls); // cls标记为已加载 cls-&gt;setInfo(RW_LOADED); &#125;这个函数内部有个递归调用，先去class的superclass添加到数组中，这就解释了子类+load方法调用时，会先调用父类的+load这一现象。3. call_load_methods添加到loadable_classes数组和数组loadable_categories后，就是遍历数组，调用数组元素的+load方法。函数主要内容如下：1234567891011121314151617181920212223242526272829303132333435/************************************************************************ call_load_methods* Call all pending class and category +load methods.* Class +load methods are called superclass-first. * Category +load methods are not called until after the parent class's +load.**********************************************************************/void call_load_methods(void)&#123; static bool loading = NO; bool more_categories; loadMethodLock.assertLocked(); // Re-entrant calls do nothing; the outermost call will finish the job. if (loading) return; loading = YES; void *pool = objc_autoreleasePoolPush(); do &#123; // 1. Repeatedly call class +loads until there aren't any more while (loadable_classes_used &gt; 0) &#123; call_class_loads(); &#125; // 2. Call category +loads ONCE more_categories = call_category_loads(); // 3. Run more +loads if there are classes OR more untried categories &#125; while (loadable_classes_used &gt; 0 || more_categories); objc_autoreleasePoolPop(pool); loading = NO;&#125;观察call_load_methods函数的实现我们得知，内部会先调用class的+load方法，之后才会调用category的+load方法。接下来看下runtime是怎么自动调用+load方法的，在call_class_loads函数内部我们可以找到答案，call_class_loads的概要源码如下：12345678910111213141516171819202122static void call_class_loads(void)&#123; int i; // Detach current loadable list. struct loadable_class *classes = loadable_classes; int used = loadable_classes_used; for (i = 0; i &lt; used; i++) &#123; // 取出class Class cls = classes[i].cls; // 拿到保存的'+load'方法 load_method_t load_method = (load_method_t)classes[i].method; if (!cls) continue; // 直接手动调用'+load'方法 (*load_method)(cls, SEL_load); &#125; // Destroy the detached list. if (classes) free(classes);&#125;所以我们可以得知，+load方法是默认通过函数地址直接调用，而不是通过OC通用的runtime消息机制+load总结+load方法会在runtime加载类、分类时调用每个类、分类的+load，在程序运行过程中只调用一次调用顺序先调用类的+load按照编译先后顺序调用（先编译，先调用）调用子类的+load之前会先调用父类的+load再调用分类的+load按照编译先后顺序调用（先编译，先调用）+initialize介绍关于+initialize，我们知道+initialize方法会在类第一次接收到消息时调用，apple文档中关于initialize介绍如下12345678910111213141516171819SummaryInitializes the class before it receives its first message.Declaration+ (void)initialize;DiscussionThe runtime sends initialize to each class in a program just before the class, or any class that inherits from it, is sent its first message from within the program. Superclasses receive this message before their subclasses.The runtime sends the initialize message to classes in a thread-safe manner. That is, initialize is run by the first thread to send a message to a class, and any other thread that tries to send a message to that class will block until initialize completes.The superclass implementation may be called multiple times if subclasses do not implement initialize—the runtime will call the inherited implementation—or if subclasses explicitly call [super initialize]. If you want to protect yourself from being run multiple times, you can structure your implementation along these lines:+ (void)initialize &#123; if (self == [ClassName self]) &#123; // ... do the initialization ... &#125;&#125;Because initialize is called in a blocking manner, it’s important to limit method implementations to the minimum amount of work necessary possible. Specifically, any code that takes locks that might be required by other classes in their initialize methods is liable to lead to deadlocks. Therefore, you should not rely on initialize for complex initialization, and should instead limit it to straightforward, class local initialization.结合文档和之前的知识我们知道+initialize方法会在类第一次接收到消息时调用先调用父类的+initialize，再调用子类的+initialize(先初始化父类，再初始化子类，每个类只会初始化1次)+initialize方法是线程安全的，要注意防止+initialize死锁，不要再+initialize内做太复杂的事情+initialize原理我们知道了+initialize的特性，接下来我们通过runtime源码分析+initialize的原理。我们已经知道+initialize是第一次接收到消息时调用，我们以此为切入点进行分析。第一次接收到消息，意味着第一次objc_msgSend(cls, @selector(xxx))，怎么知道是第一次呢，猜测应该是在objc_msgSend前先进行判断有没有initialize标记，没有的话先调用+initialize，然后再继续原有流程。还有一个查找源码的切入点是+initialize调用之后的标记值，因为我们已经知道一个class只会initialize一次，+load也是只会调用一次。同时在前面学习+load调用流程时从源码中知道，load完成时会有一步做标记cls-&gt;setInfo(RW_LOADED);，我们猜测：+initialize也会有类似的标记，仿照格式应该为RW_INITIALIZED。我们去runtime源码中搜索，果真找到这个RW_INITIALIZED，它对应的函数如下：123bool isInitialized() &#123; return getMeta()-&gt;data()-&gt;flags &amp; RW_INITIALIZED;&#125;不过我们的目的是分析什么时候调用+initialize，已经知道了这个initialize前的判断方法isInitialized()，我们就可以顺瓜摸藤，通过在objc源码中搜索isInitialized()这个方法，同时知道这个方法应该在objc_msgSend前调用，所以我们可以进一步缩小搜索范围。通过分析搜索结果，我们几乎可以确定唯一与结果相关的就是lookUpImpOrForward函数，该函数概要内容如下：123456789101112131415161718/************************************************************************ lookUpImpOrForward.* The standard IMP lookup. * initialize==NO tries to avoid +initialize (but sometimes fails)**********************************************************************/IMP lookUpImpOrForward(Class cls, SEL sel, id inst, bool initialize, bool cache, bool resolver)&#123; if (initialize &amp;&amp; !cls-&gt;isInitialized()) &#123; runtimeLock.unlockRead(); _class_initialize (_class_getNonMetaClass(cls, inst)); runtimeLock.read(); // If sel == initialize, _class_initialize will send +initialize and // then the messenger will send +initialize again after this // procedure finishes. Of course, if this is not being called // from the messenger then it won't happen. 2778172 &#125;&#125;这个函数内部有个逻辑，就是判断有没有initialized，没有的话，就调用_class_initialize方法进行初始化。这样我们就从晦涩的源码中找到我们的线索，我们就通过这条线索来分析+initialize方法的底层原理。我们通过搜索lookUpImpOrForward函数，发现是class_getClassMethod调用来lookUpImpOrForward的。我们正向分析一下。如果要对class发消息，肯定要判断消息对应的Method是否存在，这就需要class_getClassMethod这个函数来实现，正向推理也合理。接下来我们继续分析_class_initialize的实现，探究initialize过程做了哪些事情。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/************************************************************************ class_initialize. Send the '+initialize' message on demand to any* uninitialized class. Force initialization of superclasses first.**********************************************************************/void _class_initialize(Class cls)&#123; assert(!cls-&gt;isMetaClass()); Class supercls; bool reallyInitialize = NO; // Make sure super is done initializing BEFORE beginning to initialize cls. // See note about deadlock above. // 先判断supercls是否初始化，没有的话通过递归先初始化supercls supercls = cls-&gt;superclass; if (supercls &amp;&amp; !supercls-&gt;isInitialized()) &#123; _class_initialize(supercls); &#125; // Try to atomically set CLS_INITIALIZING. &#123; monitor_locker_t lock(classInitLock); if (!cls-&gt;isInitialized() &amp;&amp; !cls-&gt;isInitializing()) &#123; cls-&gt;setInitializing(); reallyInitialize = YES; &#125; &#125; if (reallyInitialize) &#123; // We successfully set the CLS_INITIALIZING bit. Initialize the class. // Record that we're initializing this class so we can message it. _setThisThreadIsInitializingClass(cls); if (MultithreadedForkChild) &#123; // LOL JK we don't really call +initialize methods after fork(). performForkChildInitialize(cls, supercls); return; &#125; // Send the +initialize message. // Note that +initialize is sent to the superclass (again) if // this class doesn't implement +initialize. 2157218 // Exceptions: A +initialize call that throws an exception // is deemed to be a complete and successful +initialize. // // Only __OBJC2__ adds these handlers. !__OBJC2__ has a // bootstrapping problem of this versus CF's call to // objc_exception_set_functions().#if __OBJC2__ @try#endif &#123; // 真正初始化的逻辑 callInitialize(cls); if (PrintInitializing) &#123; _objc_inform(\"INITIALIZE: thread %p: finished +[%s initialize]\", pthread_self(), cls-&gt;nameForLogging()); &#125; &#125;#if __OBJC2__ @catch (...) &#123; if (PrintInitializing) &#123; _objc_inform(\"INITIALIZE: thread %p: +[%s initialize] \" \"threw an exception\", pthread_self(), cls-&gt;nameForLogging()); &#125; @throw; &#125; @finally#endif &#123; // Done initializing. lockAndFinishInitializing(cls, supercls); &#125; return; &#125;&#125;结合源码我们知道，+initialize时，先调用父类的+initialize，再调用子类的+initialize我们看下真正执行+initialize的代码callInitialize，源码如下：12345void callInitialize(Class cls)&#123; ((void(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize); asm(\"\");&#125;callInitialize函数很简单，看源码我们得知，+initialize是通过runtime的消息机制调用的(而+load是加载时通过函数地址直接调用)+initialize总结结合源码分析，我们可以分析apple是如何实现+initialize方法会在类第一次接收到消息时调用(Initializes the class before it receives its first message.)进行objc_msgSend前先进行方法查找(通过class_getClassMethod)class_getClassMethod内部调用class_getInstanceMethod，利用元类进行查找class_getInstanceMethod内部通过lookUpImpOrNil判断函数是否存在lookUpImpOrNil查找函数的实现或者进行消息转发lookUpImpOrForwardlookUpImpOrForward判断class是否初始化，没有的话进行初始化_class_initialize_class_initialize内部先初始化superclass，之后调用初始化方法callInitializecallInitialize内部就是((void(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize);，调用class的initialize方法。+initialize整个流程完毕，接下来我们再对+initialize做一个总结+initialize方法会在类第一次接收到消息时调用调用顺序先调用父类的+initialize，再调用子类的+initialize(先初始化父类，再初始化子类，每个类只会初始化1次)虽有初始化只会一次，但是当子类没有实现+initialize时，父类的+initialize会被调用多次，但是父类仍然只会初始化1次，被调用多次是因为继承的原因(子类没有回去父类查找)总结综合全文，对+load和+initialize总结load、initialize方法的区别什么？调用方式1&gt; load是根据函数地址直接调用2&gt; initialize是通过objc_msgSend调用调用时机1&gt; load是runtime加载类、分类的时候调用（只会调用1次）2&gt; initialize是类第一次接收到消息的时候调用，每一个类只会initialize一次（父类的initialize方法可能会被调用多次）load、initialize的调用顺序？1.load1&gt; 先调用类的loada) 先编译的类，优先调用loadb) 调用子类的load之前，会先调用父类的load2&gt; 再调用分类的loada) 先编译的分类，优先调用load2.initialize1&gt; 先初始化父类2&gt; 再初始化子类（可能最终调用的是父类的initialize方法）参考和源码Apple Source Browser - objc","categories":[],"tags":[]},{"title":"关联对象(Associated)详解","slug":"day07-关联对象(Associated)详解","date":"2020-05-03T10:10:44.000Z","updated":"2020-05-14T01:51:32.000Z","comments":true,"path":"p/4bdf012b/","link":"","permalink":"https://ticsmatic.com/p/4bdf012b/","excerpt":"学习MJ的视频课程，整理总结知识点–关联对象(Associated)详解本文通过runtime中objc_setAssociatedObject源码为切入点，同时结合category的底层结构(struct category_t)、对象的底层结构(objc_object)，类的底层结构(objc_class)来讲解OC中的对象关联对象。主要回答：1、为什么分类不能添加属性(根本原因)、2、分类中怎样才能添加属性(关联对象)、3、关联对象的原理。","text":"学习MJ的视频课程，整理总结知识点–关联对象(Associated)详解本文通过runtime中objc_setAssociatedObject源码为切入点，同时结合category的底层结构(struct category_t)、对象的底层结构(objc_object)，类的底层结构(objc_class)来讲解OC中的对象关联对象。主要回答：1、为什么分类不能添加属性(根本原因)、2、分类中怎样才能添加属性(关联对象)、3、关联对象的原理。分类为什么不能添加属性最初学习OC编程的时候，已经知道category中不能直接添加属性，当时很好奇为什么category这么方便的东西不能直接使用属性，后来查资料知道不能直接添加属性是因为底层结构设计导致不允许。当时也只是停留在概念阶段，对于底层原因不够明了，这次通过较系统的学习，有了一定的知识储备后，再来讲解分类为什么不能添加属性。结合我之前的Category的本质文章，我们已经知道category的底层结构是struct category_t，它在编译阶段是结构体，在运行时，runtime会把category的结构体里面的信息加载到对应的class中去。同时，我们也知道struct category_t的结构体有保存的主要有实例方法列表instanceMethods、类方法列表classMethods、协议列表protocols、实例属性列表instanceProperties、类属性列表_classProperties等。但没有成员成员变量列表ivars。这就直接表明category中没有成员变量这个东西。所以即使利用@property关键字给分类增加属性，也只能增加set方法和get方法的声明，不会有实现，也会有对应的成员变量。真实因为category的结构体中不能保存成员变量，就决定了在OC中category是没有成员变量的，这是直接原因。下面，我们思考下category不能直接添加属性，根本原因是什么？为什么在设计category底层结构时不增加一个类似成员变量的东西? 下面我结合之前的文章，分析并解答。结合我之前的OC对象的本质这篇文章可以知道，成员变量在内存中是存储在OC对象内部的，这一点很重要。而方法列表、属性列表、协议列表是存储在类的内部。同时，OC对象的大小和内存布局是在编译完后就决定的了。而category存储的信息是在运行时才添加到class上，但此时，对象的大小和 内存布局已确定，假如category中有成员变量，假如成员变量能添加到对象里，那么对象的结构和大小肯定要变化，两者相悖。所以category中的是不能有成员变量的。毕竟category是Objective-C 2.0之后添加的语言特性，category的主要作用是为已经存在的类添加方法。同时，OC是基于C语言这门静态语言的扩展，虽然OC有小巧的runtime实现动态性，但它并不完全是一门动态语言。在语言设计上，OC在1.0版本时，更多的是在C语言这门静态语言的扩展，然后加上Smalltalk的消息机制。在OC2.0时，优化了runtime，但是category的设计目的是为类增加方法，加上C语言这个底子及OC1.0设计时的历史原因，OC2.0中category增加成员变量比较困难，同时重要性不是很高，所以category不能直接成员变量。但是提供了 第三方管理者 来实现category间接添加属性。这部分在objc源码中也能有所体现1234567891011121314151617static Class realizeClassWithoutSwift(Class cls, Class previously)&#123; auto ro = (const class_ro_t *)cls-&gt;data(); auto isMeta = ro-&gt;flags &amp; RO_META; if (ro-&gt;flags &amp; RO_FUTURE) &#123; // This was a future class. rw data is already allocated. rw = cls-&gt;data(); ro = cls-&gt;data()-&gt;ro(); ASSERT(!isMeta); cls-&gt;changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE); &#125; else &#123; // Normal class. Allocate writeable class data. rw = objc::zalloc&lt;class_rw_t&gt;(); rw-&gt;set_ro(ro); rw-&gt;flags = RW_REALIZED|RW_REALIZING|isMeta; cls-&gt;setData(rw); &#125;类的方法、属性等在编译期保存在data()的位置，在运行期，直到realizeClassWithoutSwift执行之后，才放到了class_rw_t指向的只读区域const class_ro_t。ps：这块内容主要是自己结合源码分析进行的总结，有错误或不严谨的地方请指出分类怎样才能添加属性我们已经知道了分类不能添加属性的直接原因和根本，但是我们在使用category时，很多时候还是需要用属性的set和get方法的。接下来我们探讨分类中间接添加属性的方式。默认情况下，因为分类底层结构的限制，不能添加成员变量到分类中。但可以通过关联对象来间接实现关联对象提供了以下API12345678// 添加关联对象void objc_setAssociatedObject(id object, const void * key, id value, objc_AssociationPolicy policy)// 获得关联对象id objc_getAssociatedObject(id object, const void * key)// 移除所有的关联对象void objc_removeAssociatedObjects(id object)key的常见用法用于关联对象的keyconst void * key，说明只要求是个指向常量的指针，使用static时为了限制key的作用域。123static void *MyKey = &amp;MyKey;objc_setAssociatedObject(obj, MyKey, value, OBJC_ASSOCIATION_RETAIN_NONATOMIC);objc_getAssociatedObject(obj, MyKey);123static char MyKey;objc_setAssociatedObject(obj, &amp;MyKey, value, OBJC_ASSOCIATION_RETAIN_NONATOMIC);objc_getAssociatedObject(obj, &amp;MyKey);123// 使用属性名作为keybjc_setAssociatedObject(obj, @\"property\", value, OBJC_ASSOCIATION_RETAIN_NONATOMIC);objc_getAssociatedObject(obj, @\"property\");123// 使用get方法的@selecor作为keyobjc_setAssociatedObject(obj, @selector(getter), value, OBJC_ASSOCIATION_RETAIN_NONATOMIC);objc_getAssociatedObject(obj, @selector(getter));这里更推荐最后一种写法，原因如下明了是为哪个属性进行的绑定，比较接近属性set和get不用额外定义key自带语法提示关联对象的原理关联对象是runtime的一部分，所以我们直接看源码即可123void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy) &#123; _object_set_associative_reference(object, (void *)key, value, policy);&#125;设置关联对象的核心源码1234567891011121314151617181920212223242526272829303132333435363738394041424344void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) &#123; // retain the new value (if any) outside the lock. ObjcAssociation old_association(0, nil); id new_value = value ? acquireValue(value, policy) : nil; &#123; AssociationsManager manager; AssociationsHashMap &amp;associations(manager.associations()); disguised_ptr_t disguised_object = DISGUISE(object); if (new_value) &#123; // break any existing association. AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) &#123; // secondary table exists ObjectAssociationMap *refs = i-&gt;second; ObjectAssociationMap::iterator j = refs-&gt;find(key); if (j != refs-&gt;end()) &#123; old_association = j-&gt;second; j-&gt;second = ObjcAssociation(policy, new_value); &#125; else &#123; (*refs)[key] = ObjcAssociation(policy, new_value); &#125; &#125; else &#123; // create the new association (first time). ObjectAssociationMap *refs = new ObjectAssociationMap; associations[disguised_object] = refs; (*refs)[key] = ObjcAssociation(policy, new_value); object-&gt;setHasAssociatedObjects(); &#125; &#125; else &#123; // setting the association to nil breaks the association. AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) &#123; ObjectAssociationMap *refs = i-&gt;second; ObjectAssociationMap::iterator j = refs-&gt;find(key); if (j != refs-&gt;end()) &#123; old_association = j-&gt;second; refs-&gt;erase(j); &#125; &#125; &#125; &#125; // release the old value (outside of the lock). if (old_association.hasValue()) ReleaseValue()(old_association);&#125;我们可以总结如下流程得出如下结论：关联对象存储在全局的统一的一个AssociationsManager中AssociationsManager里面有一个_map，管理每个对象的对象关联ObjectAssociationMapObjectAssociationMap的key保存的就是外界传递进来的参数key，value保存的就是关联值，里面包含policy、value。设置关联对象为nil，就相当于是移除关联对象AssociationsManager添加了锁，并自己做旧值的释放拓展至于protocol，我们看它的源码1234567891011struct protocol_t : objc_object &#123; const char *mangledName; struct protocol_list_t *protocols; method_list_t *instanceMethods; method_list_t *classMethods; method_list_t *optionalInstanceMethods; method_list_t *optionalClassMethods; property_list_t *instanceProperties; uint32_t size; // sizeof(protocol_t) uint32_t flags;&#125;;通过源码可知，protocol的结构有一点类似category。而且，protocol也是没有成员变量列表的，有getter、setter方法的声明，但是没有方法的实现。总结category不能直接添加属性的原因直接原因：category内部没有用于存储ivar的地方根本原因：OC是最初是基于C语言+Smalltalk，category是OC2.0才有的特性，当时的语言发展史已经决定了类在编译阶段就决定了对象的大小和内存布局。而且OC对象的成员变量是保存在对象中的。category的设计初衷是为类添加方法。这两个条件决定了为category添加变量的需求不是很高，相对于对OC底层大幅改动从而实现在category中直接添加变量，语言的设计者采取第三方管理者(关联对象)来间接实现添加成员变量关联对象使用个人建议使用@selector(getter)作为关联对象的key关联对象的原理使用一个全局的AssociationsManager，它的内部有一个map，map的key对应要关联的对象，value保存的是ObjectAssociationMap，这个ObjectAssociationMap关联key和值信息。这一部分看上面总结的图会更清晰参考和源码Apple Source Browser - objc","categories":[],"tags":[]},{"title":"Category的本质","slug":"day06-Category的本质","date":"2020-05-03T10:10:44.000Z","updated":"2020-05-20T02:58:00.024Z","comments":true,"path":"p/e15d38f8/","link":"","permalink":"https://ticsmatic.com/p/e15d38f8/","excerpt":"学习MJ的视频课程，整理总结知识点–Category的本质","text":"学习MJ的视频课程，整理总结知识点–Category的本质[TOC]Category基本使用category 是对装饰模式的一种具体实现。它的主要作用是在不改变原有类的前提下，动态地给这个类添加一些方法。category 还可以对类进行模块拆解，甚至模拟多继承等操作。具体可参考官方文档CategoryCategory底层结构我们知道category的基本用法，前面我们也已经知道了NSObject、class的底层结构，及调用机制。那么category的结构是什么样的，OC是通过怎样的机制来实现category？想知道category的底层结构(基于经验，完全可以大胆的推测它是结构体)，结合前面的经验，我们可以去两个地方查线索。用clang重写category的编译文件来查看项目中的源码阅读objc-runtime-new.h开源的源码，搜索category关键字进行查看这里通过Demo，用clang重写category的编译文件，分析重写后生成的cpp文件，来探索category的底层结构。创建MJPerson.h、MJPerson.m，创建MJPerson+Test.h、MJPerson+Test.m，然后通过class重写MJPerson+Test.m文件，生成为C++文件，如下：1clang -rewrite-objc MJPerson+Test.m -o MJPerson+Test.cpp打开MJPerson+Test.cpp文件，我们看到如下代码，简单阅读一下，这个看起来就是我们要找到的MJPerson+Test.m重写后的另一种表达样式。123456789static struct _category_t _OBJC_$_CATEGORY_MJPerson_$_Test __attribute__ ((used, section (\"__DATA,__objc_const\"))) = &#123; \"MJPerson\", 0, // &amp;OBJC_CLASS_$_MJPerson, (const struct _method_list_t *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_MJPerson_$_Test, (const struct _method_list_t *)&amp;_OBJC_$_CATEGORY_CLASS_METHODS_MJPerson_$_Test, 0, 0,&#125;;我们还可以找到_CATEGORY_INSTANCE_METHODS_MJPerson_，_CATEGORY_CLASS_METHODS_MJPerson_的具体实现结构。12345678910static struct /*_method_list_t*/ &#123; unsigned int entsize; // sizeof(struct _objc_method) unsigned int method_count; struct _objc_method method_list[2];&#125; _OBJC_$_CATEGORY_INSTANCE_METHODS_MJPerson_$_Test __attribute__ ((used, section (\"__DATA,__objc_const\"))) = &#123; sizeof(_objc_method), 2, &#123;&#123;(struct objc_selector *)\"run\", \"v16@0:8\", (void *)_I_MJPerson_Test_run&#125;, &#123;(struct objc_selector *)\"test\", \"v16@0:8\", (void *)_I_MJPerson_Test_test&#125;&#125;&#125;;同时，我们还能在MJPerson+Test.cpp文件中找打如下代码：12345678struct _category_t &#123; const char *name; struct _class_t *cls; const struct _method_list_t *instance_methods; const struct _method_list_t *class_methods; const struct _protocol_list_t *protocols; const struct _prop_list_t *properties;&#125;;看起来很像category结构体的标准格式。name注意，并不是category小括号里写的名字，而是类的名字cls要扩展的类对象，编译期间这个值是不会有的，在app被runtime加载时才会根据name对应到类对象instance_methods这个category所有的-方法class_methods这个category所有的+方法protocols这个category实现的protocol，比较不常用在category里面实现协议，但是确实支持的properties这个category所有的property，这也是category里面可以定义属性的原因，不过这个property不会@synthesize实例变量，一般有需求添加实例变量属性时会采用objc_setAssociatedObject和objc_getAssociatedObject方法绑定方法绑定，不过这种方法生成的与一个普通的实例变量完全是两码事。上面这些是我们利用编译器重写OC代码生成的C++源码，同时我们还可以在apple开源的objc中找到category的源码，在objc-runtime-new.h文件中看到定义的源码如下：1234567891011121314151617struct category_t &#123; const char *name; classref_t cls; struct method_list_t *instanceMethods; struct method_list_t *classMethods; struct protocol_list_t *protocols; struct property_list_t *instanceProperties; // Fields below this point are not always present on disk. struct property_list_t *_classProperties; method_list_t *methodsForMeta(bool isMeta) &#123; if (isMeta) return classMethods; else return instanceMethods; &#125; property_list_t *propertiesForMeta(bool isMeta, struct header_info *hi);&#125;;Category底层结构部分Demo的下载地址Category源码分析通过解读category的源码，我们知道category的底层结构长这个样子1234567891011121314151617struct category_t &#123; const char *name; classref_t cls; struct method_list_t *instanceMethods; struct method_list_t *classMethods; struct protocol_list_t *protocols; struct property_list_t *instanceProperties; // Fields below this point are not always present on disk. struct property_list_t *_classProperties; method_list_t *methodsForMeta(bool isMeta) &#123; if (isMeta) return classMethods; else return instanceMethods; &#125; property_list_t *propertiesForMeta(bool isMeta, struct header_info *hi);&#125;;我们知道OC中所有的方法调用都会转成runtime的objc_msgSend，这个函数需要两个参数id, SEL，函数通过这个id参数查找对象的isa指针，通过isa找到class的方法列表，在方法列表中匹配SEL进行调用。但是在之前的class源码解读中(struct objc_class : objc_object {...})，我们已经知道，实例方法信息都是存储在class的方法列表中(struct objc_class -&gt; class_rw_t* data() -&gt; method_array_t methods，注：在不同的objc源码版本中可能会有细微差异)那么category里的方法信息存储在哪里？是否就在本来的category_t中？ 程序运行时如何调用到category里面的信息？实际上，category的信息最终也会合并到class中，且在runtime加载完成后，category的原始信息在类结构里将不会存在。我们先通过打印class的方法列表1234567// 打印class的方法列表，发现category中的方法也会被打印出来，看起来分类的方法似乎存在于Class中了unsigned int outCount;Method *methodlist = class_copyMethodList([MJPerson class], &amp;outCount);for (NSInteger i = 0; i &lt; outCount; i++) &#123; Method method = methodlist[i]; NSLog(@\"%@\", NSStringFromSelector(method_getName(method)));&#125;发现Class的方法列表中包含了category的方法，可以说明category的信息会添加到class中。下面我们通过runtime的加载入口为切入点，来解读category的信息是如何添加到到class中。这需要探究下runtime对category的加载过程，这里就简单说一下objc runtime的加载入口是一个叫_objc_init的方法，在library加载前由libSystem dyld调用，进行初始化操作调用map_images方法将文件中的imagemap到内存调用_read_images方法初始化map后的image，这是一个很重要的函数。这里面干了很多的事情，像load所有的类、协议和category，著名的+ load方法就是这一步调用的仔细看category的初始化，调用了_getObjc2CategoryList方法获取所有的categoriescategory_t **catlist = _getObjc2CategoryList(hi, &amp;count);，接下来runtime终于开始了category的处理，简化的代码如下1234567891011121314151617181920// Process this category. // First, register the category with its target class. // Then, rebuild the class's method lists (etc) if // the class is realized. bool classExists = NO;if (cat-&gt;instanceMethods || cat-&gt;protocols || cat-&gt;instanceProperties) &#123; addUnattachedCategoryForClass(cat, cls, hi); if (cls-&gt;isRealized()) &#123; remethodizeClass(cls); classExists = YES; &#125;if (cat-&gt;classMethods || cat-&gt;protocols || (hasClassProperties &amp;&amp; cat-&gt;_classProperties)) &#123; addUnattachedCategoryForClass(cat, cls-&gt;ISA(), hi); if (cls-&gt;ISA()-&gt;isRealized()) &#123; remethodizeClass(cls-&gt;ISA()); &#125;&#125;首先分成两拨，一拨是实例对象相关的调用addUnattachedCategoryForClass，一拨是类对象相关的调用addUnattachedCategoryForClass，判断每一拨里面是否实现有方法、协议、属性，有的话就remethodizeClass重新组织class信息结构。在remethodizeClass函数中有一个重要方法attachCategories。attachCategories(cls, cats, true);将分类列表cats的附加到类cls。接下来讲解attachCategories函数，不粘贴大片的代码，我用注释说明主要做的事情，需要的可以去看源码如下：12345678910// Attach method lists and properties and protocols from categories to a class.// Assumes the categories in cats are all loaded and sorted by load order, // oldest categories first.static void attachCategories(Class cls, category_list *cats, bool flush_caches)&#123;// 1. 分配方法数组、属性数组、协议数组空间// 2. 遍历分类数组cats，取出方法、属性、协议并添加到对应的数组中// 3. 拿到cls的信息表auto rw = cls-&gt;data(); 往cls里面添加categories的方法数组、属性数组、协议数组，最后把数组空间释放。&#125;在上面的第3步(rw-&gt;methods.attachLists(mlists, mcount))，往cls里面添加数组数据的时候，我们讲解一下个重要方法attachLists.123456789101112131415void attachLists(List* const * addedLists, uint32_t addedCount) &#123; if (addedCount == 0) return; if (hasArray()) &#123; // many lists -&gt; many lists uint32_t oldCount = array()-&gt;count; uint32_t newCount = oldCount + addedCount; // 计算新数组个数后重新分配空间 setArray((array_t *)realloc(array(), array_t::byteSize(newCount))); array()-&gt;count = newCount; // cls自身的数组部分移动到新数组0位置 memmove(array()-&gt;lists + addedCount, array()-&gt;lists, oldCount * sizeof(array()-&gt;lists[0])); // 增加的部分copy到新数组0位置 memcpy(array()-&gt;lists, addedLists, addedCount * sizeof(array()-&gt;lists[0])); &#125;attachLists流程有3个关键的地方，realloc、memmove、memcpy，有一个非常重要的地方，就是memcpy，在categories加载的过程中就是把categories的信息(方法、属性、协议)添加到新数组的其实位置。因为runtime的方法调用机制就是找到对应的方法后方法查找流程就结束，然后进行方法调用。正是因为每次categories的信息都是添加到cls的方法数组的最前面，所以遇到category和class方法同名时，优先调用的是category的方法。学习了categories的加载机制，我们还可以解释另外一个问题，就是同一个class的多个category，每个category都有同样方法，则最后参与编译的分类方法优先调用。因为在attachCategories过程中，有这样一段代码1234567891011121314// 创建用于存储同一个class的所有category方法的数组method_list_t **mlists = (method_list_t **)malloc(cats-&gt;count * sizeof(*mlists)); while (i--) &#123; auto&amp; entry = cats-&gt;list[i]; method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta); if (mlist) &#123; // 向数组中添加方法 mlists[mcount++] = mlist; fromBundle |= entry.hi-&gt;isBundle(); &#125; // ...&#125;因为是i--的while循环，所以最后加载的category会添加到数组的最前端。这样runtime在方法查找的时候，会优先查找到最前面的方法，也就意味着最后参与编译的分类方法优先调用。总结Category编译之后的底层结构是struct category_t，里面存储着分类的对象方法、类方法、属性、协议信息在程序运行的时候，runtime会将Category的数据，合并到类信息中（类对象、元类对象中）category信息添加到class时有几个重要的函数_objc_init // runtime的加载入口map_images // 将文件中的imagemap到内存_read_images // 重要：初始化map后的image_getObjc2CategoryList // 获取所有的categoriesremethodizeClass // 为了添加category重修ClassattachCategories // 添加categories到ClassattachLists // Class的结构体重新分配大小，把category中的信息添加的最前面参考和源码参考：objc category的秘密Demo源码：Category的底层结构-Demo.zip","categories":[],"tags":[]},{"title":"KVC的本质","slug":"day05-KVC的本质","date":"2020-04-30T03:45:03.000Z","updated":"2020-05-22T01:36:45.003Z","comments":true,"path":"p/6fefa1e2/","link":"","permalink":"https://ticsmatic.com/p/6fefa1e2/","excerpt":"学习MJ的视频课程，整理并记录知识点–KVC的本质","text":"学习MJ的视频课程，整理并记录知识点–KVC的本质[TOC]KVC的全称是Key-Value Coding，俗称“键值编码”，可以通过一个key来访问某个属性常见的API有1234- (void)setValue:(id)value forKeyPath:(NSString *)keyPath;- (void)setValue:(id)value forKey:(NSString *)key;- (id)valueForKeyPath:(NSString *)keyPath;- (id)valueForKey:(NSString *)key;基本使用设值1、我们可以通过-setValue:forKey:，或者-setValue:forKeyPath:给对象的属性赋值，也可以直接调用对象的属性赋值，如下三个方法的效果等价。123person.age = 10;[person setValue:@10 forKey:@\"age\"];[person setValue:@10 forKeyPath:@\"age\"];-setValue:forKey:、-setValue:forKeyPath:这两个方法的调用结果一样，函数名很相似，它们两个的区别是什么？我们先看它的API文档DiscussionThe default implementation of this method gets the destination object for each relationship using valueForKey:, and sends the final object a setValue:forKey: message.可以概述如下：-setValue:forKeyPath:支持路径方式的参数（[person setValue:@10 forKeyPath:@&quot;cat.weight&quot;];），它会新利用路径查找到指定的层级，内部最终是会调用-setValue:forKey:2、KVC的另一种使用场景就是我么利用它进行对象的私有属性赋值。1[searchField setValue:[UIColor whiteColor] forKeyPath:@\"_placeholderLabel.textColor\"];但是在iOS13以后，系统对象通过KVC设置私有属性已被禁止。取值相对应的取值方式为-valueForKey:、-valueForKeyPath:，使用很简单123person.age;[person valueForKey:@\"age\"];[person valueForKeyPath:@\"age\"];-setValue:forKey:的原理-setValue:forKey:是Foundation的函数，我们看不到源码，不过这个API的接口文档很详细。-setValue:forKey:同时，在Foundation的头文件中，函数的描述如下：1234567891011121314/* Given a value and a key that identifies an attribute, set the value of the attribute. Given an object and a key that identifies a to-one relationship, relate the object to the receiver, unrelating the previously related object if there was one. Given a collection object and a key that identifies a to-many relationship, relate the objects contained in the collection to the receiver, unrelating previously related objects if there were any.The default implementation of this method does the following: 1. Searches the class of the receiver for an accessor method whose name matches the pattern -set&lt;Key&gt;:. If such a method is found the type of its parameter is checked. If the parameter type is not an object pointer type but the value is nil -setNilValueForKey: is invoked. The default implementation of -setNilValueForKey: raises an NSInvalidArgumentException, but you can override it in your application. Otherwise, if the type of the method's parameter is an object pointer type the method is simply invoked with the value as the argument. If the type of the method's parameter is some other type the inverse of the NSNumber/NSValue conversion done by -valueForKey: is performed before the method is invoked. 2. Otherwise (no accessor method is found), if the receiver's class' +accessInstanceVariablesDirectly property returns YES, searches the class of the receiver for an instance variable whose name matches the pattern _&lt;key&gt;, _is&lt;Key&gt;, &lt;key&gt;, or is&lt;Key&gt;, in that order. If such an instance variable is found and its type is an object pointer type the value is retained and the result is set in the instance variable, after the instance variable's old value is first released. If the instance variable's type is some other type its value is set after the same sort of conversion from NSNumber or NSValue as in step 1. 3. Otherwise (no accessor method or instance variable is found), invokes -setValue:forUndefinedKey:. The default implementation of -setValue:forUndefinedKey: raises an NSUndefinedKeyException, but you can override it in your application.Compatibility notes: - For backward binary compatibility with -takeValue:forKey:'s behavior, a method whose name matches the pattern -_set&lt;Key&gt;: is also recognized in step 1. KVC accessor methods whose names start with underscores were deprecated as of Mac OS 10.3 though. - For backward binary compatibility, -unableToSetNilForKey: will be invoked instead of -setNilValueForKey: in step 1, if the implementation of -unableToSetNilForKey: in the receiver's class is not NSObject's. - The behavior described in step 2 is different from -takeValue:forKey:'s, in which the instance variable search order is &lt;key&gt;, _&lt;key&gt;. - For backward binary compatibility with -takeValue:forKey:'s behavior, -handleTakeValue:forUnboundKey: will be invoked instead of -setValue:forUndefinedKey: in step 3, if the implementation of -handleTakeValue:forUnboundKey: in the receiver's class is not NSObject's.*/- (void)setValue:(nullable id)value forKey:(NSString *)key;我们可以结合文档，整理出-setValue:forKey:内部的主要逻辑如下：KVC底层调用willChangeValueForKey:、didChangeValueForKey:-valueForKey:的原理-valueForKey:函数核心原理和-setValue:forKey:很类似，一个是设置值，一个是取值。它的原理如下：KVC触发KVO的observerKVC是键值编码、KVO的键值监听，从定义的描述可推测两者之前似乎有关联。他们关联也就是键值，一个是设置修改键值、一个是监听键值的修改。那么通过KVC修改属性会触发KVO么？答案是：会12345// 添加KVO监听[person addObserver:observer forKeyPath:@\"age\" options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:NULL];// 通过KVC修改age属性[person setValue:@10 forKeyPath:@\"age\"];我们在KVO的那一章中介绍过，触发KVO的关键代码是-willChangeValueForKey:，-didChangeValueForKey:，123[self.person1 willChangeValueForKey:@\"age\"];self.person1-&gt;_age = 10;[self.person1 didChangeValueForKey:@\"age\"];我们可以在person的class中实现-willChangeValueForKey:，-didChangeValueForKey:，进行调试，结论是，通过KVC设置属性会调用这两个方法，也就会触发KVO总结知道KVC的调用顺序通过KVC设置属性会触发KVO源码和参考apple document：setvalue","categories":[],"tags":[]},{"title":"KVO的实现原理","slug":"day04-KVO的实现原理","date":"2020-04-27T03:45:03.000Z","updated":"2020-05-20T02:56:48.222Z","comments":true,"path":"p/4dec9c48/","link":"","permalink":"https://ticsmatic.com/p/4dec9c48/","excerpt":"学习MJ的视频课程，整理并记录知识点–KVO的实现原理","text":"学习MJ的视频课程，整理并记录知识点–KVO的实现原理[TOC]KVO的全称是Key-Value Observing，俗称“键值监听”，可以用于监听某个对象属性值的改变。KVO的使用先回忆下，关于KVO的使用，通常的代码类似如下：12345678910111213141516// 1. Add KVONSKeyValueObservingOptions options = NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld; [self.person1 addObserver:self forKeyPath:@\"age\" options:options context:@\"123\"]; // 2. Trigger self.person1.age = 18;// 3. Observing - (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey, id&gt; *)change context:(void *)context &#123; NSLog(@\"监听到%@的%@属性值改变了 - %@ - %@\", object, keyPath, change, context);&#125;// Remove observe- (void)dealloc &#123; [self.person1 removeObserver:self forKeyPath:@\"age\"];&#125;KVO本质分析我们通过一个对照组来逐步分析KVO的本质实现，如下12// 创建另一个实例对象，设置同样的属性self.person2.age = 20;person1和person2都会调用setAge:方法，但不添加监听的person2是不会触发KVO的方法的，这两个对象有什么区别呢？我们分析下这两个对象，根据前面的学习，我们知道，instance对象只存变量，方法存储在class对象中，我们可以尝试打印person1和person2的isa12345(lldb) p self.person1-&gt;isa(Class) $0 &#x3D; NSKVONotifying_MJPerson(lldb) p self.person2-&gt;isa(Class) $0 &#x3D; MJPerson两者的isa指向不一样，从哪里出来一个NSKVONotifying_MJPerson类。我们知道实例对象的isa是指指向class的，但是person1的class却成了NSKVONotifying_MJPerson，这个NSKVONotifying_MJPerson的产生必然与添加observer有关，那么它的superclass是谁？我们打印会发现NSKVONotifying_MJPerson的superclass是MJPerson。原来在给person1添加observer时，会动态创建一个叫NSKVONotifying_MJPerson的子类，然后person1的isa会指向这个新创建的子类。KVO本质分析验证person1的isa指向NSKVONotifying_MJPerson，当调用setAge:方法时，肯定是去NSKVONotifying_MJPerson中找，而setAge:是触发监听者的关键，那么动态创建的这个子类的setAge:方法肯定和之前的不一样。我们尝试打印这个动态类的方法列表：1234567891011// 在添加observer后，利用runtime打印person1的方法列表unsigned int outCount2;Method *methodList2 = class_copyMethodList(object_getClass(self.person1), &amp;outCount2);NSMutableString *methodNames = [NSMutableString string];for (NSInteger i = 0; i &lt; outCount2; i++) &#123; Method method = methodList2[i]; [methodNames appendFormat:@\"%@&#123; %p &#125;, \", NSStringFromSelector(method_getName(method)), (IMP)method_getImplementation(method)];&#125;// ... setAge:, class, dealloc, _isKVOANSLog(@\"%@\", methodNames);我们发现这个动态生成的class里面同样有setAge:方法，另外多了class, dealloc, _isKVOA这几个方法。同时我们获取了每个方法的实现(IMP指针)，这样我们就可以通过LLDB查看IMP指针指向的内存了，作为对照组，我们先查看未添加observer的person2对象如下所示：123456(lldb) p methodNames(__NSCFString *) $0 &#x3D; 0x0000600001e7e220 @&quot;setAge:&#123; 0x101e13720 &#125;, age&#123; 0x101e13700 &#125;, &quot;(lldb) p (IMP)0x101e13720(IMP) $1 &#x3D; 0x0000000101e13720 (Interview01&#96;-[MJPerson setAge:] at MJPerson.h:12)(lldb) p (IMP)0x101e13700(IMP) $2 &#x3D; 0x0000000101e13700 (Interview01&#96;-[MJPerson age] at MJPerson.h:12)我们可以看到未添加observer的对象的setAge:的实现，是位于Interview01(二进制文件)下的MJPerson类。我们对添加了observer的对象进行信息打印，如下：1234(lldb) p methodNames(__NSCFString *) $2 &#x3D; 0x0000600002143ed0 @&quot;setAge:&#123; 0x1040ebcf2 &#125;, class&#123; 0x1040ea06e &#125;, dealloc&#123; 0x1040e9e12 &#125;, _isKVOA&#123; 0x1040e9e0a &#125;, &quot;(lldb) p (IMP)0x1040ebcf2(IMP) $3 &#x3D; 0x00000001040ebcf2 (Foundation&#96;_NSSetIntValueAndNotify)我们看到setAge:方法的实现是调用了Foundation框架里面的_NSSetIntValueAndNotify方法。说明setAge:方法的实现已经不一样了，由于苹果的Foundation框架是不开源的，我们无法查看_NSSetIntValueAndNotify函数的内部实现，不过我们结合已知的信息，查资料，可以得出_NSSetIntValueAndNotify的内部实现为下伪代码1234567891011121314// 伪代码void _NSSetIntValueAndNotify()&#123; [self willChangeValueForKey:@\"age\"]; [super setAge:age]; [self didChangeValueForKey:@\"age\"];&#125;// 伪代码- (void)didChangeValueForKey:(NSString *)key&#123; // 通知监听器，某某属性值发生了改变 [observer observeValueForKeyPath:key ofObject:self change:nil context:nil];&#125;窥探Foundation如何验证Foundation下面确实有_NSSetIntValueAndNotify方法？我们平时使用Foundation.framework都是已经编译后的二进制文件，不过我们可以利用反编译工具hopper来查看Foundation里面的方法名和汇编代码（想拿到Foundation二进制文件我们通过已越狱的手机获取或者去网上搜索，hopper工具的使用这里不作介绍）。除了Hopper，在mac上，我们还可以系统给提供的工具nm(OVERVIEW: llvm symbol table dumper)命令来导出函数符号表:1nm Foundation | grep ValueAndNotify我们可以确定，Foundation里面确实有_NSSet...ValueAndNotify方法。子类的内部方法除了setAge:, 子类还有这几个方法class、dealloc、_isKVOA我们知道NSObject中是有class方法的，是通过object_getClass()方法获取的，这个子类重写class方法，是为了返回MJPerson这个类，也就是它原本的class，这么做是为了隐藏这个类的存在，让开发者无感，避免歧义。子类的dealloc方法是为了做监听的收尾工作结合上面的知识我们可以得出这个子类的内存结构图总结当添加observer时，runtime会动态创建一个子类，重写被监听属性的set方法。KVO一定会调用willChangeValueForKey:、didChangeValueForKey:方法思路：分析两个对象，发现isa不一样，通过isa找到class，通过class找到方法列表以及_NSSetIntValueAndNotify方法，分析_NSSetIntValueAndNotify方法。引出willChangeValueForKey:、didChangeValueForKey:面试题1、iOS用什么方式实现对一个对象的KVO?(KVO的本质是什么)利用RuntimeAPI动态生成一个子类, 并且让instance对象的isa指向这个全新的子类当修改instance对象的属性时, 会调用Fundation的_NSSet*ValueAndNotify函数willChangeValueForKey:父类原来的setter方法didChangeValueForKey:内部会触发监听器Observer的监听方法(observeValueForKeyPath:ofObject:change:context:)2、如果直接修改对象的成员变量, 是否会触发监听器的(observeValueForKeyPath:ofObject:change:context:)方法?直接修改对象的成员变量, 而不调用set方法, 将不会触发观察者的observeValueForKeyPath:ofObject:change:context:方法3、如何手动触发KVO?已知实例对象被观察的属性, 在调用set方法进行修改时, 会触发_NSSet*ValueAndNotify函数并触发willChangeValueForKey:和didChangeValueForKey:这两个方法, 所以我们可以手动添加这两个方法, 来触发KVO现在已知直接修改成员变量时, 不会触发KVO, 那么就在修改成员变量的前后添加这两个方法123[self.person1 willChangeValueForKey:@\"age\"];self.person1-&gt;_age = 21;[self.person1 didChangeValueForKey:@\"age\"];注意:willChangeValueForKey:和didChangeValueForKey:, 两个方法必须同时出现, 如果只有一个, 将不会触发KVO源码和参考Demo源码：KVO-Demo.zip","categories":[],"tags":[]},{"title":"isa和superclass","slug":"day03-isa和superclass","date":"2020-04-26T12:47:47.000Z","updated":"2020-05-20T02:50:00.217Z","comments":true,"path":"p/ffcce99c/","link":"","permalink":"https://ticsmatic.com/p/ffcce99c/","excerpt":"学习MJ的视频课程，整理并记录知识点–isa和superclass","text":"学习MJ的视频课程，整理并记录知识点–isa和superclass[TOC]结合之前的文章，我们已经知道objc中的对象是如下的内存结构如下：这里我们探究isa指针和superclass指针的作用。对象的isa指针提出问题：对象的isa指针指向哪里？分析：我们知道实例对象只保存成员变量信息，它对应的对象方法信息是保存在实例对应的类(class)对象中(因为同一个类的生成的实例默认的对象方法肯定一样，因为系统不会不优雅的为每个实例对象都开辟空间保存同样的方法信息)。那么我们用实例对象调方法时，肯定要知道这个方法的信息，这些信息存储位置必然和类有关，所以实例对象必然能找到它对应的类，我们结合OC对象的本质一节，已经得知，一个没有任何变量的实例对象都有isa指针，做排除法也可得知，实例对象的isa指针指向它的类(class)对象。同理，类(class)对象的方法信息是存储在它的元类(meta-class)中；类(class)对象的isa指针必然指向它的元类(meta-class)对象。这三种对象之间是通过isa指针联系起来的instance的isa指向class，当调用对象方法时，通过instance的isa找到class，最后找到对象方法的实现进行调用class的isa指向meta-class，当调用类方法时，通过class的isa找到meta-class，最后找到类方法的实现进行调用class的superclass指针superclass我们知道它是指向父类对象(super class)，这里不再啰嗦，可以看下图meta-class的superclass指针meta-class 主要存放的是class的类方法，meta-class之间也是有对应的superclass指针的，这里不再啰嗦，可以看下图isa、superclass总结附上一张比较比较有名的来总结isa、superclass指针，如下有两个地方需要注意：meta-class的isa指向基类的meta-class基类的meta-class的superclass指针，指向基类的class总结：isa和superclass是重要的两根线，来联通 instance、class、meta-class关于方法的调用顺序我们知道，无论是实例对象还是类对象，都是先在当前类找看是否有和这个方法的实现，没有的话回去父类找，直到找到或者抛出异常。下面我们举class方法的调用例子，来加深理解，源码在这里下载主要代码如下：123456789101112131415161718192021222324252627282930@interface MJPerson : NSObject+ (void)test;@end@implementation MJPerson@end@interface NSObject (Text)@end@implementation NSObject (Test)//+ (void)test &#123;// NSLog(@\"+[NSObject test] - %p\", self);//&#125;- (void)test &#123; NSLog(@\"-[NSObject test] - %p\", self);&#125;@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; // 调用一个没有实现的类方法，结果会怎样？ [MJPerson test]; &#125; return 0;&#125;演示中，我们使用MJPerson调用类方法test，但是test方法是没有实现的，只有基类实现了一个对象方法。调用结果会崩溃吗？答案是程序不会崩溃，类可以调用到对象方法，看起来似乎有点让人震惊。我们分析一下调用流程来解释为什么会是这样：首先是类对象调用方法，类对象的方法信息放在元类里面，MJPerson会去自己的元类对象找，没有找到(因为已经被注释了)。继续去父类的元类对象找(NSObject的元类)，也没找到。但是，因为NSObject的元类还有superclass，就是NSObject，所以会继续去NSObject中找test方法的实现，找到了，然后调用这个方法，调用流程结束。流程如下：Demo下载meta-class底层机构和class是一致，都是class，不要被方法的符号迷惑（+、-），objc消息机制只要求对象、方法名，实例方法、类方法没有本质却别。只会依据调用规则通过isa和superclass指针来查找，流程简述如下isa -&gt; superclass -&gt; suerpclass -&gt; superclass -&gt; .... superclass == nil和Java不一样，OC不是严格的面向对象，是对C语言的扩展，增加消息机制。isa指针窥探前面我们知道instance对象的isa指向类对象，这里通过查看内存进行验证。我们通过断点debug能找到一个对象的变量信息，但是isa变量的信息我们却看不到，此时，我们可以利用前面学习的LLDB调试指令，打印内存地址p/x (long)instance-&gt;isa，当这个打印结果和class对象的地址一直，即可验证instance对象的isa指向类对象。但实际上的打印结果发现却发现两者不一致，因为苹果规定从64bit开始，isa需要和ISA_MASK进行一次与运算，才能计算出真实地址。那么class对象的isa是不是也需要进行一次ISA_MASK的与运算，我们来验证一下。通过p/x (long)class对象-&gt;isa报错，提示member reference base type &#39;Class&#39; is not a structure or union，我们只能先把class转成struct。根据class的结构类型，定义MJPerson对应的结构体，如下：1234struct mj_objc_class &#123; Class isa; Class superclass;&#125;;在使用时，直接将class桥接转成对应的结构体1struct mj_objc_class *personClass = (__bridge struct mj_objc_class *)([MJPerson class]);此时我们就能打印结构体的isa指针了。我们打印指针地址，与上ISA_MASK后得到的地址确实为MJPerson的meta-class地址。总结如下图：class和meta-class的结构本小节窥探class、meta-class内存的结构，来证明我们之前推测的class的struct结构模型。想了解class的结构细节，我们还是需要去看objc的源码，在objc-runtime-new.h文件中，我们能看到objc_class大致结构如下：思路：我们可以自己创建一个class，然后仿照objc_class的定义，构建类似的结构体，然后把class桥接转换成结构体，如果结构体内有对应的值，说明假设成立。这里我就不粘贴代码了，这里已经通过真实的Demo进行测试，可以下载进行演示和验证Demo下载源码和参考objc-private.hobjc-runtime-new.hDemo源码：Interview02-isa和superclass.zipInterview03-isa.zipInterview04-class的结构.zip","categories":[],"tags":[]},{"title":"OC对象的分类","slug":"day02-OC对象的分类","date":"2020-04-26T08:49:04.000Z","updated":"2020-05-07T10:34:34.000Z","comments":true,"path":"p/5a039b46/","link":"","permalink":"https://ticsmatic.com/p/5a039b46/","excerpt":"学习MJ的视频课程，整理总结知识点–Objective-C中的对象","text":"学习MJ的视频课程，整理总结知识点–Objective-C中的对象[TOC]Objective-C中的对象，简称OC对象，主要分为3种instance对象（实例对象）class对象（类对象）meta-class对象（元类对象）1. instance对象instance对象是通过类alloc出来的对象，每次调用alloc都会产生新的instance对象。实例对象主要存储的是成员变量的具体值。12NSObject *object1 = [[NSObject alloc] init];NSObject *object2 = [[NSObject alloc] init];object1、object2是NSObject的instance对象（实例对象）它们是不同的两个对象，分别占据着两块不同的内存。instance对象在内存中存储的信息包括:isa指针其他成员变量即：实例对象的地址是isa指针的地址，isa指针所在的内存空间后面紧跟着的是其它成员变量所占的内存空间。2. class对象类对象主要存储的这个类的信息12345Class objectClass1 = [object1 class];Class objectClass2 = [object2 class];Class objectClass3 = object_getClass(object1);Class objectClass4 = object_getClass(object2);Class objectClass5 = [NSObject class];objectClass1 ~ objectClass5都是NSObject的class对象（类对象），它们是同一个对象，每个类在内存中有且只有一个class对象class对象在内存中存储的信息主要包括：isa指针superclass指针类的属性信息（@property）类的对象方法信息（instance method）类的协议信息（protocol）类的成员变量信息（ivar）3. meta-class 元类对象12&#x2F;&#x2F; 将类对象当做参数传入，获得元类对象Class objectMetaClass &#x3D; object_getClass(objectClass5);objectMetaClass是NSObject的meta-class对象（元类对象）每个类在内存中有且只有一个meta-class对象meta-class对象和class对象的内存结构是一样的，但是用途不一样，在内存中存储的信息主要包括isa指针superclass指针类的类方法信息（class method）……12// 判断是否为元类对象 runtime apiBOOL result = class_isMetaClass(objectClass3);其它：objc_getClass, object_getClass函数源码位于苹果开源的objc项目，相关部分如下12345678910111213/************************************************************************ objc_getClass. Return the id of the named class. If the class does* not exist, call _objc_classLoader and then objc_classHandler, either of * which may create a new class.* Warning: doesn't work if aClassName is the name of a posed-for class's isa!**********************************************************************/Class objc_getClass(const char *aClassName)&#123; if (!aClassName) return Nil; // NO unconnected, YES class handler return look_up_class(aClassName, NO, YES);&#125;传入字符串类名，去查找对应的类对象123456789101112/************************************************************************ object_getClass.* Locking: None. If you add locking, tell gdb (rdar://7516456).**********************************************************************/Class object_getClass(id obj)&#123; // 如果是instance对象，返回class对象 // 如果是class对象，返回meta-class对象 // 如果是meta-class对象，返回基类(NSObject)的meta-class对象 if (obj) return obj-&gt;getIsa(); else return Nil;&#125;object_getClass参数对象的isa指针，查找到它类、元类对象objc_getClass根据参数的字符，去匹配对应的class总结Objective-C中的对象，简称OC对象，主要分为3种instance对象（实例对象）class对象（类对象）meta-class对象（元类对象）他们的在内存中存储的信息大致如下：参考和源码Apple Source Browser - objc","categories":[],"tags":[]},{"title":"OC对象的本质","slug":"day01-OC对象的本质","date":"2020-04-24T14:50:29.000Z","updated":"2020-06-01T02:30:09.160Z","comments":true,"path":"p/74ed6556/","link":"","permalink":"https://ticsmatic.com/p/74ed6556/","excerpt":"学习MJ的视频课程，整理总结知识点–OC对象的本质","text":"学习MJ的视频课程，整理总结知识点–OC对象的本质[TOC]Objective-C是一种通用、高级、面向对象的编程语言。它扩展了标准的ANSI C编程语言，将Smalltalk式的消息传递机制加入到ANSI C中。当前主要支持的编译器有GCC和Clang（采用LLVM作为后端）维基：Objective-CObjective-C和C_C++想探究OC对象的本质，我们可以逐步深入。我们知道，最了解一个编程语言的，莫过于它的编译器了，而我们知道Xcode内置的编译器的前端是clang，clang是一个C、C++、Object-C的轻量级编译器。Objective-C兼容C语言，我们可以通过clang编译器将Objective-C代码重写成更基础的C/C++代码，这样就能看到Object-C在C/C++下的等价实现。但是使用Xcode构建ObjC项目时并不会先将Objective-C代码翻译为C++，这是因为clang编译器支持直接编译Objective-C代码。(本文为了书写方便，将Object-C简写为OC)Objective-C对象数据结构我们知道OC是基于C语言扩展出来的，C是没有对象的概念，那么OC的对象是基于什么结构实现的呢？或许我们曾经通过Xcode看过objc.h的头文件，发现如下代码1234/// Represents an instance of a class.struct objc_object &#123; Class _Nonnull isa OBJC_ISA_AVAILABILITY;&#125;;同时我们知道，结构体里面可以存放不同类型的数据。我们或许猜测到NSObject的底层结构是基于结构体。事实上OC对象确实是基于结构体的实现，下面我们通过重写源码进行验证。我们以简单main.m函数代码为例，新建一个如下图所示的工程，然后通过clang命令把main函数及内部的NSObject重写为C++的实现，即可了解objc对象的实现。123456int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; NSObject *obj = [[NSObject alloc] init]; &#125; return 0;&#125;终端切换到main.m所在的目录，然后执行clang命令，如下：(关于命令的使用我们可以通过clang --help来了解)1clang -rewrite-objc main.m -o main.cpp打开main.cpp文件，如下图，我们在最后看到main.m函数的实现，同时还可以一窥OC的消息机制123456int main(int argc, const char * argv[]) &#123; /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; NSObject *obj = ((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"NSObject\"), sel_registerName(\"alloc\")), sel_registerName(\"init\")); &#125;return 0;&#125;同时，我们在main.cpp可以看到这样的一段代码1234// NSObject_IMPL (NSObject_IMPLEMENTATION)struct NSObject_IMPL &#123; Class isa;&#125;;即说明了NSObject对象是通过结构体实现的，且内部只有一个Class(结构体)指针。NSObject的内存本质通过上面的内容，我们已经知道NSObject对象的底层实现是结构体，且内部只有一个isa结构体指针，这个指针指向Class的起始地址。class_getInstanceSize、malloc_size知道了NSObject的内存结构后，接下来我们探讨一个NSObject对象占用多少内存？思路：通过上面的小节，我们已经知道NSObject对象内部只有一个isa结构体指针，我们知道在64位中操作系统中，指针占用内存空间是8个字节，所以我们推测一个NSObject对象应该只占8个字节，事实是否如此？我们可以利用系统提供的malloc_size函数进行验证。通过系统提供的函数即可获得，如下：12345678910111213int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; NSObject *obj = [[NSObject alloc] init]; // 获得NSObject实例对象的成员变量所占用的大小 &gt;&gt; 8 NSLog(@\"%zd\", class_getInstanceSize([NSObject class])); // 获得obj指针所指向内存的大小 &gt;&gt; 16 NSLog(@\"%zd\", malloc_size((__bridge const void *)obj)); &#125; return 0;&#125;更进一步，我们可以研究class_getInstanceSize、malloc_size这两个函数的实现，因为苹果已经开源了objc，我们可以查找相应的实现代码从而做到知其所以然。苹果的源码开放地址为：Source Browser，如果想研究苹果的源码一般都是访问这个地址。我们下载objc4的最新源码，然后解压打开源码。搜索我们要找的源码class_getInstanceSize，结果如下：12345size_t class_getInstanceSize(Class cls)&#123; if (!cls) return 0; return cls-&gt;alignedInstanceSize();&#125;我们看到alignedInstanceSize函数的实现如下：1234// Class's ivar size rounded up to a pointer-size boundary.uint32_t alignedInstanceSize() const &#123; return word_align(unalignedInstanceSize());&#125;从而得出结论：class_getInstanceSize是获得NSObject实例对象的成员变量所占用的空间大小(isa指针所占的空间)，占用的空间大小8字节。但是我们通过malloc_size获取到的空间大小是16字节，为什么？接下来我们探究malloc_size的实现。我们知道malloc_size是调用的alloc方法，而alloc会调用allocWithZone，我们在源码中搜索allocWithZone，会在NSObject.mm文件中看到类似如下的实现12345678910111213// Call [cls alloc] or [cls allocWithZone:nil], with appropriate // shortcutting optimizations.static ALWAYS_INLINE idcallAlloc(Class cls, bool checkNil, bool allocWithZone=false)&#123;#if __OBJC2__ if (slowpath(checkNil &amp;&amp; !cls)) return nil; if (fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())) &#123; return _objc_rootAllocWithZone(cls, nil); &#125;#endif // ...&#125;我们研究_objc_rootAllocWithZone的实现会发现如下调用顺序：_objc_rootAllocWithZone -&gt;_class_createInstanceFromZone我们搜索_class_createInstanceFromZone的实现，会有如下发现：123456789101112131415161718192021222324static ALWAYS_INLINE id_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone, int construct_flags = OBJECT_CONSTRUCT_NONE, bool cxxConstruct = true, size_t *outAllocatedSize = nil)&#123; ASSERT(cls-&gt;isRealized()); // Read class's info bits all at once for performance bool hasCxxCtor = cxxConstruct &amp;&amp; cls-&gt;hasCxxCtor(); bool hasCxxDtor = cls-&gt;hasCxxDtor(); bool fast = cls-&gt;canAllocNonpointer(); size_t size; size = cls-&gt;instanceSize(extraBytes); if (outAllocatedSize) *outAllocatedSize = size; id obj; if (zone) &#123; obj = (id)malloc_zone_calloc((malloc_zone_t *)zone, 1, size); &#125; else &#123; obj = (id)calloc(1, size); &#125; ...然后发现关键的地方，变量size的值是通过instanceSize函数返回的，我们查找instanceSize的源码，然后会有如下发现12345678910size_t instanceSize(size_t extraBytes) const &#123; if (fastpath(cache.hasFastInstanceSize(extraBytes))) &#123; return cache.fastInstanceSize(extraBytes); &#125; size_t size = alignedInstanceSize() + extraBytes; // CF requires all objects be at least 16 bytes. if (size &lt; 16) size = 16; return size;&#125;上面的源码有两个关键的地方alignedInstanceSize我们在上面已经知道它返回的是成员变量所占用的空间大小，NSObject对象占用的大小为8字节。// CF requires all objects be at least 16 bytes.。我们可以知道分配的size一旦小于16，CoreFoundation框架会返回最小值16。至于alignedInstanceSize函数以及CF框架为什么会是16，这里不再深究，感兴趣的可以搜索内存对齐。这里简述一下：内存对齐(数据结构对齐)是方便访问，OC对象占用的空间大小都是16的倍数，结构体的内存对齐最小单元是8字节这里做一下总结：系统分配了16个字节给NSObject对象（通过malloc_size函数获得），但是NSObject内部只占用了8个字节的空间(64为环境下，可以通过class_getInstanceSize函数获得)实时查看内存数据View Memory了解一个对象所占用内存具体情况，我们可以利用Xcode的菜单栏上的Debug -&gt; Debug Workfllow -&gt; View Memory，来查看一个对象的内存占用情况。备注：内存中0000…一般代表未使用的空白空间LLDB我们还可以通过Xcode提供的LLDB进行断点调试12print、p：打印地址po：打印对象读取内存 memory read (简写为x)例：x/4xw 0x100550c2012memory read&#x2F;数量格式字节数 内存地址x&#x2F;数量格式字节数 内存地址修改内存中的值 memory write例： memory write 0x100550c29 101memory write 内存地址 数值自定义对象(Student)的本质我们研究NSObject对象后，继续研究简单的自定义对象，以Student对象为例，我们可以根据NSObject的内存结构推断出下面的结果。我们同样可以使用clang对这里的OC源码重新进行验证。1234567891011121314151617181920212223242526272829303132struct Student_IMPL &#123; Class isa; int _no; int _age; &#125;;@interface Student : NSObject &#123; @public int _no; // 4个字节 int _age; // 4个字节&#125;@end@implementation Student@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; Student *stu = [[Student alloc] init]; // 通过指针直接访问成员变量 stu-&gt;_no = 4; stu-&gt;_age = 5; NSLog(@\"%zd\", class_getInstanceSize([Student class])); // 16个字节 (8 + 4 + 4) NSLog(@\"%zd\", malloc_size((__bridge const void *)stu)); // 16个字节 // 等价结构体 struct Student_IMPL *stuImpl = (__bridge struct Student_IMPL *)stu; NSLog(@\"no is %d, age is %d\", stuImpl-&gt;_no, stuImpl-&gt;_age); // no is 4, age is 5 &#125; return 0;&#125;Student的内存布局Student对象占用了16个字节的内存空间，前8个字节放isa指针，接下来4位放_no变量，最后4位放_age变量。我们还可以通过View Memory验证，以及通过LLDB重写内存验证这一结论。通过上面的验证，可以知道Student的真实结构如下更复杂的继承结构结论：Person对象占用了16个字节的内存空间，Student也占用了16个字节的内存空间。备注：Student对象的Person_IVARS其实占用了16个字节的内存空间，但是有4个字节的未使用空间，_no变量大小为4个字节，刚好利用这4个内存空间。我们可以通过malloc_size函数进行验证这个结论属性和方法当我们为Person类增加一个属性时，如下：12345678910@interface Person : NSObject&#123; @public int _age;&#125;@property (nonatomic, assign) int height;@end@implementation Person@end我们知道@property默认会生成一个带下划线的变量，以及对应属性set和get方法，我们再次通过clang命令编译重写导出后能看到如下代码12345struct Person_IMPL &#123; struct NSObject_IMPL NSObject_IVARS; int _age; int _height;&#125;;也即验证了@property可以生成对应的变量。关于@property生成的方法的细节，我们在后面的文章中再讲解小结OC对象的本质是结构体系统分配了16个字节给NSObject对象，但NSObject对象内部只使用了8个字节的空间（64bit环境下，可以通过class_getInstanceSize函数获得）class_getInstanceSize返回的是需要的最小空间，malloc_size返回的是实际分配的内存空间大小参考和源码Apple Source Browser - objc","categories":[{"name":"ios","slug":"ios","permalink":"https://ticsmatic.com/categories/ios/"}],"tags":[{"name":"底层","slug":"底层","permalink":"https://ticsmatic.com/tags/%E5%BA%95%E5%B1%82/"}]},{"title":"GitBook安装和使用","slug":"GitBook安装和使用","date":"2020-04-17T03:18:31.793Z","updated":"2020-04-23T02:19:06.461Z","comments":true,"path":"p/9aea9f9/","link":"","permalink":"https://ticsmatic.com/p/9aea9f9/","excerpt":"介绍GitBook安装和使用","text":"介绍GitBook安装和使用安装GitBook 是一个基于 Node.js 的命令行工具，支持 Markdown 和 AsciiDoc 两种语法格式，可以输出 HTML、PDF、eBook 等格式的电子书。所以我更喜欢把 GitBook 定义为文档格式转换工具。因为 GitBook 是基于 Node.js，所以我们首先需要安装 Node.js1234567891011&#x2F;&#x2F; 检查是否有Node.js环境$ node -v&#x2F;&#x2F; 如果没有node环境的，先安装Node环境$ brew install node&#x2F;&#x2F; 现在安装 Node.js 都会默认安装 npm（node 包管理工具），所以我们不用单独安装 npm，打开命令行，执行以下命令安装 GitBook：npm install -g gitbook-cli&#x2F;&#x2F; 检查是否安装成功gitbook -v使用想象一下，现在你准备构建一本书籍，你在硬盘上新建了一个叫 mybook 的文件夹，按照以前的做法，你会新建一个 Word 文档，写上标题，然后开始巴滋巴滋地笔耕。但是现在有了 GitBook，你首先要做的是在 mybook 文件夹下执行以下命令：1gitbook init执行完后，你会看到多了两个文件 —— README.md 和 SUMMARY.md，它们的作用如下：README.md —— 书籍的介绍写在这个文件里SUMMARY.md —— 书籍的目录结构在这里配置然后就是编辑这个书的目录了，实际上需要一个支持MarkDown的编辑器，我们使用VSCode，来编辑 README.md 和 SUMMARY.md文件编辑 SUMMARY.md 文件，内容修改为：12345678910111213141516171819202122232425* [Python 基础](README.md)* 1.python基础 * [1.1.认识Python](day01&#x2F;01-Python简介.md) * [1.2.第一个Python程序](day01&#x2F;02-第一个程序.md) * [1.3.Pycharm设置（知道）](day01&#x2F;03-Pycharm设置（知道）.md) * [1.4.多文件项目的演练](day02&#x2F;04-多文件项目的演练.md) * [1.5.注释](day02&#x2F;05-注释.md) * [1.6.算数运算符](day02&#x2F;06-算数运算符.md) * [1.7.程序执行原理（科普）](day02&#x2F;07-程序执行原理（科普）.md) * [1.8.变量的基本使用](day02&#x2F;08-变量的基本使用.md)* day03 * [1.9.变量的命名](day03&#x2F;09-变量的命名.md) * [1.10.判断（if）语句](day03&#x2F;10-判断（if）语句.md) * [1.11.运算符](day03&#x2F;11-运算符.md) * [1.12.循环](day03&#x2F;12-循环.md)* day04 * [函数基础](day04&#x2F;函数基础.md)* day05 * [高级变量类型](day05&#x2F;高级变量类型.md)* day06 * [综合应用——名片管理系统](day06&#x2F;综合应用——名片管理系统.md)* day07 * [变量进阶（理解）](day07&#x2F;变量进阶（理解）.md) * [函数进阶](day07&#x2F;函数进阶.md)然后我们回到命令行，在 mybook 文件夹中再次执行gitbook init命令。GitBook 会查找 SUMMARY.md 文件中描述的目录和文件，如果没有则会将其创建。接着我们执行gitbook serve 来预览这本书籍，执行命令后会对 Markdown 格式的文档进行转换，默认转换为 html 格式，最后提示 “Serving book on http://localhost:4000”。嗯，打开浏览器看一下吧.当你写得差不多，你可以执行 gitbook build 命令构建书籍，默认将生成的静态网站输出到 _book 目录。实际上，这一步也包含在 gitbook serve 里面，因为它们是 HTML，所以 GitBook 通过 Node.js 给你提供服务了。当然，build 命令可以指定路径：1gitbook build [书籍路径] [输出路径]serve 命令也可以指定端口：1gitbook serve --port 2333你还可以生成 PDF 格式的电子书：123gitbook pdf .&#x2F; .&#x2F;mybook.pdfgitbook epub .&#x2F; .&#x2F;mybook.epubgitbook mobi .&#x2F; .&#x2F;mybook.mobi如果生成不了，你可能还需要安装一些工具，比如 ebook-convert。或者在 Typora 中安装 Pandoc 进行导出。此时基本就完成了。安装过程中遇到的问题gitbook init超时解决：替换npm的源gitbook build生成的html本地不能跳转解决：修改书籍下”theme.js”文件的内容。把if(m)for(替换为if(false)for(","categories":[],"tags":[]},{"title":"使用Hexo搭建博客","slug":"使用Hexo搭建博客","date":"2020-04-15T08:26:43.109Z","updated":"2020-04-23T10:02:15.232Z","comments":true,"path":"p/eb656981/","link":"","permalink":"https://ticsmatic.com/p/eb656981/","excerpt":"介绍使用Hexo搭建博客","text":"介绍使用Hexo搭建博客[TOC]环境mac 10.14默认已安装好了HomeBrew和Git搭建安装Node.js环境先检测电脑山管是否安装有Node.js环境，能正确显示版本号即表示node安装成功（mac不自带Node.js环境）12$ npm -v$ node -v安装Node.js（Hexo是基于Node.js环境的）1$ brew install node安装npm1$ npm install安装Hexo安装12# -g表示全局安装$ npm install hexo-cli -g初始化博客12$ cd myblog # 创建并进入存储博客的目录(myblog)$ hexo init # 初始化本地博客生成并运行服务执行下述命令生成本地网页文件并开启服务器，然后通过http://localhost:4000查看本地博客。12$ hexo g # Generate static files$ hexo s # Run server关联GitHub修改myblog目录下的_config.yml文件1234deploy: type: git repo: 这里填入你之前在GitHub上创建仓库的完整路径，记得加上 .git branch: maste双线部署123456deploy: type: git repo: gitee: https:&#x2F;&#x2F;gitee.com&#x2F;ticsmatic&#x2F;ticsmatic.git github: https:&#x2F;&#x2F;github.com&#x2F;ticsmatic&#x2F;ticsmatic.github.io.git branch: master部署发布1234$ hexo g $ hexo d &#x2F;&#x2F; Deploy to remote sites或者使用组合命令：$ hexo d -g若执行hexo g出错则执行npm install hexo --save，若执行hexo d出错则执行npm install hexo-deployer-git --save。错误修正后再次执行hexo g和hexo d上传到服务器若未关联GitHub，执行hexo d时会提示输入GitHub账号用户名和密码，即:12username for &#39;https:&#x2F;&#x2F;github.com&#39;:password for &#39;https:&#x2F;&#x2F;github.com&#39;:hexo d执行成功后便可通过git 仓库地址访问博客，看到的内容和http://localhost:4000相同。更换Hexo主题以比较精简的为例 maupassant123$ git clone https:&#x2F;&#x2F;github.com&#x2F;tufu9441&#x2F;maupassant-hexo.git themes&#x2F;maupassant$ npm install hexo-renderer-pug --save$ npm install hexo-renderer-sass --save将myblog目录下_config.yml里的theme的名称landscape更改为next。123$ hexo g &#x2F;&#x2F; 生成缓存和静态文件$ hexo d &#x2F;&#x2F; 重新部署到服务器$ hexo s &#x2F;&#x2F; Run server当本地博客部署到服务器后，网页端无变化时可以采用下述命令。1hexo clean &#x2F;&#x2F; 清楚缓存文件(db.json)和已生成的静态文件(public)推荐主题A-BoyAnisinaMaupassant 更适用于写文章JacmanMaterial-Xhexo-theme-sukavolantis ✔️写个博客1$ hexo new &quot;article title&quot;然后执行生成，发布即可其它知识当安装的一些插件不需要时，可以卸载123456npm uninstall 模块 删除本地模块时你应该思考的问题：是否将在package.json上的相应依赖信息也消除？npm uninstall 模块：删除模块，但不删除模块留在package.json中的对应信息npm uninstall 模块 --save 删除模块，同时删除模块留在package.json中dependencies下的对应信息npm uninstall 模块 --save-dev 删除模块，同时删除模块留在package.json中devDependencies下的对应信息参考hexo官方文档","categories":[],"tags":[]},{"title":"Git基础操作","slug":"Git基础操作","date":"2020-04-15T08:26:43.109Z","updated":"2020-04-23T02:19:06.467Z","comments":true,"path":"p/22f526fc/","link":"","permalink":"https://ticsmatic.com/p/22f526fc/","excerpt":"z","text":"zGit基础操作更多参考：GitBook V2配置账户123456$ git version # 查看版本$ git config -l # 查看当前配置$ git config --global user.name &quot;Dean&quot; # 设置用户名，邮箱 $ git config --global user.email g.xiangyu1990@gmail.com # 设置用户名，邮箱 $ git config --global alias.ci commit # 设置git命令的别名$ git config --global alias.co checkout # 设置git命令的别名仓库(repository)12$ git init # 创建一个本地的git仓库$ git clone https:&#x2F;&#x2F;xx.git &#x2F;path # 克隆一个远程的git仓库到指定路径添加(add)1234$ git add fileA fileB # 将本地指定文件名或目录（新增和修改，没有删除）的文件添加到暂存区$ git add . # 将本地所有的（新增和修改，没有删除）文件添加到暂存区$ git add -u # 将本地的（修改和删除，没有新增）文件添加到暂存区$ git add -A # 将本地所有改动添加到暂存区（git add -A &#x3D; git add . + git add -u）删除/重命名(rm/mv)1234git rm &lt;file&gt; # 删除文件git rm -r &lt;floder&gt; # 删除文件夹git rm --cached &lt;file&gt; # 从版本库中删除文件，但不删除文件，此时文件只会在本地存在 git mv &lt;old_name&gt; &lt;new_name&gt; # 文件重命名提交(commit)12345$ git commit m &quot;add file&quot;$ git commit -am &quot;add file&quot; # 等价于git add . + git commit -m &quot;add file&quot;$ git commit -m &quot;add fileA&quot; readme.md # 提交一个文件$ git commit &quot;增补提交&quot; --amend # 增补提交 $ git commit -C head --amend状态(status)123$ git status # 查看你的代码在缓存与当前工作目录的状态$ git status -s # 将结果以简短的形式输出$ git status --ignored # 显示被忽略的文件差异(diff)123456$ git diff # 查看工作目录（working tree）暂存区（index）的差别$ git diff --cached # 查看暂存起来的文件（stage）与并未提交（commit）的差别$ git diff --staged # 同上$ git diff HEAD # 查看最后一次提交之后的的差别（HEAD代表最近一次commit的信息）$ git diff --stat # 查看显示简略结果(文件列表)$ git diff commit1 commit2 # 对比两次提交的内容（也可以是branch，哈希值）查看历史(log)1234567# https:&#x2F;&#x2F;git-scm.com&#x2F;docs&#x2F;git-log$ git log -2 # 查看前2次修改$ git log --oneline # 一行显示一条log$ git log -p # 查看详细修改内容 $ git log --stat # 查看提交统计信息$ git log --graph # 显示何时出现了分支和合并等信息$ git reflog # 重返未来，以便确定要回到未来的哪个版本暂存(stash)1234567$ git stash # 存储$ git stash save &quot;message&quot; # 存储加说明$ git stash list # 查看储藏列表$ git stash pop # 恢复并删除存储$ git stash apply # 恢复最新的保存，但不删除$ git stash drop stash@&#123;0&#125; # 删除$ git stash clear # 删除所有取消/重置(checkout/reset)12345678910$ git checkout file1 file2 # 撤销未提交的修改$ git checkout . # 撤销所有未提交的文件修改$ git reset --mixed # git reset默认值，重置暂存区，但不改变工作区，再提交的话需要先添加到暂存区再commit$ git reset --soft # 回退到某个版本，不改变暂存区和工作区（如果还要提交，直接commit即可）$ git reset --hard # 彻底回退到某个版本，替换暂存区和工作区，本地的源码也会变为上一个版本的内容# 彻底回退到某个版本$ git reset commit_id$ git reset head^$ git reset filename # 将文件撤出暂存区（相当于git add filename的反向操作）撤销(revert)123456$ git revert commit # 撤销指定commit$ git revert -no-edit HEAD # 撤销上一次并直接使用默认注释$ git revert -n HEAD # 撤销上一次但不commit$ git revert -m 1 mergecomitid # 撤销分支的合并，且保留现有分支之后的提交记录(实践：feature分支合并到Dev分支，一段时间后发现这个feature分支有严重的bug，影响到Dev分支下业务的进行需要撤销掉feature分支的代码，可使用git revert命令，常用的附加参数是‘-m 1’，代表保留dev分支后的代码。撤销提交过程一般会有冲突，解决冲突，提交代码为commitidR, 当feature分支的bug修复完成，再次往Dev合并时，需要先git revert commitidR，然后把feature合并到dev上，流程完毕)本地分支查看、新建、切换1234567$ git branch -a # 列出所有分支信息$ git branch &lt;branchname&gt; # 新建分支$ git checkout &lt;branchname&gt; # 切换分支$ git checkout -b &lt;branchname&gt; # 基于当前分支创建并且换到新分支$ git branch feature&#x2F;login 82b31b # 基于某次提交、分支、或标签新建分支$ git branch tmp feature&#x2F;login分支合并(merge)123$ git merge feature&#x2F;login # 在develop分支上，把feature分支合并到develop分支$ git merge feature --no-ff -m &quot;msg&quot; # 强制显示每次操作变基(rebase)1234$ git rebase &lt;branch_name&gt; # 目标分支$ git rebase --continue # 执行rebase出现冲突解决后，执行该命令会继续应用(apply)余下的补丁$ git rebase --skip # 跳过当前提交，取以服务端为准$ git rebase --abort # 终止rebase, 分支会回到rebase开始前的状态删除分支12$ git branch -d feature&#x2F;login$ git branch -D feature&#x2F;login # 强制删除，即使分支没有被合并也删除远端分支新建、删除、关联本地分支123$ git push origin locbranch:originbranch # 新建$ git push origin --delete &lt;branchname&gt; # 删除$ git branch --set-upstream-to&#x3D;origin&#x2F;develop develop # 关联本地分支分支拉取(fetch/pull)12345$ git fetch origin develop # 只是获取远程仓库的数据至.git目录，并未merge本地$ git merge origin&#x2F;develop # 把获取的远程仓库的数据手工merge至当前分支$ git pull origin develop # 获取远程仓库的数据，并自动merge至当前的分支，相当于以上两步, git pull &#x3D;&#x3D; git fetch + git merge$ git pull --rebase # 也可以使用git pull的rebase策略分支推送12$ git push -f # 强推$ git push --all # 本地所有分支推送到远端prune1git remote prune origin # 修剪远程分支标签12345678$ git tag v1.0.0 commit_id # 新建（标签不能重命名）$ git tag # 查看$ git show v1.0.0$ git tag -d v1.0.0 # 删除$ git push origin v1.0.0 # 推送标签$ git push origin --tags$ git push origin :v1.0.0 # 删除远端标签$ git checkout -b branch_name tag_name # 切换到某个tag其它操作冲突123456&#39;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&#39;之间的内容是我的修改&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;之间的内容是别人的修改&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;一般是删除冲突标记，并解决冲突Vi编辑器12345$ vi filename # 创建文件 touch filenamevi编辑: i按ESC键 跳到命令模式:wq 是保存退出 :q! 是不保存强制退出硬核配置项目git(.git/config文件)1234567891011121314151617直接打开.git目录下的config文件进行编辑，参考内容如下[core] repositoryformatversion &#x3D; 0 filemode &#x3D; true bare &#x3D; false logallrefupdates &#x3D; true ignorecase &#x3D; true precomposeunicode &#x3D; true[remote &quot;origin&quot;] url &#x3D; https:&#x2F;&#x2F;gitee.com&#x2F;ticsmatic_admin&#x2F;CodeStore.git fetch &#x3D; +refs&#x2F;heads&#x2F;*:refs&#x2F;remotes&#x2F;origin&#x2F;*[branch &quot;master&quot;] remote &#x3D; origin merge &#x3D; refs&#x2F;heads&#x2F;master[branch &quot;develop&quot;] remote &#x3D; origin merge &#x3D; refs&#x2F;heads&#x2F;develop单文件回退1$ git reset comit_id filename # 把某个文件回退到某个提交历史，checkout也可以","categories":[],"tags":[]},{"title":"阿里云SSL证书使用","slug":" 阿里云SSL证书使用","date":"2020-04-15T01:39:01.616Z","updated":"2020-04-23T10:02:25.510Z","comments":true,"path":"p/2c49c232/","link":"","permalink":"https://ticsmatic.com/p/2c49c232/","excerpt":"标题","text":"标题阿里云SSL证书使用流程概要购买-&gt;申请证书（提交资料，填入域名、联系方式）-&gt;ssl域名解析验证-&gt;等待审核(大致5分钟)-&gt;审核成功-下载使用购买采用免费的个人版使用购买后点击”申请证书“填入资料（域名、联系人、联系方式）提交审核，大约3-20分钟，审核成功然后下载证书（选择需要的证书类型，有Tomcat、Apache、Nginx、IIS等）实例（为七牛云配置Https证书）购买SSL证书在阿里云购买证书SSL证书填写SSL证书申请资料填写申请资料，其中要绑定的域名为cdn.ticsmatic.com，然后验证域名解析，验证成功下载证书然后等待证书审核成功，下载Nginx类型的证书（因为七牛云需要的证书格式是pem、key，Nginx服务类型的证书刚好符合）分割线使用证书在七牛云的SSL证书服务tab下，上传在阿里云下载的SSL证书七牛云添加域名在七牛云的CDN下添加自己的域名cdn.ticsmatic.com，选择已经添加的https证书七牛云cname解析添加完域名后，七牛云会提示去对应的域名服务商进行cname域名解析。进入到阿里云的域名解析，解析七牛云的域名。填写cname信息后，去七牛云验证是佛解析成功（一般实时出结果）在七牛云中使用自定义的域名在气七牛云的对象存储服务中，绑定自己的域名cdn.ticsmatic.com，然后访问路径下的对象资源时，前缀就是cdn.ticsmatic.com","categories":[],"tags":[]},{"title":"使用volantis主题","slug":"volantis主题使用","date":"2020-04-14T09:25:58.266Z","updated":"2020-04-23T02:19:06.466Z","comments":true,"path":"p/6cb5ab8a/","link":"","permalink":"https://ticsmatic.com/p/6cb5ab8a/","excerpt":"z","text":"z[TOC]演示地址文档地址开始使用开始使用第1/3步：下载主题源码到 themes/ 文件夹1git clone https:&#x2F;&#x2F;github.com&#x2F;xaoxuu&#x2F;hexo-theme-volantis themes&#x2F;volantis第2/3步：修改站点配置文件 blog/_config.yml1theme: volantis第3/3步：检查并安装依赖安装 Hexo 搜索的依赖包：1npm i -S hexo-generator-search hexo-generator-json-content安装 stylus 渲染器：1npm i -S hexo-renderer-stylus站点文档主题文档页面文档写作文档红色Volantis为简单的一句话提供的简便写法。纯文本测试","categories":[{"name":"ios","slug":"ios","permalink":"https://ticsmatic.com/categories/ios/"}],"tags":[]}],"categories":[{"name":"ios","slug":"ios","permalink":"https://ticsmatic.com/categories/ios/"}],"tags":[{"name":"底层","slug":"底层","permalink":"https://ticsmatic.com/tags/%E5%BA%95%E5%B1%82/"}]}
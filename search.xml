<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Runloop</title>
      <link href="/p/d4d0b04c/"/>
      <url>/p/d4d0b04c/</url>
      
        <content type="html"><![CDATA[<p>学习MJ的视频课程，整理总结知识点–Runloop</p><a id="more"></a><p>[NSRunLoop mainRunLoop] CFRunLoopGetMain()</p><h2 id="基本认识"><a href="#基本认识" class="headerlink" title="基本认识"></a>基本认识</h2><p><img src="https://cdn.ticsmatic.com/img/2020-05-31/15908896344658.png" alt="RunLoop - 1"><br><img src="https://cdn.ticsmatic.com/img/2020-05-31/15908896618578.png" alt="RunLoop - 2"><br><img src="https://cdn.ticsmatic.com/img/2020-05-31/15908896959444.png" alt="RunLoop - 3"><br><img src="https://cdn.ticsmatic.com/img/2020-05-31/15908897128125.png" alt="RunLoop - 4"><br><img src="https://cdn.ticsmatic.com/img/2020-05-31/15908897349451.png" alt="RunLoop - 5"></p><h2 id="CFRunLoopModeRef"><a href="#CFRunLoopModeRef" class="headerlink" title="CFRunLoopModeRef"></a>CFRunLoopModeRef</h2><p><img src="https://cdn.ticsmatic.com/img/2020-05-31/15908897591829.png" alt="CFRunLoopModeRef - 1"></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __CFRunLoop &#123;</span><br><span class="line">    <span class="built_in">CFRuntimeBase</span> _base;</span><br><span class="line">    pthread_mutex_t _lock;<span class="comment">/* locked for accessing mode list */</span></span><br><span class="line">    __CFPort _wakeUpPort;<span class="comment">// used for CFRunLoopWakeUp </span></span><br><span class="line">    Boolean _unused;</span><br><span class="line">    <span class="keyword">volatile</span> _per_run_data *_perRunData;              <span class="comment">// reset for runs of the run loop</span></span><br><span class="line">    pthread_t _pthread;</span><br><span class="line">    uint32_t _winthread;</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _commonModes;</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _commonModeItems;</span><br><span class="line">    <span class="built_in">CFRunLoopModeRef</span> _currentMode;</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _modes;</span><br><span class="line">    <span class="keyword">struct</span> _block_item *_blocks_head;</span><br><span class="line">    <span class="keyword">struct</span> _block_item *_blocks_tail;</span><br><span class="line">    <span class="built_in">CFAbsoluteTime</span> _runTime;</span><br><span class="line">    <span class="built_in">CFAbsoluteTime</span> _sleepTime;</span><br><span class="line">    <span class="built_in">CFTypeRef</span> _counterpart;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __CFRunLoop &#123;</span><br><span class="line">    pthread_t _pthread;</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _commonModes;</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _commonModeItems;</span><br><span class="line">    <span class="built_in">CFRunLoopModeRef</span> _currentMode;</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _modes;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>NSRunloop是对CFRunloop的一层包装</p><p>source0<br>触摸事件 lldb: bt调试<br>performSelector:onThread:</p><p>source1<br>基于Port的线程间通信的<br>系统事件捕捉</p><p>timers<br>NSTimer<br>performSelector:withObject:afterDelay:</p><p>observes<br>监听Runloop的状态<br>UI界面刷新(BeforeWaiting)(self.view.backgroundColor = color)<br>AutoreleasePool(BeforeWaiting)</p><p><strong>Runloop循环处理某种模式下的source0、source1、timers、observes</strong></p><p>CFRunLoopObserverRef<br>用observer监听RunLoop的运行状态</p><p><img src="https://cdn.ticsmatic.com/img/2020-05-31/15908899061418.png" alt="CFRunLoopModeRef - 2"></p><p><img src="https://cdn.ticsmatic.com/img/2020-05-31/15908900219481.png" alt="CFRunLoopActivity"></p><p>beforeWaiting 即将睡觉<br>afterWaiting 睡完醒了</p><p><img src="https://cdn.ticsmatic.com/img/2020-05-31/15908900507798.png" alt="RunLoop添加Observer"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>Runloop循环处理某种模式下的source0、source1、timers、observes</strong></p><h2 id="参考和源码"><a href="#参考和源码" class="headerlink" title="参考和源码"></a>参考和源码</h2><p>源码：</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Runloop</title>
      <link href="/p/d4d0b04c/"/>
      <url>/p/d4d0b04c/</url>
      
        <content type="html"><![CDATA[<p>学习MJ的视频课程，整理总结知识点–Runloop</p><a id="more"></a><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><img src="https://cdn.ticsmatic.com/img/2020-06-03/15911441554959.png" alt="iOS中的常见多线程方案"></p><p>GCD使用<br><img src="https://cdn.ticsmatic.com/img/2020-06-03/15911441873942.png" alt="GCD的常用函数"><br>sync同步意味着只能在当前线程执行，不具备开启线程的能力<br>async可能在新开的线程执行（特列：异步主队列主执行，不能开新线程）</p><p>并发队列、串行队列<br>队列的类型，决定了任务的执行方式（并发、串行）<br><img src="https://cdn.ticsmatic.com/img/2020-06-03/15911443042577.png" alt="GCD的队列"></p><p>总结<br><img src="https://cdn.ticsmatic.com/img/2020-06-03/15911443608905.png" alt="各种队列的执行效果"></p><h2 id="死锁面试题"><a href="#死锁面试题" class="headerlink" title="死锁面试题"></a>死锁面试题</h2><p>面试题1、gcd产生死锁</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)interview01 &#123;</span><br><span class="line">    <span class="comment">// 问题：以下代码是在主线程执行的，会不会产生死锁？会！</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"执行任务1"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 主队列里已经有任务，有添加了一个任务，FIFO串行执行，旧的任务interview01没执行完，还要立马执行新任务@"执行任务2"，两者之间互相死等</span></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_main_queue();</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"执行任务2"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"执行任务3"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// dispatch_sync立马在当前线程同步执行任务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>队列：排队 FIFO<br>从主队类取任务，得等上一个任务执行完，sync要求立马在当前线程执行任务，执行完毕才能继续往下走。<br><img src="https://cdn.ticsmatic.com/img/2020-06-03/15911444195362.png" alt="死锁面试题分析"></p><p>面试题2</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)interview02 &#123;</span><br><span class="line">    <span class="comment">// 问题：以下代码是在主线程执行的，会不会产生死锁？不会！</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"执行任务1"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_main_queue();</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"执行任务2"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"执行任务3"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// dispatch_async不要求立马在当前线程同步执行任务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异步主队类执行，不会死锁<br>async：不要求里面在当前线程同步执行<br>执行时已经出了函数栈</p><p>面试题3</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)interview03</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 问题：以下代码是在主线程执行的，会不会产生死锁？会！</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"执行任务1"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"myqueu"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123; <span class="comment">// 0</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"执行任务2"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">dispatch_sync</span>(queue, ^&#123; <span class="comment">// 1</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"执行任务3"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"执行任务4"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"执行任务5"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很重要的结论：<strong>sync当前的串行队列都会死锁</strong></p><p>面试题4<br>sync在其它队列，木问题</p><p>面试题5<br>并发队列，内部sync木问题，队列中的任务会并发执行</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)interview05</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 问题：以下代码是在主线程执行的，会不会产生死锁？不会！</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"执行任务1"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"myqueu"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123; <span class="comment">// 0</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"执行任务2"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">dispatch_sync</span>(queue, ^&#123; <span class="comment">// 1</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"执行任务3"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"执行任务4"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"执行任务5"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>全局并发队列、自定义并发队列的区别<br><code>dispatch_queue_t queue1 = dispatch_get_global_queue(0, 0);</code>两个全局并发队列的内存地址一样，位域内存中的<code>Global</code>区<br><code>dispatch_queue_t queue3 = dispatch_queue_create(&quot;queu3&quot;, DISPATCH_QUEUE_CONCURRENT);</code>每个自定义并发队列的内存地址不一样，位域内存中的堆区</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h2 id="参考和源码"><a href="#参考和源码" class="headerlink" title="参考和源码"></a>参考和源码</h2><p>源码：</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>GCD定时器、内存布局、Tagged Pointer</title>
      <link href="/p/24a6731c/"/>
      <url>/p/24a6731c/</url>
      
        <content type="html"><![CDATA[<p>学习MJ的视频课程，整理总结知识点–GCD定时器、内存布局、Tagged Pointer</p><a id="more"></a><h2 id="GCD定时器"><a href="#GCD定时器" class="headerlink" title="GCD定时器"></a>GCD定时器</h2><p>timer是添加到RunLoop中处理的，RunLoop每跑一圈检测一次timer是否满足触发条件，所以每一圈的时间是不确定的。</p><p>NSTimer依赖于RunLoop，如果RunLoop的任务过于繁重，可能会导致NSTimer不准时</p><p>GCD的定时器是直接与内核挂钩的，与RunLoop无关，所以是比较精确的</p><p><img src="https://cdn.ticsmatic.com/img/2020-06-09/15917060634711.png" alt="GCD定时器"></p><h2 id="GCD定时器的封装"><a href="#GCD定时器的封装" class="headerlink" title="GCD定时器的封装"></a>GCD定时器的封装</h2><h2 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h2><p>堆空间内存对齐，最后位肯定是0</p><p><img src="https://cdn.ticsmatic.com/img/2020-06-09/15917127185119.png" alt="内存布局"></p><h2 id="Tagged-Pointer"><a href="#Tagged-Pointer" class="headerlink" title="Tagged Pointer"></a>Tagged Pointer</h2><p>从64bit开始，iOS引入了Tagged Pointer技术，用于优化NSNumber、NSDate、NSString等小对象的存储</p><p>在没有使用Tagged Pointer之前， NSNumber等对象需要动态分配内存、维护引用计数等，NSNumber指针存储的是堆中NSNumber对象的地址值</p><p>使用Tagged Pointer之后，NSNumber指针里面存储的数据变成了：Tag + Data，也就是将数据直接存储在了指针中</p><p>当指针不够存储数据时，才会使用动态分配内存的方式来存储数据</p><p>objc_msgSend能识别Tagged Pointer，比如NSNumber的intValue方法，直接从指针提取数据，节省了以前的调用开销</p><p>如何判断一个指针是否为Tagged Pointer？<br>iOS平台，最高有效位是1（第64bit）<br>Mac平台，最低有效位是1</p><p><img src="https://cdn.ticsmatic.com/img/2020-06-09/15917127346138.png" alt="判断是否为Tagged Pointer"></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不加锁的话会崩溃 多线程setter内部会重复调用对象的release方法</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        <span class="keyword">self</span>.name = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"abcdefghijk"</span>];</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不会崩溃，因为是tagged pointer，直接指针赋值，不存在release、retain</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="keyword">self</span>.name = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"abc"</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h2 id="参考和源码"><a href="#参考和源码" class="headerlink" title="参考和源码"></a>参考和源码</h2><p>源码：</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MRC、copy</title>
      <link href="/p/bff81d76/"/>
      <url>/p/bff81d76/</url>
      
        <content type="html"><![CDATA[<p>学习MJ的视频课程，整理总结知识点–MRC、copy</p><a id="more"></a><h2 id="MRC"><a href="#MRC" class="headerlink" title="MRC"></a>MRC</h2><p>人、狗<br>狗属于人，人存在狗就要存在，人死了，狗也得死。狗的内存管理交给人</p><p>有两个狗，人换狗了，老狗要先释放</p><p>set方法：<strong>release旧值，retain新值</strong><br>要判断是不是同一个狗，同一个狗的话就跳过，因为此时release旧值，导致狗的retaincount为0，狗会释放</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setDog:(MJDog *)dog &#123;</span><br><span class="line">    <span class="keyword">if</span> (_dog != dog) &#123;</span><br><span class="line">        [_dog release];</span><br><span class="line">        _dog = [dog <span class="keyword">retain</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>升级版使用@property<br>@property， 编译器自动生成synthesize：自动生成成员变量和属性的setter、getter实现</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">retain</span>) MJDog *dog;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    <span class="keyword">self</span>.dog = <span class="literal">nil</span>;</span><br><span class="line">    [<span class="keyword">super</span> dealloc];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MRC编程<br>NSMutableArray的alloc方法，需要自己release，不是alloc或new或copy初始化的，比如[NSMutableArray array]初始化的，就不需要调用release，这个类方法内部实现会有类似autorelease函数的调用</p><p>工厂方法，里面封装autorelease</p><h2 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h2><p>拷贝</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">根本</span><br><span class="line"><span class="comment">// 拷贝的目的：产生一个副本对象，跟源对象互不影响</span></span><br><span class="line"><span class="comment">// 修改了源对象，不会影响副本对象</span></span><br><span class="line"><span class="comment">// 修改了副本对象，不会影响源对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> iOS提供了2个拷贝方法</span></span><br><span class="line"><span class="comment"> 1.copy，不可变拷贝，产生不可变副本</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> 2.mutableCopy，可变拷贝，产生可变副本</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> 深拷贝和浅拷贝</span></span><br><span class="line"><span class="comment"> 1.深拷贝：内容拷贝，产生新的对象</span></span><br><span class="line"><span class="comment"> 2.浅拷贝：指针拷贝，没有产生新的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>不可变对象的copy，大家都是不可变，干脆指向同一块内容，所以生成的还是不可变对象</p><p>可变对象的copy，都是深拷贝，生成不可变副本</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h2 id="参考和源码"><a href="#参考和源码" class="headerlink" title="参考和源码"></a>参考和源码</h2><p>源码：</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>atomic、读写安全、定时器</title>
      <link href="/p/63797d9b/"/>
      <url>/p/63797d9b/</url>
      
        <content type="html"><![CDATA[<p>学习MJ的视频课程，整理总结知识点–atomic、读写安全、定时器</p><a id="more"></a><h2 id="atomic"><a href="#atomic" class="headerlink" title="atomic"></a>atomic</h2><p>atomic：原子，不可再分割的单位<br>保证setter和getter内部实现是线程同步的<br>但是不能保证同时setter、getter时线程同步，要想实现setter、getter的安全，这两个函数内部要重写并自己加锁，或者在调用这两个函数的地方加锁。</p><p>iPhone不适用：调用频率高，都加锁解锁耗性能</p><p>1、atomic不能保证安全（同步锁），为何；如何保证<br>Atomic使用的是自旋锁，在setter和getter加锁spinlock_t，不能保证真正的线程安全，如果多个线程同时读写这个值，某个线程就会获取到错误的值</p><h2 id="读写安全"><a href="#读写安全" class="headerlink" title="读写安全"></a>读写安全</h2><p>多读单写：读时可并发读、写仍然是单线程；读写之间也是互斥</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pthread_rwlock：读写锁</span><br><span class="line">dispatch_barrier_async：异步栅栏调用</span><br></pre></td></tr></table></figure><h3 id="pthread-rwlock"><a href="#pthread-rwlock" class="headerlink" title="pthread_rwlock"></a>pthread_rwlock</h3><p>等待锁的线程会进入休眠<br><img src="https://cdn.ticsmatic.com/img/2020-06-09/15916705224332.png" alt="pthread_rwlock"></p><p>runtime源码中有不少地方用到<code>pthread_rwlock</code></p><h3 id="dispatch-barrier-async"><a href="#dispatch-barrier-async" class="headerlink" title="dispatch_barrier_async"></a>dispatch_barrier_async</h3><p>这个函数传入的并发队列必须是自己通过dispatch_queue_cretate创建的<br>如果传入的是一个串行或是一个全局的并发队列，那这个函数便等同于dispatch_async函数的效果<br><img src="https://cdn.ticsmatic.com/img/2020-06-09/15916705224397.png" alt="d499f7b8-03a7-439d-a0ec-77596c798610"></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.queue = dispatch_queue_create(<span class="string">"rw_queue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        [<span class="keyword">self</span> read];</span><br><span class="line">        [<span class="keyword">self</span> read];</span><br><span class="line">        [<span class="keyword">self</span> read];</span><br><span class="line">        [<span class="keyword">self</span> write];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)read &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.queue, ^&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"read"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)write &#123;</span><br><span class="line">    dispatch_barrier_async(<span class="keyword">self</span>.queue, ^&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"write"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.ticsmatic.com/img/2020-06-09/15916754327494.png" alt="dispatch_barrier_async"></p><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><h3 id="CADisplayLink"><a href="#CADisplayLink" class="headerlink" title="CADisplayLink"></a>CADisplayLink</h3><p><img src="https://cdn.ticsmatic.com/img/2020-06-09/15916968513527.png" alt="CADisplayLink、NSTimer使用注意"></p><h3 id="NSTimer"><a href="#NSTimer" class="headerlink" title="NSTimer"></a>NSTimer</h3><p>解决循环引用<br>1、timer的block初始化方式<br>2、自定义target，通过消息转发给原target</p><h3 id="NSProxy"><a href="#NSProxy" class="headerlink" title="NSProxy"></a>NSProxy</h3><p>特殊的类<br>存在的意义：解决代理转发行为<br>做消息转发的话相比NSObject效率更高，少了去父类搜索的流程和动态方法解析的阶段</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MJProxy</span></span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)proxyWithTarget:(<span class="keyword">id</span>)target &#123;</span><br><span class="line">    <span class="comment">// NSProxy对象不需要调用init，因为它本来就没有init方法</span></span><br><span class="line">    MJProxy *proxy = [MJProxy alloc];</span><br><span class="line">    proxy.target = target;</span><br><span class="line">    <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span>.target methodSignatureForSelector:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)invocation &#123;</span><br><span class="line">    [invocation invokeWithTarget:<span class="keyword">self</span>.target];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>NSProxy大部分方法底层都没有实现，调用时很容易就消息转发了，会调用Target的方法</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h2 id="参考和源码"><a href="#参考和源码" class="headerlink" title="参考和源码"></a>参考和源码</h2><p>源码：</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>weak指针、autorelease原理</title>
      <link href="/p/1abf6ce/"/>
      <url>/p/1abf6ce/</url>
      
        <content type="html"><![CDATA[<p>学习MJ的视频课程，整理总结知识点–weak指针、autorelease原理</p><a id="more"></a><h2 id="引用计数的存储"><a href="#引用计数的存储" class="headerlink" title="引用计数的存储"></a>引用计数的存储</h2><p>存储位置<br><img src="https://cdn.ticsmatic.com/img/2020-06-10/15918004151387.png" alt="isa"></p><p><img src="https://cdn.ticsmatic.com/img/2020-06-10/15918003799854.png" alt="引用计数的存储"></p><p>对象释放</p><h2 id="weak指针的原理"><a href="#weak指针的原理" class="headerlink" title="weak指针的原理"></a>weak指针的原理</h2><p>weak引用是存储在哈希表（弱引用表SideTable-&gt;weak_table），当对象dealloc时，dealloc方法会清除哈希表中对应的值</p><p>关联对象表、引用计数表<br><img src="https://cdn.ticsmatic.com/img/2020-06-10/15918003946738.png" alt="dealloc"></p><h2 id="ARC帮我们做了什么"><a href="#ARC帮我们做了什么" class="headerlink" title="ARC帮我们做了什么"></a>ARC帮我们做了什么</h2><p>LLVM+Runtime相互协作的结果<br>利用LLVM自动帮我们生成release、retain、autorelease等内存管理相关的代码，弱引用的清除利用了Runtime运行时自动处理。</p><h2 id="autorelease原理"><a href="#autorelease原理" class="headerlink" title="autorelease原理"></a>autorelease原理</h2><p><img src="https://cdn.ticsmatic.com/img/2020-06-10/15918004341086.png" alt="自动释放池"></p><p>clang源代码，发现__AtAutoreleasePool的两个关键的函数</p><p>runtime中查看这两个函数的实现，发现调用的是AutoreleasePoolPage类的方法</p><p>调用了autorelease的对象最终都是通过AutoreleasePoolPage对象来管理的</p><p>研究AutoreleasePoolPage的结构</p><p>多个pool，之间是通过双向链表联系<br>知道每个pool内空间的分布</p><p><img src="https://cdn.ticsmatic.com/img/2020-06-10/15918005392664.png" alt="AutoreleasePoolPage的结构"></p><p>调用push方法会将一个<code>POOL_BOUNDARY</code>入栈（插入边界标记），并且返回其存放的内存地址</p><p>调用pop方法时传入一个<code>POOL_BOUNDARY</code>的内存地址，会从最后一个入栈的对象开始发送release消息，直到遇到这个<code>POOL_BOUNDARY</code></p><p>id *next指向了下一个能存放autorelease对象地址的区域</p><p>查看的函数<br><code>_objc_autoreleasePoolPrint();</code></p><p>push流程，压边界标记，添加autorelease对象到page里</p><p>pop流程，查找直到边界标记token，release</p><h3 id="autorelease总结"><a href="#autorelease总结" class="headerlink" title="autorelease总结"></a>autorelease总结</h3><p>对象存储在AutoreleasePoolPage，每个自动释放池插入自动释放对象前先插入<code>POOL_BOUNDARY</code>作为边界标记</p><h2 id="RunLoop与autorelease"><a href="#RunLoop与autorelease" class="headerlink" title="RunLoop与autorelease"></a>RunLoop与autorelease</h2><p>autorelease对象在什么时候会被释放<br>1、被autoreleasepool包围的，出了括号就被释放<br>2、在iOS项目中测试，并不是被main函数的autoreleasepool管理的，因为main函数里的autoreleasepool包围着主线程的RunLoop，是一直走不到autoreleasepool大括号结尾的</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这个Person什么时候调用release，是由RunLoop来控制的</span></span><br><span class="line">    <span class="comment">// 它可能是在某次RunLoop循环中，RunLoop休眠之前调用了release</span></span><br><span class="line">    <span class="comment">// MJPerson *person = [[[MJPerson alloc] init] autorelease];</span></span><br><span class="line">    </span><br><span class="line">    MJPerson *person = [[MJPerson alloc] init];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span></span><br><span class="line"><span class="comment"> kCFRunLoopEntry = (1UL &lt;&lt; 0),  1</span></span><br><span class="line"><span class="comment"> kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), 2</span></span><br><span class="line"><span class="comment"> kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), 4</span></span><br><span class="line"><span class="comment"> kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), 32</span></span><br><span class="line"><span class="comment"> kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), 64</span></span><br><span class="line"><span class="comment"> kCFRunLoopExit = (1UL &lt;&lt; 7), 128</span></span><br><span class="line"><span class="comment"> kCFRunLoopAllActivities = 0x0FFFFFFFU</span></span><br><span class="line"><span class="comment"> &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> kCFRunLoopEntry  push</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> &lt;CFRunLoopObserver 0x60000013f220 [0x1031c8c80]&gt;&#123;valid = Yes, activities = 0x1, repeats = Yes, order = -2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x103376df2), context = &lt;CFArray 0x60000025aa00 [0x1031c8c80]&gt;&#123;type = mutable-small, count = 1, values = (\n\t0 : &lt;0x7fd0bf802048&gt;\n)&#125;&#125;</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> kCFRunLoopBeforeWaiting | kCFRunLoopExit</span></span><br><span class="line"><span class="comment"> kCFRunLoopBeforeWaiting pop、push</span></span><br><span class="line"><span class="comment"> kCFRunLoopExit pop</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> &lt;CFRunLoopObserver 0x60000013f0e0 [0x1031c8c80]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x103376df2), context = &lt;CFArray 0x60000025aa00 [0x1031c8c80]&gt;&#123;type = mutable-small, count = 1, values = (\n\t0 : &lt;0x7fd0bf802048&gt;\n)&#125;&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h2 id="参考和源码"><a href="#参考和源码" class="headerlink" title="参考和源码"></a>参考和源码</h2><p>源码：</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>性能优化-耗电、架构设计</title>
      <link href="/p/34aa13dd/"/>
      <url>/p/34aa13dd/</url>
      
        <content type="html"><![CDATA[<p>学习MJ的视频课程，整理总结知识点–性能优化-耗电、架构设计</p><a id="more"></a><h2 id="耗电优化"><a href="#耗电优化" class="headerlink" title="耗电优化"></a>耗电优化</h2><p><img src="https://cdn.ticsmatic.com/img/2020-06-14/15921476820358.png" alt="屏幕快照 2020-06-14 下午11.10.12"><br><img src="https://cdn.ticsmatic.com/img/2020-06-14/15921476871057.png" alt="屏幕快照 2020-06-14 下午11.11.28"></p><h2 id="APP的启动"><a href="#APP的启动" class="headerlink" title="APP的启动"></a>APP的启动</h2><p><img src="https://cdn.ticsmatic.com/img/2020-06-14/15921477094809.png" alt="屏幕快照 2020-06-11 下午1.56.18"><br><img src="https://cdn.ticsmatic.com/img/2020-06-14/15921477126762.png" alt="屏幕快照 2020-06-11 下午1.56.28"></p><p><img src="https://cdn.ticsmatic.com/img/2020-06-14/15921477639525.png" alt="屏幕快照 2020-06-14 下午11.15.24"><br><img src="https://cdn.ticsmatic.com/img/2020-06-14/15921477667767.png" alt="屏幕快照 2020-06-14 下午11.15.27"><br><img src="https://cdn.ticsmatic.com/img/2020-06-14/15921477696474.png" alt="屏幕快照 2020-06-14 下午11.15.30"><br><img src="https://cdn.ticsmatic.com/img/2020-06-14/15921477726157.png" alt="屏幕快照 2020-06-14 下午11.15.36"></p><h2 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h2><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p>结构图：<br>Apple的结构， UITableViewController<br>Model和View之间互相不知道，View和Model复用方便，Controller臃肿</p><h2 id="MVC变种"><a href="#MVC变种" class="headerlink" title="MVC变种"></a>MVC变种</h2><p>结构图：</p><p>项目迭代频繁，业务复杂，View和Model的成本很低，减少控制器业务逻辑<br>优点：对Controller进行瘦身，将View内部的细节封装起来了，外界不知道View内部的具体实现<br>缺点：View依赖于Model</p><h2 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h2><p>结构图：</p><p>把MVC架构下，控制器的一部分功能挪到presenter里<br>一个控制器可以有多个presenter，每个presenter封装处理一部分业务</p><p>去网上再找找资料</p><h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p>结构图</p><p>核心：属性监听，View和ViewMode是双向绑定的<br>View监听ViewModel属性的改变<br>监听的方案：RAC、KVO、KVOController<br>一个控制器可以有多个ViewMode，每个ViewMode封装处理一部分业务</p><p>MVVM+RAC</p><h2 id="VIPPER"><a href="#VIPPER" class="headerlink" title="VIPPER"></a>VIPPER</h2><h2 id="CDD"><a href="#CDD" class="headerlink" title="CDD"></a>CDD</h2><h2 id="分层架构"><a href="#分层架构" class="headerlink" title="分层架构"></a>分层架构</h2><p>界面层</p><p>业务层</p><p>数据层</p><h2 id="设计模式简介"><a href="#设计模式简介" class="headerlink" title="设计模式简介"></a>设计模式简介</h2><p>创建：</p><p>结构：</p><p>行为：</p><p>delegate并不是代理模式，NSProxy更像代理模式</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h2 id="参考和源码"><a href="#参考和源码" class="headerlink" title="参考和源码"></a>参考和源码</h2><p>源码：</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>性能优化-卡顿</title>
      <link href="/p/a073543c/"/>
      <url>/p/a073543c/</url>
      
        <content type="html"><![CDATA[<p>学习MJ的视频课程，整理总结知识点–性能优化-卡顿</p><a id="more"></a><h2 id="CPU和GPU"><a href="#CPU和GPU" class="headerlink" title="CPU和GPU"></a>CPU和GPU</h2><p>CPU是处理器，GPU是了解屏幕的<br><img src="https://cdn.ticsmatic.com/img/2020-06-11/15918448117980.png" alt="CPU和GPU"></p><h2 id="屏幕成像原理"><a href="#屏幕成像原理" class="headerlink" title="屏幕成像原理"></a>屏幕成像原理</h2><p><img src="https://cdn.ticsmatic.com/img/2020-06-11/15918448382326.png" alt="屏幕成像原理"></p><p>先垂直同步信号、再水平同步信号</p><h2 id="卡顿产生的原因"><a href="#卡顿产生的原因" class="headerlink" title="卡顿产生的原因"></a>卡顿产生的原因</h2><p><img src="https://cdn.ticsmatic.com/img/2020-06-11/15918448633226.png" alt="卡顿产生的原因"></p><p>垂直信号来了，就要显示，发现GPU还没渲染完，此时就会把上次GPU渲染的帧显示上去，当前GPU渲染的帧就会丢失，等待下一次垂直信号达到时渲染。按照60FPS的刷帧率，每隔16ms（1000/60）就会有一次VSync信号，所以要尽可能减少CPU和GPU的资源消耗。</p><h2 id="卡顿优化"><a href="#卡顿优化" class="headerlink" title="卡顿优化"></a>卡顿优化</h2><p><img src="https://cdn.ticsmatic.com/img/2020-06-11/15918448796538.png" alt="卡顿优化-CPU"><br>图片异步解码</p><p><img src="https://cdn.ticsmatic.com/img/2020-06-11/15918448928888.png" alt="卡顿优化-GPU"><br>透明需要混合计算</p><h2 id="离屏渲染"><a href="#离屏渲染" class="headerlink" title="离屏渲染"></a>离屏渲染</h2><h2 id="卡顿检测"><a href="#卡顿检测" class="headerlink" title="卡顿检测"></a>卡顿检测</h2><p>监听RunLoop状态切换的耗时<br>LXDAppFluencyMonitor</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h2 id="参考和源码"><a href="#参考和源码" class="headerlink" title="参考和源码"></a>参考和源码</h2><p>源码：</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Runloop</title>
      <link href="/p/d4d0b04c/"/>
      <url>/p/d4d0b04c/</url>
      
        <content type="html"><![CDATA[<p>学习MJ的视频课程，整理总结知识点–Runloop</p><a id="more"></a><h2 id="RunLoop的运行逻辑"><a href="#RunLoop的运行逻辑" class="headerlink" title="RunLoop的运行逻辑"></a>RunLoop的运行逻辑</h2><p>RunLoop 循环等待处理sources、timers，处理完睡觉</p><p><img src="https://cdn.ticsmatic.com/img/2020-06-02/15910581242727.jpeg" alt="RunLoop-1"></p><p><img src="https://cdn.ticsmatic.com/img/2020-06-02/15910583975080.png" alt="RunLoop-2"></p><p><img src="https://cdn.ticsmatic.com/img/2020-06-02/15910583975099.png" alt="RunLoop-3"></p><p><img src="https://cdn.ticsmatic.com/img/2020-06-02/15910583975063.png" alt="RunLoop-4"></p><p>MJ流程图介绍（熟悉）<br>切换模式、线程销毁会推出Loop；循环2-10的步骤</p><p>实践RunLoop的调用流程</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="comment">// 函数调用栈 LLDB中使用backtrace命令: bt</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"111111"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(lldb) bt</span><br><span class="line">* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 2.1</span><br><span class="line">  * frame #<span class="number">0</span>: <span class="number">0x00000001040f3571</span> Interview01-runloop流程`__29-[ViewController viewDidLoad]_block_invoke_2(.block_descriptor=<span class="number">0x00000001040f50c0</span>) at ViewController.m:<span class="number">32</span>:<span class="number">9</span></span><br><span class="line">    frame #<span class="number">1</span>: <span class="number">0x000000010440ddf0</span> libdispatch.dylib`_dispatch_call_block_and_release + <span class="number">12</span></span><br><span class="line">    frame #<span class="number">2</span>: <span class="number">0x000000010440ed64</span> libdispatch.dylib`_dispatch_client_callout + <span class="number">8</span></span><br><span class="line">    frame #<span class="number">3</span>: <span class="number">0x000000010441ce1c</span> libdispatch.dylib`_dispatch_main_queue_callback_4CF + <span class="number">1500</span></span><br><span class="line">    frame #<span class="number">4</span>: <span class="number">0x00007fff23afb699</span> CoreFoundation`__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__ + <span class="number">9</span></span><br><span class="line">    frame #<span class="number">5</span>: <span class="number">0x00007fff23af62f9</span> CoreFoundation`__CFRunLoopRun + <span class="number">2329</span></span><br><span class="line">    frame #<span class="number">6</span>: <span class="number">0x00007fff23af56b6</span> CoreFoundation`CFRunLoopRunSpecific + <span class="number">438</span></span><br><span class="line">    frame #<span class="number">7</span>: <span class="number">0x00007fff3815cbb0</span> GraphicsServices`GSEventRunModal + <span class="number">65</span></span><br><span class="line">    frame #<span class="number">8</span>: <span class="number">0x00007fff47162a67</span> UIKitCore`UIApplicationMain + <span class="number">1621</span></span><br><span class="line">    frame #<span class="number">9</span>: <span class="number">0x00000001040f3680</span> Interview01-runloop流程`main(argc=<span class="number">1</span>, argv=<span class="number">0x00007ffeebb0bc68</span>) at main.m:<span class="number">14</span>:<span class="number">16</span></span><br><span class="line">    frame #<span class="number">10</span>: <span class="number">0x00007fff5123bcf5</span> libdyld.dylib`start + <span class="number">1</span></span><br><span class="line">    frame #<span class="number">11</span>: <span class="number">0x00007fff5123bcf5</span> libdyld.dylib`start + <span class="number">1</span></span><br></pre></td></tr></table></figure><blockquote><p>打印函数调用栈 bt</p></blockquote><p>RunLoop执行流程源码分析，从<code>CFRunLoopRunSpecific</code>开始，在<code>CFRunLoop.c</code>中搜索<code>CFRunLoopRunSpecific</code>，找打对应的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SInt32 <span class="title">CFRunLoopRunSpecific</span><span class="params">(CFRunLoopRef rl, CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled)</span> </span>&#123;     <span class="comment">/* DOES CALLOUT */</span></span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    <span class="keyword">if</span> (__CFRunLoopIsDeallocating(rl)) <span class="keyword">return</span> kCFRunLoopRunFinished;</span><br><span class="line">    __CFRunLoopLock(rl);</span><br><span class="line">    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, modeName, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == currentMode || __CFRunLoopModeIsEmpty(rl, currentMode, rl-&gt;_currentMode)) &#123;</span><br><span class="line">Boolean did = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (currentMode) __CFRunLoopModeUnlock(currentMode);</span><br><span class="line">__CFRunLoopUnlock(rl);</span><br><span class="line"><span class="keyword">return</span> did ? kCFRunLoopRunHandledSource : kCFRunLoopRunFinished;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">volatile</span> _per_run_data *previousPerRun = __CFRunLoopPushPerRunData(rl);</span><br><span class="line">    CFRunLoopModeRef previousMode = rl-&gt;_currentMode;</span><br><span class="line">    rl-&gt;_currentMode = currentMode;</span><br><span class="line">    <span class="keyword">int32_t</span> result = kCFRunLoopRunFinished;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (currentMode-&gt;_observerMask &amp; kCFRunLoopEntry ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);</span><br><span class="line">result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);</span><br><span class="line"><span class="keyword">if</span> (currentMode-&gt;_observerMask &amp; kCFRunLoopExit ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br><span class="line"></span><br><span class="line">        __CFRunLoopModeUnlock(currentMode);</span><br><span class="line">        __CFRunLoopPopPerRunData(rl, previousPerRun);</span><br><span class="line">rl-&gt;_currentMode = previousMode;</span><br><span class="line">    __CFRunLoopUnlock(rl);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用细节<br><strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION</strong><br><em>_CFRUNLOOP_IS_CALLING_OUT_TO</em><br>…</p><p>GCD的很多流程是不依赖RunLoop的，除了<code>dispatch_async(dispatch_get_main_queue(), ^{});</code></p><p>休眠细节<br><img src="https://cdn.ticsmatic.com/img/2020-06-02/15910863645795.png" alt="RunLoop休眠的实现原理"><br>线程休眠，操作系统内核层面API才能实现，实现：<code>mach_msg</code>函数<br>用户态、内核态（操作系统的知识稍微补一下）<br>等待消息<br>没有消息就让线程休眠<br>有消息就唤醒线程</p><p>状态<br>活动名状态</p><p>模式<br>两种，执行时互相隔离，互不影响</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="控制线程的生命周期（线程保活）"><a href="#控制线程的生命周期（线程保活）" class="headerlink" title="控制线程的生命周期（线程保活）"></a>控制线程的生命周期（线程保活）</h3><p>线程是默认执行完里面的任务后就会被自动销毁，有些场景需要经常在子线程做事情，但是一做完就销毁了，再次使用还要创建，频繁的创建销毁时比较浪费的。AFN避免线程频繁创建销毁，<strong>使用RunLoop来使线程做完事情后以休眠态阻塞线程，避免被销毁，达到保活的效果</strong>。</p><h4 id="保活基础代码"><a href="#保活基础代码" class="headerlink" title="保活基础代码"></a>保活基础代码</h4><p>如果Mode里没有任何Source0/Source1/Timer/Observer，RunLoop会立马退出</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 往RunLoop里面添加Source\Timer\Observer</span></span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addPort:[[<span class="built_in">NSPort</span> alloc] init] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] run];</span><br></pre></td></tr></table></figure><p><code>touchesBegan</code>时让子线程做事情，完整代码如下</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    MJThread *thread = [[MJThread alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run) object:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">    [thread start];</span><br><span class="line">    <span class="keyword">self</span>.thread = thread;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="comment">// 让线程做事情，RunLoop检测到performSelector:onThread:withObject会醒过来干活</span></span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(test) onThread:<span class="keyword">self</span>.thread withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">YES</span>];</span><br><span class="line">    <span class="comment">// 在子线程调用stop（waitUntilDone设置为YES，代表子线程的代码执行完毕后，这个方法才会往下走）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - Action</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)run &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"start --%s"</span>, __func__);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 往RunLoop里面添加Source\Timer\Observer</span></span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> currentRunLoop] addPort:[[<span class="built_in">NSPort</span> alloc] init] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> currentRunLoop] run];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"end --%s"</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子线程需要执行的任务</span></span><br><span class="line">- (<span class="keyword">void</span>)test &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>上面的代码，<code>[MJThread alloc] initWithTarget:self</code> thread会强引用target</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MJThread *thread = [[MJThread alloc] initWithBlock:^&#123;</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"start --%s"</span>, __func__);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 往RunLoop里面添加Source\Timer\Observer</span></span><br><span class="line">      [[<span class="built_in">NSRunLoop</span> currentRunLoop] addPort:[[<span class="built_in">NSPort</span> alloc] init] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">      [[<span class="built_in">NSRunLoop</span> currentRunLoop] run];</span><br><span class="line">      </span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"end --%s"</span>, __func__);</span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure><p>此时控制器可以正常销毁，但是线程还没销毁<br>因为线程里面的block任务还没执行完毕，<code>NSLog(@&quot;end --%s&quot;, __func__);</code>还没执行</p><p>run的注释<br><img src="https://cdn.ticsmatic.com/img/2020-06-02/15910665640286.png" alt="run注释"></p><p>run是个无限循环，想停止的话只能使用如下方法<br>解决如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">MJThread *thread = [[MJThread alloc] initWithBlock:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"start --%s"</span>, __func__);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 往RunLoop里面添加Source\Timer\Observer</span></span><br><span class="line">    <span class="built_in">NSRunLoop</span> *theRL = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line">    [theRL addPort:[[<span class="built_in">NSPort</span> alloc] init] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">    <span class="keyword">while</span> (weakSelf.shouldKeepRunning) &#123;</span><br><span class="line">        [theRL runMode:<span class="built_in">NSDefaultRunLoopMode</span> beforeDate:[<span class="built_in">NSDate</span> distantFuture]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"end --%s"</span>, __func__);</span><br><span class="line">&#125;];</span><br><span class="line">[thread start];</span><br></pre></td></tr></table></figure><p>在需要销毁时把<code>shouldKeepRunning</code>修改为NO</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">IBAction</span>)stop:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(stopRunLoop) onThread:<span class="keyword">self</span>.thread withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)stopRunLoop &#123;</span><br><span class="line">    <span class="keyword">self</span>.shouldKeepRunning = <span class="literal">NO</span>;</span><br><span class="line">    <span class="built_in">CFRunLoopStop</span>(<span class="built_in">CFRunLoopGetCurrent</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 创建上下文（要初始化一下结构体）</span></span><br><span class="line"><span class="built_in">CFRunLoopSourceContext</span> context = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 创建source</span></span><br><span class="line"><span class="built_in">CFRunLoopSourceRef</span> source = <span class="built_in">CFRunLoopSourceCreate</span>(kCFAllocatorDefault, <span class="number">0</span>, &amp;context);</span><br></pre></td></tr></table></figure><p>这就是封装后的</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MJPermenantThread</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - public methods</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.innerThread = [[MJThread alloc] initWithBlock:^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"begin----"</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 创建上下文（要初始化一下结构体）</span></span><br><span class="line">            <span class="built_in">CFRunLoopSourceContext</span> context = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 创建source</span></span><br><span class="line">            <span class="built_in">CFRunLoopSourceRef</span> source = <span class="built_in">CFRunLoopSourceCreate</span>(kCFAllocatorDefault, <span class="number">0</span>, &amp;context);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 往Runloop中添加source</span></span><br><span class="line">            <span class="built_in">CFRunLoopAddSource</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), source, kCFRunLoopDefaultMode);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 销毁source</span></span><br><span class="line">            <span class="built_in">CFRelease</span>(source);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 启动</span></span><br><span class="line">            <span class="built_in">CFRunLoopRunInMode</span>(kCFRunLoopDefaultMode, <span class="number">1.0e10</span>, <span class="literal">false</span>);</span><br><span class="line">            </span><br><span class="line"><span class="comment">//            while (weakSelf &amp;&amp; !weakSelf.isStopped) &#123;</span></span><br><span class="line"><span class="comment">//                // 第3个参数：returnAfterSourceHandled，设置为true，代表执行完source后就会退出当前loop</span></span><br><span class="line"><span class="comment">//                CFRunLoopRunInMode(kCFRunLoopDefaultMode, 1.0e10, true);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">            </span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"end----"</span>);</span><br><span class="line">        &#125;];</span><br><span class="line">        </span><br><span class="line">        [<span class="keyword">self</span>.innerThread start];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//- (void)run</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//    if (!self.innerThread) return;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    [self.innerThread start];</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)executeTask:(MJPermenantThreadTask)task</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.innerThread || !task) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(__executeTask:) onThread:<span class="keyword">self</span>.innerThread withObject:task waitUntilDone:<span class="literal">NO</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)stop</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.innerThread) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(__stop) onThread:<span class="keyword">self</span>.innerThread withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> stop];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - private methods</span></span><br><span class="line">- (<span class="keyword">void</span>)__stop</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CFRunLoopStop</span>(<span class="built_in">CFRunLoopGetCurrent</span>());</span><br><span class="line">    <span class="keyword">self</span>.innerThread = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)__executeTask:(MJPermenantThreadTask)task</span><br><span class="line">&#123;</span><br><span class="line">    task();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="解决NSTimer在滑动时停止工作的问题"><a href="#解决NSTimer在滑动时停止工作的问题" class="headerlink" title="解决NSTimer在滑动时停止工作的问题"></a>解决NSTimer在滑动时停止工作的问题</h3><p>RunLoop只能处于某一种模式，默认模式，拖拽时切换到另一种模式，所以NSTimer的默认模式消失<br><strong>NSRunLoopCommonModes并不是一个真的模式，它只是一个标记</strong>，timer能在_commonModes数组中存放的模式下工作</p><p>RunLoop里面放的有模式，模式里面放的有timers，timer设置为commonmodes时会添加到runloop的_commonModeitems<br>timer工作：在runloop的执行流程中工作，timer能唤醒RunLoop</p><h3 id="监控应用卡顿"><a href="#监控应用卡顿" class="headerlink" title="监控应用卡顿"></a>监控应用卡顿</h3><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>Runloop循环处理当前模式下的source0、source1、timers、observes</strong></p><h2 id="参考和源码"><a href="#参考和源码" class="headerlink" title="参考和源码"></a>参考和源码</h2><p>源码：<br><a href="https://opensource.apple.com/tarballs/CF/" target="_blank" rel="noopener">CF源码</a></p><p>参考：<br><a href="https://dnduuhn.com/2018/12/15/iOS-Runloop%E4%B8%8E%E7%BA%BF%E7%A8%8B%E4%BF%9D%E6%B4%BB/" target="_blank" rel="noopener">iOS Runloop与线程保活</a><br><a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">深入理解RunLoop</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>队列组、自旋锁</title>
      <link href="/p/9aa1f76b/"/>
      <url>/p/9aa1f76b/</url>
      
        <content type="html"><![CDATA[<p>学习MJ的视频课程，整理总结知识点–队列组、自旋锁</p><a id="more"></a><p>面试题一：子线程添加timer会不执行</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="string">@"1"</span>);</span><br><span class="line">        <span class="comment">// 这句代码的本质是往Runloop中添加定时器</span></span><br><span class="line">        [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(log2func) withObject:<span class="literal">nil</span> afterDelay:<span class="number">.0</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="string">@"3"</span>);</span><br><span class="line">        <span class="comment">// [[NSRunLoop currentRunLoop] run]; 子线程默认不启动RunLoop，需要启动RunLoop，log2func才会执行</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)log2func &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="string">@"2"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：打印“1 3”<br>一句话概括原因：performSelector:withObject:afterDelay是RunLoop中的代码，依靠RunLoop来执行，而子线程没有RunLoop或者子线程RunLoop没有启动</p><p><code>performSelector:withObject:afterDelay</code>是RunLoop中的代码<br>底层用到了定时器、定时器添加到RunLoop里的，RunLoop被唤醒时才会处理timer任务，异步线程不执行timer是因为子线程RunLoop没有启动（需要启动RunLoop）<code>[[NSRunLoop currentRunLoop] run];</code></p><p>面试题二：没有RunLoop，子线程执行完就会自动退出</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSThread</span> *thread = [[<span class="built_in">NSThread</span> alloc] initWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"1"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 为RunLoop添加Source1</span></span><br><span class="line">        <span class="comment">// [[NSRunLoop currentRunLoop] addPort:[[NSPort alloc] init] forMode:NSDefaultRunLoopMode];</span></span><br><span class="line">        <span class="comment">// 启动RunLoop保证线程不退出</span></span><br><span class="line">        <span class="comment">// [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];</span></span><br><span class="line">    &#125;];</span><br><span class="line">    [thread start];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(test) onThread:thread withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">YES</span>];</span><br></pre></td></tr></table></figure><p>performSelector:onThread:withObject:waitUntilDone:是通过RunLoop来处理的，子线程默认没有RunLoop，此时子线程内任务执行完就自动退出了，再执行<code>test</code>函数会崩溃。<br>除非子线程内启动了RunLoop</p><p>两个函数的对比：<br><code>performSelector:withObject:</code> 调用的底层msgSend<br><code>performSelector:withObject:afterDelay</code> 调用的底层是RunLoop中的API<br>两者调用的本质不太一样</p><p>RunLoop源码不开放，但是有组织用自己的方式实现了一遍Cocoa的源码，就是<code>GNUstep</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">GNUstep是GNU计划的项目之一，它将Cocoa的OC库重新开源实现了一遍</span><br><span class="line">源码地址：http:&#x2F;&#x2F;www.gnustep.org&#x2F;resources&#x2F;downloads.php</span><br><span class="line">虽然GNUstep不是苹果官方源码，但还是具有一定的参考价值</span><br><span class="line">&#96;&#96;&#96; </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">## 队列组的使用</span><br><span class="line">思考：如何用gcd实现以下功能：</span><br><span class="line">异步并发执行任务：1、任务2，等任务1、任务2都执行完毕后，再回到主线程执行任务3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;objc</span><br><span class="line">&#x2F;&#x2F; 创建队列组</span><br><span class="line">dispatch_group_t group &#x3D; dispatch_group_create();</span><br><span class="line">&#x2F;&#x2F; 创建并发队列</span><br><span class="line">dispatch_queue_t queue &#x3D; dispatch_queue_create(&quot;my_queue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F; 添加异步任务</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">        NSLog(@&quot;任务1-%@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">        NSLog(@&quot;任务2-%@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F; 等前面的任务执行完毕后，会自动执行这个任务</span><br><span class="line">dispatch_group_notify(group, queue, ^&#123;</span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">            NSLog(@&quot;任务3-%@&quot;, [NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line">dispatch_group_notify(group, queue, ^&#123;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">        NSLog(@&quot;任务3-%@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line">dispatch_group_notify(group, queue, ^&#123;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">        NSLog(@&quot;任务4-%@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h2><p>卖票问题、存取钱问题</p><p>解决方案：使用<strong>线程同步</strong>技术（同步，就是协同步调，按预定的先后次序进行）<br>常见的线程同步技术是：加锁</p><p><img src="https://cdn.ticsmatic.com/img/2020-06-05/15913213956242.png" alt="ee51c443-f226-4d1a-99e2-4f81d41e9b21"></p><p><img src="https://cdn.ticsmatic.com/img/2020-06-05/15913213992118.png" alt="bdbe50f5-99d9-4211-ad90-3b0e979f1f92"></p><h2 id="线程安全问题解决"><a href="#线程安全问题解决" class="headerlink" title="线程安全问题解决"></a>线程安全问题解决</h2><p>解决方案：加锁</p><p>iOS中常用的锁有</p><ul><li>OSSpinLock</li><li>os_unfair_lock</li><li>pthread_mutex</li><li>dispatch_semaphore</li><li>dispatch_queue(DISPATCH_QUEUE_SERIAL)</li><li>NSLock</li><li>NSRecursiveLock</li><li>NSCondition</li><li>NSConditionLock</li><li>@synchronized</li></ul><h3 id="OSSpinLock"><a href="#OSSpinLock" class="headerlink" title="OSSpinLock"></a>OSSpinLock</h3><p><img src="https://cdn.ticsmatic.com/img/2020-06-05/15913623075993.png" alt="OSSpinLock"></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> OSSpinLock moneyLock = OS_SPINLOCK_INIT;</span><br><span class="line">- (<span class="keyword">void</span>)saveMoney &#123;</span><br><span class="line">    OSSpinLockLock(&amp;moneyLock);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSInteger</span> oldMoney = money;</span><br><span class="line">    sleep(<span class="number">.2</span>);</span><br><span class="line">    oldMoney += <span class="number">50</span>;</span><br><span class="line">    money = oldMoney;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"存50，还剩%ld元 - %@"</span>, oldMoney, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    OSSpinLockUnlock(&amp;moneyLock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要用同一把锁（锁被加了的标记，有标记就不进去执行了，等待这个锁被解标记后才能进去执行）</p><p>等待锁的线程会处于忙等，一致占用cpu资源，while等待</p><p>thread1<br>thread2<br>thread3<br>线程的调度<br>时间片轮训<br>线程优先级高的话，会分配的时间片更多</p><p>导致OSSpinLock的问题问题：优先级反转<br>如果等待锁的线程优先级较高，它会一直占用着CPU资源，优先级低的线程就无法释放锁<br>（因为它是占用cpu忙等，所以执行效率是比较高的）</p><h4 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h4><p>通过汇编查看<br><code>stepinstruction、stepi、si</code></p><h3 id="os-unfair-lock"><a href="#os-unfair-lock" class="headerlink" title="os_unfair_lock"></a>os_unfair_lock</h3><p>iOS10 API_AVAILABLE<br>和OSSpinLock的使用方式非常像<br>Low-level lock 等待过程中会休眠，自旋锁不是，等待时是一直占用cpu等<br><img src="https://cdn.ticsmatic.com/img/2020-06-05/15913623213807.png" alt="os_unfair_lock"></p><p>通过汇编查看<br><code>stepinstruction、stepi、si</code></p><h3 id="pthread-mutex"><a href="#pthread-mutex" class="headerlink" title="pthread_mutex"></a>pthread_mutex</h3><p>mutex叫做”互斥锁”，等待锁的线程会处于休眠状态<br><img src="https://cdn.ticsmatic.com/img/2020-06-05/15913623283072.png" alt="pthread_mutex"></p><h3 id="递归锁"><a href="#递归锁" class="headerlink" title="递归锁"></a>递归锁</h3><p>一个函数内加锁，内部调用另一个函数，这个函数内也加同样的锁，结果会出现死锁<br>递归函数也会出现同样的问题<br>解决：使用递归锁<br>递归锁：允许同一个线程对一把锁进行重复加锁</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化属性</span></span><br><span class="line">pthread_mutexattr_t attr;</span><br><span class="line">pthread_mutexattr_init(&amp;attr);</span><br><span class="line">pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE);</span><br><span class="line"><span class="comment">// 初始化锁</span></span><br><span class="line">pthread_mutex_init(mutex, &amp;attr);</span><br><span class="line"><span class="comment">// 销毁属性</span></span><br><span class="line">pthread_mutexattr_destroy(&amp;attr);</span><br></pre></td></tr></table></figure><p><strong>递归锁可以对同一把锁重复加锁，但是重复加锁仅限同一个线程，重复加锁最终也都会做同样次数的释放锁</strong>。<br>当第二个线程进来发现已经加锁时，就等待之前的线程释放锁</p><h4 id="条件锁"><a href="#条件锁" class="headerlink" title="条件锁"></a>条件锁</h4><p><img src="https://cdn.ticsmatic.com/img/2020-06-05/15913673443842.png" alt="条件"><br>// 等待<br>pthread_cond_wait(&amp;_cond, &amp;_mutex);<br>// 信号<br>pthread_cond_signal(&amp;_cond);</p><p>执行流程：<br>pthread_cond_wait睡眠等待、释放锁，等signal条件唤醒<br>signal条件唤醒，解锁完成，等待的线程重新加锁，继续往下执行，完成后解锁</p><p>使用场景：<br><strong>线程依赖的实现</strong></p><h3 id="NSLock、NSRecursiveLock"><a href="#NSLock、NSRecursiveLock" class="headerlink" title="NSLock、NSRecursiveLock"></a>NSLock、NSRecursiveLock</h3><p><strong>NSLock是对mutex普通锁的封装</strong><br><strong>NSRecursiveLock也是对mutex递归锁的封装，API跟NSLock基本一致</strong><br><img src="https://cdn.ticsmatic.com/img/2020-06-06/15914046665943.png" alt="NSLock、NSRecursiveLock"></p><h3 id="NSCondition"><a href="#NSCondition" class="headerlink" title="NSCondition"></a>NSCondition</h3><p>条件锁<br><strong>NSCondition是对mutex和cond的封装</strong><br><img src="https://cdn.ticsmatic.com/img/2020-06-06/15914067316938.png" alt="屏幕快照 2020-06-06 上午9.19.35"></p><h3 id="NSConditionLock"><a href="#NSConditionLock" class="headerlink" title="NSConditionLock"></a>NSConditionLock</h3><p><strong>NSConditionLock是对NSCondition的进一步封装，可以设置具体的条件值</strong><br><strong>可以设置只有满足条件才加锁</strong>，真正使用的场景不多<br><img src="https://cdn.ticsmatic.com/img/2020-06-06/15914122280988.png" alt="NSConditionLock"></p><h3 id="dispatch-queue-DISPATCH-QUEUE-SERIAL"><a href="#dispatch-queue-DISPATCH-QUEUE-SERIAL" class="headerlink" title="dispatch_queue(DISPATCH_QUEUE_SERIAL)"></a>dispatch_queue(DISPATCH_QUEUE_SERIAL)</h3><p>串行队列，让队列中的任务串行执行，防止并发访问的安全问题。也就是多线程中的任务串行执行</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.ticketQueue = dispatch_queue_create(<span class="string">"ticketQueue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">        <span class="keyword">self</span>.moneyQueue = dispatch_queue_create(<span class="string">"moneyQueue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)__drawMoney &#123;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(<span class="keyword">self</span>.moneyQueue, ^&#123;</span><br><span class="line">        [<span class="keyword">super</span> __drawMoney];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)__saveMoney &#123;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(<span class="keyword">self</span>.moneyQueue, ^&#123;</span><br><span class="line">        [<span class="keyword">super</span> __saveMoney];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.ticsmatic.com/img/2020-06-08/15916147676787.png" alt="dispatch_queue"></p><h3 id="semaphore"><a href="#semaphore" class="headerlink" title="semaphore"></a>semaphore</h3><p>semaphore叫做”信号量”<br>信号量的初始值，可以用来控制线程并发访问的最大数量<br>信号量的初始值为1，代表同时只允许1条线程访问资源，保证线程同步<br><img src="https://cdn.ticsmatic.com/img/2020-06-08/15916147309748.png" alt="semaphore"></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> dispatch_semaphore_t semaphore;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line"><span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">    semaphore = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">dispatch_semaphore_signal(semaphore);</span><br></pre></td></tr></table></figure><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="@synchronized"></a>@synchronized</h3><p>@synchronized是对mutex递归锁的封装<br>源码查看：objc4中的objc-sync.mm文件<br>@synchronized(obj)内部会生成obj对应的递归锁，然后进行加锁、解锁操作</p><p><img src="https://cdn.ticsmatic.com/img/2020-06-08/15916148015276.png" alt="@synchronized"></p><p>选择对象<br>self、类对象、oncelock对象</p><h2 id="iOS线程同步方案性能比较"><a href="#iOS线程同步方案性能比较" class="headerlink" title="iOS线程同步方案性能比较"></a>iOS线程同步方案性能比较</h2><p>性能从高到低排序<br>os_unfair_lock<br>OSSpinLock<br>dispatch_semaphore<br>pthread_mutex<br>dispatch_queue(DISPATCH_QUEUE_SERIAL)<br>NSLock<br>NSCondition<br>pthread_mutex(recursive)<br>NSRecursiveLock<br>NSConditionLock<br>@synchronized</p><h2 id="自旋锁、互斥锁比较"><a href="#自旋锁、互斥锁比较" class="headerlink" title="自旋锁、互斥锁比较"></a>自旋锁、互斥锁比较</h2><p>什么情况使用自旋锁比较划算？<br>预计线程等待锁的时间很短<br>加锁的代码（临界区）经常被调用，但竞争情况很少发生<br>CPU资源不紧张<br>多核处理器</p><p>什么情况使用互斥锁比较划算？<br>预计线程等待锁的时间较长<br>单核处理器<br>临界区有IO操作<br>临界区代码复杂或者循环量大<br>临界区竞争非常激烈</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>os_unfair_lock iOS10<br>dispatch_semaphore 多样性<br>pthread_mutex 跨平台 多样性</p><h2 id="参考和源码"><a href="#参考和源码" class="headerlink" title="参考和源码"></a>参考和源码</h2><p>源码：</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Runtime API</title>
      <link href="/p/78c95faf/"/>
      <url>/p/78c95faf/</url>
      
        <content type="html"><![CDATA[<p>学习MJ的视频课程，整理总结知识点–Runtime API</p><p>本文主要简单介绍Runtime常用的一些API，相关的API包括类、成员变量、属性、方法等。另，文章前面已介绍不少Runtime的API，这里不再重复</p><a id="more"></a><h2 id="中间代码"><a href="#中间代码" class="headerlink" title="中间代码"></a>中间代码</h2><p>先补充一些知识点，关于查看OC代码转换后的底层实现的手段</p><ol><li>通过clang转换为cpp文件<br>用于查看OC代码转化的C、C++代码，导出的一般是编译阶段的代码，和运行时真实调用的底层代码可能会有细小的差异，可以用于参考，但是代码逻辑基本上一致，可以用于分析OC的底层实现。</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSendSuper(&#123;<span class="keyword">self</span>, class_getSuperclass(objc_getClass(<span class="string">"MJPerson"</span>))&#125;, <span class="keyword">@selector</span>(forwardInvocation:), anInvocation);</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> c = a + b;</span><br><span class="line">test(c);</span><br></pre></td></tr></table></figure><ol><li>Xcode断点Debug选择<code>Always Show Disassembly</code>查看运行阶段的汇编代码</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x100000e8e</span> &lt;+<span class="number">62</span>&gt;:  movq   <span class="number">0x29b</span>(%rip), %rdx         ; <span class="string">"forwardInvocation:"</span></span><br><span class="line"><span class="number">0x100000e95</span> &lt;+<span class="number">69</span>&gt;:  leaq   <span class="number">-0x28</span>(%rbp), %rdi</span><br><span class="line"><span class="number">0x100000e99</span> &lt;+<span class="number">73</span>&gt;:  movq   %rsi, <span class="number">-0x40</span>(%rbp)</span><br><span class="line"><span class="number">0x100000e9d</span> &lt;+<span class="number">77</span>&gt;:  movq   %rdx, %rsi</span><br><span class="line"><span class="number">0x100000ea0</span> &lt;+<span class="number">80</span>&gt;:  movq   <span class="number">-0x40</span>(%rbp), %rdx</span><br><span class="line"><span class="number">0x100000ea4</span> &lt;+<span class="number">84</span>&gt;:  callq  <span class="number">0x100000ef0</span>               ; symbol stub <span class="keyword">for</span>: objc_msgSendSuper2</span><br><span class="line"><span class="number">0x100000ea9</span> &lt;+<span class="number">89</span>&gt;:  movl   $<span class="number">0xa</span>, <span class="number">-0x2c</span>(%rbp)</span><br><span class="line"><span class="number">0x100000eb0</span> &lt;+<span class="number">96</span>&gt;:  movl   $<span class="number">0x14</span>, <span class="number">-0x30</span>(%rbp)</span><br></pre></td></tr></table></figure><ol><li>Xcode选择<code>Product</code> -&gt; Assembly xx文件，转成汇编<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.loc<span class="number">2</span> <span class="number">29</span> <span class="number">5</span>                  ## Interview01-<span class="keyword">super</span>/MJPerson.m:<span class="number">29</span>:<span class="number">5</span></span><br><span class="line">movq%rdx, <span class="number">-40</span>(%rbp)</span><br><span class="line">movqL_OBJC_CLASSLIST_SUP_REFS_$_(%rip), %rdx</span><br><span class="line">movq%rdx, <span class="number">-32</span>(%rbp)</span><br><span class="line">movqL_OBJC_SELECTOR_REFERENCES_<span class="number">.2</span>(%rip), %rdx</span><br><span class="line">leaq<span class="number">-40</span>(%rbp), %rdi</span><br><span class="line">movq%rsi, <span class="number">-64</span>(%rbp)         ## <span class="number">8</span>-byte Spill</span><br><span class="line">movq%rdx, %rsi</span><br><span class="line">movq<span class="number">-64</span>(%rbp), %rdx         ## <span class="number">8</span>-byte Reload</span><br><span class="line">callq_objc_msgSendSuper2</span><br></pre></td></tr></table></figure>4、clang导出中间代码<br>苹果是通过LLVM把OC代码转成最终执行的机器码，大致过程<code>OC -&gt; 中间代码 -&gt; 机器码</code><br>LLVM跨平台的，汇编、机器码是区分平台的</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">define internal <span class="keyword">void</span> <span class="string">@"\01-[MJPerson forwardInvocation:]"</span>(%<span class="number">0</span>*, i8*, %<span class="number">1</span>*) #<span class="number">1</span> &#123;</span><br><span class="line">%<span class="number">4</span> = alloca %<span class="number">0</span>*, align <span class="number">8</span></span><br><span class="line">%<span class="number">5</span> = alloca i8*, align <span class="number">8</span></span><br><span class="line">%<span class="number">6</span> = alloca %<span class="number">1</span>*, align <span class="number">8</span></span><br><span class="line">%<span class="number">7</span> = alloca %<span class="keyword">struct</span>._objc_super, align <span class="number">8</span></span><br><span class="line">%<span class="number">8</span> = alloca i32, align <span class="number">4</span></span><br><span class="line">%<span class="number">9</span> = alloca i32, align <span class="number">4</span></span><br><span class="line">%<span class="number">10</span> = alloca i32, align <span class="number">4</span></span><br><span class="line">store %<span class="number">0</span>* %<span class="number">0</span>, %<span class="number">0</span>** %<span class="number">4</span>, align <span class="number">8</span></span><br><span class="line">store i8* %<span class="number">1</span>, i8** %<span class="number">5</span>, align <span class="number">8</span></span><br><span class="line">store %<span class="number">1</span>* %<span class="number">2</span>, %<span class="number">1</span>** %<span class="number">6</span>, align <span class="number">8</span></span><br><span class="line">%<span class="number">11</span> = load %<span class="number">0</span>*, %<span class="number">0</span>** %<span class="number">4</span>, align <span class="number">8</span></span><br><span class="line">%<span class="number">12</span> = load %<span class="number">1</span>*, %<span class="number">1</span>** %<span class="number">6</span>, align <span class="number">8</span></span><br><span class="line">%<span class="number">13</span> = bitcast %<span class="number">0</span>* %<span class="number">11</span> to i8*</span><br><span class="line">%<span class="number">14</span> = getelementptr inbounds %<span class="keyword">struct</span>._objc_super, %<span class="keyword">struct</span>._objc_super* %<span class="number">7</span>, i32 <span class="number">0</span>, i32 <span class="number">0</span></span><br><span class="line">store i8* %<span class="number">13</span>, i8** %<span class="number">14</span>, align <span class="number">8</span></span><br><span class="line">%<span class="number">15</span> = load %<span class="keyword">struct</span>._class_t*, %<span class="keyword">struct</span>._class_t** <span class="string">@"OBJC_CLASSLIST_SUP_REFS_$_"</span>, align <span class="number">8</span></span><br><span class="line">%<span class="number">16</span> = bitcast %<span class="keyword">struct</span>._class_t* %<span class="number">15</span> to i8*</span><br><span class="line">%<span class="number">17</span> = getelementptr inbounds %<span class="keyword">struct</span>._objc_super, %<span class="keyword">struct</span>._objc_super* %<span class="number">7</span>, i32 <span class="number">0</span>, i32 <span class="number">1</span></span><br><span class="line">store i8* %<span class="number">16</span>, i8** %<span class="number">17</span>, align <span class="number">8</span></span><br><span class="line">%<span class="number">18</span> = load i8*, i8** @OBJC_SELECTOR_REFERENCES_, align <span class="number">8</span>, !invariant.load !<span class="number">8</span></span><br><span class="line">call <span class="keyword">void</span> bitcast (i8* (%<span class="keyword">struct</span>._objc_super*, i8*, ...)* @objc_msgSendSuper2 to <span class="keyword">void</span> (%<span class="keyword">struct</span>._objc_super*, i8*, %<span class="number">1</span>*)*)(%<span class="keyword">struct</span>._objc_super* %<span class="number">7</span>, i8* %<span class="number">18</span>, %<span class="number">1</span>* %<span class="number">12</span>)</span><br><span class="line">store i32 <span class="number">10</span>, i32* %<span class="number">8</span>, align <span class="number">4</span></span><br><span class="line">store i32 <span class="number">20</span>, i32* %<span class="number">9</span>, align <span class="number">4</span></span><br><span class="line">%<span class="number">19</span> = load i32, i32* %<span class="number">8</span>, align <span class="number">4</span></span><br><span class="line">%<span class="number">20</span> = load i32, i32* %<span class="number">9</span>, align <span class="number">4</span></span><br><span class="line">%<span class="number">21</span> = add nsw i32 %<span class="number">19</span>, %<span class="number">20</span></span><br><span class="line">store i32 %<span class="number">21</span>, i32* %<span class="number">10</span>, align <span class="number">4</span></span><br><span class="line">%<span class="number">22</span> = load i32, i32* %<span class="number">10</span>, align <span class="number">4</span></span><br><span class="line">call <span class="keyword">void</span> @test(i32 %<span class="number">22</span>)</span><br><span class="line">ret <span class="keyword">void</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Objective-C在变为机器代码之前，会被LLVM编译器转换为中间代码（Intermediate Representation）</p><p>可以使用以下命令行指令生成中间代码c<br>lang -emit-llvm -S main.m</p><p>语法简介<br>@ - 全局变量<br>% - 局部变量<br>alloca - 在当前执行的函数的堆栈帧中分配内存，当该函数返回到其调用者时，将自动释放内存<br>i32 - 32位4字节的整数<br>align - 对齐<br>load - 读出，<br>store 写入<br>icmp - 两个整数值比较，返回布尔值<br>br - 选择分支，根据条件来转向<br>label，不根据条件跳转的话类似<br>gotolabel - 代码标签<br>call - 调用函数</p><p>具体可以参考官方文档：<a href="https://llvm.org/docs/LangRef.html" target="_blank" rel="noopener">https://llvm.org/docs/LangRef.html</a></p><h2 id="Runtime-API-类"><a href="#Runtime-API-类" class="headerlink" title="Runtime API - 类"></a>Runtime API - 类</h2><p>动态创建一个类，添加属性，添加方法，注册类</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">MJPerson *person = [[MJPerson alloc] init];</span><br><span class="line">[person run];</span><br><span class="line">    </span><br><span class="line">object_setClass(person, [MJCar <span class="keyword">class</span>]);</span><br><span class="line">[person run];</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%d %d %d"</span>,</span><br><span class="line">      object_isClass(person),</span><br><span class="line">      object_isClass([MJPerson <span class="keyword">class</span>]),</span><br><span class="line">      object_isClass(object_getClass([MJPerson <span class="keyword">class</span>]))</span><br><span class="line">      );</span><br><span class="line">          </span><br><span class="line"><span class="comment">// 创建类</span></span><br><span class="line">Class newClass = objc_allocateClassPair([<span class="built_in">NSObject</span> <span class="keyword">class</span>], <span class="string">"MJDog"</span>, <span class="number">0</span>);</span><br><span class="line">class_addIvar(newClass, <span class="string">"_age"</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="keyword">@encode</span>(<span class="keyword">int</span>));</span><br><span class="line">class_addIvar(newClass, <span class="string">"_weight"</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="keyword">@encode</span>(<span class="keyword">int</span>));</span><br><span class="line">class_addMethod(newClass, <span class="keyword">@selector</span>(run), (IMP)run, <span class="string">"v@:"</span>);</span><br><span class="line"><span class="comment">// 注册类</span></span><br><span class="line">objc_registerClassPair(newClass);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 在不需要这个类时释放</span></span><br><span class="line">objc_disposeClassPair(newClass);</span><br></pre></td></tr></table></figure><h2 id="Runtime-API-成员变量"><a href="#Runtime-API-成员变量" class="headerlink" title="Runtime API - 成员变量"></a>Runtime API - 成员变量</h2><p><img src="https://cdn.ticsmatic.com/img/2020-05-30/15908415476447.png" alt="Runtime API - 类"></p><p><img src="https://cdn.ticsmatic.com/img/2020-05-30/15908415476514.png" alt="Runtime API - 成员变量"></p><p><img src="https://cdn.ticsmatic.com/img/2020-05-30/15908415476543.png" alt="Runtime API - 属性"></p><p><img src="https://cdn.ticsmatic.com/img/2020-05-30/15908415476566.png" alt="Runtime API - 方法"></p><p><img src="https://cdn.ticsmatic.com/img/2020-05-30/15908415476585.png" alt="Runtime API - 方法"></p><h2 id="应用-找textfiled"><a href="#应用-找textfiled" class="headerlink" title="应用-找textfiled"></a>应用-找textfiled</h2><p>Ivar *ivars<br>C语言取数据时数组和指针没什么区别<br>Ivar ivar = *(ivars + i)</p><h2 id="Runtime实现字典转模型"><a href="#Runtime实现字典转模型" class="headerlink" title="Runtime实现字典转模型"></a>Runtime实现字典转模型</h2><p>ivarlist</p><h2 id="Runtime-API-–-方法"><a href="#Runtime-API-–-方法" class="headerlink" title="Runtime API – 方法"></a>Runtime API – 方法</h2><p>拦截所有按钮的点击事件<br>方法交换，交换的是class_rw_t-&gt;methods-&gt;method_lsit(method_t)-&gt;imp</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIControl</span> (<span class="title">Extension</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    <span class="comment">// hook：钩子函数</span></span><br><span class="line">    Method method1 = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(sendAction:to:forEvent:));</span><br><span class="line">    Method method2 = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(mj_sendAction:to:forEvent:));</span><br><span class="line">    method_exchangeImplementations(method1, method2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)mj_sendAction:(SEL)action to:(<span class="keyword">id</span>)target forEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@-%@-%@"</span>, <span class="keyword">self</span>, target, <span class="built_in">NSStringFromSelector</span>(action));</span><br><span class="line">    <span class="comment">// 调用系统原来的实现</span></span><br><span class="line">    [<span class="keyword">self</span> mj_sendAction:action to:target forEvent:event];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>NSMutableArray数据插空处理</p><p>类簇：NSString、NSArray、NSDictionary，真实类型是其他类型</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSMutableArray</span> (<span class="title">Extension</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        <span class="comment">// 类簇：NSString、NSArray、NSDictionary，真实类型是其他类型</span></span><br><span class="line">        Class cls = <span class="built_in">NSClassFromString</span>(<span class="string">@"__NSArrayM"</span>);</span><br><span class="line">        Method method1 = class_getInstanceMethod(cls, <span class="keyword">@selector</span>(insertObject:atIndex:));</span><br><span class="line">        Method method2 = class_getInstanceMethod(cls, <span class="keyword">@selector</span>(mj_insertObject:atIndex:));</span><br><span class="line">        method_exchangeImplementations(method1, method2);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)mj_insertObject:(<span class="keyword">id</span>)anObject atIndex:(<span class="built_in">NSUInteger</span>)index &#123;</span><br><span class="line">    <span class="keyword">if</span> (anObject == <span class="literal">nil</span>) <span class="keyword">return</span>;</span><br><span class="line">    [<span class="keyword">self</span> mj_insertObject:anObject atIndex:index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>字典</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSMutableDictionary</span> (<span class="title">Extension</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        Class cls = <span class="built_in">NSClassFromString</span>(<span class="string">@"__NSDictionaryM"</span>);</span><br><span class="line">        Method method1 = class_getInstanceMethod(cls, <span class="keyword">@selector</span>(setObject:forKeyedSubscript:));</span><br><span class="line">        Method method2 = class_getInstanceMethod(cls, <span class="keyword">@selector</span>(mj_setObject:forKeyedSubscript:));</span><br><span class="line">        method_exchangeImplementations(method1, method2);</span><br><span class="line">        </span><br><span class="line">        Class cls2 = <span class="built_in">NSClassFromString</span>(<span class="string">@"__NSDictionaryI"</span>);</span><br><span class="line">        Method method3 = class_getInstanceMethod(cls2, <span class="keyword">@selector</span>(objectForKeyedSubscript:));</span><br><span class="line">        Method method4 = class_getInstanceMethod(cls2, <span class="keyword">@selector</span>(mj_objectForKeyedSubscript:));</span><br><span class="line">        method_exchangeImplementations(method3, method4);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)mj_setObject:(<span class="keyword">id</span>)obj forKeyedSubscript:(<span class="keyword">id</span>&lt;<span class="built_in">NSCopying</span>&gt;)key &#123;</span><br><span class="line">    <span class="keyword">if</span> (!key) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> mj_setObject:obj forKeyedSubscript:key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)mj_objectForKeyedSubscript:(<span class="keyword">id</span>)key &#123;</span><br><span class="line">    <span class="keyword">if</span> (!key) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> mj_objectForKeyedSubscript:key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>fishhook</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>什么是Runtime？平时项目中有用过么？<br>OC是一门动态性比较强的编程语言，允许很多操作推迟到程序运行时再进行OC的动态性就是由Runtime来支撑和实现的，Runtime是一套C语言的API，封装了很多动态性相关的函数平时编写的OC代码，底层都是转换成了Runtime API进行调用</p><p>应用<br>关联对象给分类添加属性<br>获取遍历类的成员变量，修改私有变量<br>字典转模型、自动归档解档<br>交换方法实现（交换系统的方法，导航栏样式）<br>利用消息转发机制解决方法找不到的异常问题</p><h2 id="参考和源码"><a href="#参考和源码" class="headerlink" title="参考和源码"></a>参考和源码</h2><p>源码：</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>super、class面试题</title>
      <link href="/p/a123b137/"/>
      <url>/p/a123b137/</url>
      
        <content type="html"><![CDATA[<p>学习MJ的视频课程，整理总结知识点–super、class面试题</p><p>本文讲解super、class相关的一些面试题，利用底层的知识来分析讲解</p><a id="more"></a><h2 id="面试题01-super"><a href="#面试题01-super" class="headerlink" title="面试题01-super"></a>面试题01-super</h2><p>先看一段代码，同时附上了分析时的Demo<a href="https://cdn.ticsmatic.com/source/2020-05-26/diceng/day14/Interview05-super.zip" target="_blank" rel="noopener">Interview05-super</a></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MJPerson</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MJStudent</span> : <span class="title">MJPerson</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"[self class] = %@"</span>, [<span class="keyword">self</span> <span class="keyword">class</span>]);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"[self superclass] = %@"</span>, [<span class="keyword">self</span> superclass]);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"[super class] = %@"</span>, [<span class="keyword">super</span> <span class="keyword">class</span>]);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"[super superclass] = %@"</span>, [<span class="keyword">super</span> superclass]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问：打印结果是什么？<br>验证后的输出结果如下</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"[self class] = %@"</span>, [<span class="keyword">self</span> <span class="keyword">class</span>]);          <span class="comment">// MJStudent</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"[self superclass] = %@"</span>, [<span class="keyword">self</span> superclass]);<span class="comment">// MJPerson</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"[super class] = %@"</span>, [<span class="keyword">super</span> <span class="keyword">class</span>]);        <span class="comment">// MJStudent</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"[super superclass] = %@"</span>, [<span class="keyword">super</span> superclass]);<span class="comment">// MJPerson</span></span><br></pre></td></tr></table></figure><p>对于<code>[self class]</code>、<code>[self superclass]</code>的结果我们基本上没什么疑问，对于<code>[super class]</code>的结果，可能会觉得意外。</p><p>下面结合Demo以及编译后的源码分析为什么是这样。</p><p>先从简答的<code>super</code>调用分析，代码如下</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MJStudent</span></span></span><br><span class="line">- (<span class="keyword">void</span>)run &#123;</span><br><span class="line">    [<span class="keyword">super</span> run];   </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"MJStudet......."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>利用clang编译对应部分的源码，结果如下</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">((<span class="keyword">void</span> (*)(__rw_objc_super *, SEL))(<span class="keyword">void</span> *)objc_msgSendSuper)((__rw_objc_super)&#123;(<span class="keyword">id</span>)<span class="keyword">self</span>, (<span class="keyword">id</span>)class_getSuperclass(objc_getClass(<span class="string">"MJStudent"</span>))&#125;, sel_registerName(<span class="string">"run"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码进行格式优化后</span></span><br><span class="line">objc_msgSendSuper((__rw_objc_super)&#123;</span><br><span class="line">    (<span class="keyword">id</span>)<span class="keyword">self</span>,</span><br><span class="line">    (<span class="keyword">id</span>)class_getSuperclass(objc_getClass(<span class="string">"MJStudent"</span>))</span><br><span class="line">&#125;, <span class="keyword">@selector</span>(run));</span><br></pre></td></tr></table></figure><p>我们发现，<code>objc_msgSendSuper</code>的参数有两个，一个是结构体，一个是SEL，我们搜索源码发现这个结构体相关的代码</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Specifies the superclass of an instance. </span></span><br><span class="line"><span class="keyword">struct</span> objc_super &#123;</span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> _Nonnull <span class="keyword">id</span> receiver;</span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> _Nonnull Class super_class;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>objc_super</code>的结构和<code>__rw_objc_super</code>是一致的，其实它们两个也是等价的，只不过是程序在不同阶段的表现不同而已。</p><p>所以，可以整理出super方法调用对应的源码</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_super &#123;</span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> _Nonnull <span class="keyword">id</span> receiver; <span class="comment">// 消息接收者</span></span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> _Nonnull Class super_class; <span class="comment">// 消息接收者的父类</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)run &#123;</span><br><span class="line">    [<span class="keyword">super</span> run];</span><br><span class="line">    <span class="comment">// 等价源码如下</span></span><br><span class="line">    <span class="comment">// struct objc_super arg = &#123;self, [MJPerson class]&#125;;</span></span><br><span class="line">    <span class="comment">// objc_msgSendSuper(arg, @selector(run));</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>objc_super</code>中的<code>receiver</code>消息接受者是<code>self</code>，即<code>[super run]</code>中super调用的receiver仍然是<code>MJStudent</code>对象。</strong></p><p>下面的关键就是看<code>objc_msgSendSuper</code>的实现，但是这部分是汇编代码，不过能看到它的注释，写的也很清晰，如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** </span><br><span class="line"> * Sends a message with a simple return value to the superclass of an instance of a class.</span><br><span class="line"> * </span><br><span class="line"> * @param super A pointer to an \c objc_super data structure. Pass values identifying the</span><br><span class="line"> *  context the message was sent to, including the instance of the class that is to receive the</span><br><span class="line"> *  message and the superclass at which to start searching for the method implementation.</span><br><span class="line"> * @param op A pointer of type SEL. Pass the selector of the method that will handle the message.</span><br><span class="line"> * @param ...</span><br><span class="line"> *   A variable argument list containing the arguments to the method.</span><br><span class="line"> * </span><br><span class="line"> * @return The return value of the method identified by \e op.</span><br><span class="line"> * </span><br><span class="line"> * @see objc_msgSend</span><br><span class="line"> *&#x2F;</span><br><span class="line">OBJC_EXPORT id _Nullable</span><br><span class="line">objc_msgSendSuper(struct objc_super * _Nonnull super, SEL _Nonnull op, ...)</span><br><span class="line">    OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0);</span><br></pre></td></tr></table></figure><p><strong>这段注释也说明<code>[super message]</code>的底层实现原理</strong></p><ol><li>消息接收者仍然是子类对象</li><li>从父类开始查找方法的实现</li></ol><p>分析完后，继续回到<code>[super class]</code>这段代码</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"[super class] = %@"</span>, [<span class="keyword">super</span> <span class="keyword">class</span>]);</span><br></pre></td></tr></table></figure><p>结合上面的super分析，我们可知<code>[super class]</code>这个方法的接受者仍然是当前的子类对象(<code>MJStudent</code>)。</p><p>对于<code>-class</code>方法，结合我们在<code>object_getClass</code>所学的知识，它的实现如下</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (Class)<span class="keyword">class</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> object_getClass(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (Class)superclass &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> <span class="keyword">class</span>]-&gt;superclass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以<code>[super class]</code>的消息接收者是当前的子类对象，而<code>-class</code>方法就是返回方法调用者的class，也就是<code>MJStudent</code>类型</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><code>[super message]</code>转化的底层源码<br>struct objc_super {<br>__unsafe_unretained _Nonnull id receiver; // 消息接收者<br>__unsafe_unretained _Nonnull Class super_class; // 消息接收者的父类<br>};<br>struct objc_super arg = {self, 父类};</li></ol><p>objc_msgSendSuper(arg, SEL);</p><ol start="2"><li><p><code>[super message]</code>的底层实现<br>消息接收者仍然是子类对象<br>从父类开始查找方法的实现</p></li><li><p>[super message], [self message]<br>这两个函数的实现差别挺大，一个调用<code>objc_msgSendSuper</code>，一个调用<code>objc_msgSend</code>，不要被它们两个表面迷惑；</p></li><li><p><code>-class</code>的底层实现<br>返回的是消息接收者的类，而恰好<code>super</code>的消息接收者是子类对象，就解释了<code>[super class]</code>的结果是子类了。</p></li></ol><h2 id="参考和源码"><a href="#参考和源码" class="headerlink" title="参考和源码"></a>参考和源码</h2><p>源码：<br><a href="https://cdn.ticsmatic.com/source/2020-05-26/diceng/day14/Interview05-super.zip" target="_blank" rel="noopener">Interview05-super</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Runtime-objc_msgSend</title>
      <link href="/p/e8e2068/"/>
      <url>/p/e8e2068/</url>
      
        <content type="html"><![CDATA[<p>学习MJ的视频课程，整理总结知识点–objc_msgSend</p><p>本文主要从Class结构体出发，讲解<code>class_rw_t</code>的结构及<code>class_rw_t</code>中的<code>methods</code>，及Class中的<code>cache_t cache</code>。</p><a id="more"></a><h2 id="objc-msgSend简介"><a href="#objc-msgSend简介" class="headerlink" title="objc_msgSend简介"></a>objc_msgSend简介</h2><p>OC中的方法调用，其实都是转换为objc_msgSend函数的调用</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MJPerson *person = [MJPerson alloc] init];</span><br><span class="line"></span><br><span class="line">[person personTest];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后对应的源码</span></span><br><span class="line">MJPerson *person = objc_msgSend(objc_msgSend(objc_getClass(<span class="string">"MJPerson"</span>), sel_registerName(<span class="string">"alloc"</span>)), sel_registerName(<span class="string">"init"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于 objc_msgSend(person, @selector(personTest));</span></span><br><span class="line">objc_msgSend(person, sel_registerName(<span class="string">"personTest"</span>));</span><br></pre></td></tr></table></figure><p>可以看到，OC的函数调用转成消息发送<br>我们可以测试<code>sel_registerName(&quot;personTest&quot;)</code>、<code>@selector(personTest)</code>两个函数的地址是相等的，其实它们两个确实是等价的，只不过是在不同环境的不同表现形式。</p><p>所以我们可以认为<br><strong>OC的方法调用：消息机制，给方法调用者发消息</strong></p><p>objc_msgSend的执行流程可以分为3大阶段</p><ol><li><p>消息发送</p></li><li><p>动态方法解析<br>允许动态创建一个方法出来</p></li><li><p>消息转发<br>消息转发给另外的对象调用</p></li></ol><h2 id="objc-msgSend消息发送"><a href="#objc-msgSend消息发送" class="headerlink" title="objc_msgSend消息发送"></a>objc_msgSend消息发送</h2><p>关于消息发送，我们从objc_msgSend的源码开始解读，这一部分是汇编代码，可能是因为objc_msgSend的调用频率比较高，为了性能的考虑，使用了更底层的汇编来实现。在<code>objc-msg-arm64.s</code>中</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">ENTRY</span> _objc_msgSend</span><br><span class="line">UNWIND _objc_msgSend, NoFrame</span><br><span class="line">MESSENGER_START</span><br><span class="line"></span><br><span class="line"><span class="keyword">cmp</span>x0, <span class="number">#0</span>// nil check <span class="keyword">and </span>tagged pointer check</span><br><span class="line"><span class="keyword">b.le</span>LNilOrTagged//  (MSB tagged pointer looks negative) nil的话跳转到LNilOrTagged</span><br><span class="line"><span class="keyword">ldr</span>x13, [x0]// x13 = isa</span><br><span class="line"><span class="keyword">and</span>x16, x13, <span class="symbol">#ISA_MASK</span>// x16 = class</span><br><span class="line"><span class="symbol">LGetIsaDone</span>:</span><br><span class="line">CacheLookup NORMAL// calls imp or objc_msgSend_uncached 缓存查找 参数 为NORMAL</span><br><span class="line"></span><br><span class="line"><span class="symbol">LNilOrTagged</span>:</span><br><span class="line"><span class="keyword">b.eq</span>LReturnZero// nil check nil的话直接return</span><br><span class="line"></span><br><span class="line">// tagged</span><br><span class="line"><span class="keyword">mov</span>x10, <span class="number">#0xf000000000000000</span></span><br><span class="line"><span class="keyword">cmp</span>x0, x10</span><br><span class="line"><span class="keyword">b.hs</span>LExtTag</span><br><span class="line"><span class="keyword">adrp</span>x10, _objc_debug_taggedpointer_classes<span class="comment">@PAGE</span></span><br><span class="line"><span class="keyword">add</span>x10, x10, _objc_debug_taggedpointer_classes<span class="comment">@PAGEOFF</span></span><br><span class="line"><span class="keyword">ubfx</span>x11, x0, <span class="number">#60</span>, <span class="number">#4</span></span><br><span class="line"><span class="keyword">ldr</span>x16, [x10, x11, <span class="keyword">LSL </span><span class="number">#3</span>]</span><br><span class="line"><span class="keyword">b</span>LGetIsaDone</span><br><span class="line"></span><br><span class="line"><span class="symbol">LExtTag</span>:</span><br><span class="line">// ext tagged</span><br><span class="line"><span class="keyword">adrp</span>x10, _objc_debug_taggedpointer_ext_classes<span class="comment">@PAGE</span></span><br><span class="line"><span class="keyword">add</span>x10, x10, _objc_debug_taggedpointer_ext_classes<span class="comment">@PAGEOFF</span></span><br><span class="line"><span class="keyword">ubfx</span>x11, x0, <span class="number">#52</span>, <span class="number">#8</span></span><br><span class="line"><span class="keyword">ldr</span>x16, [x10, x11, <span class="keyword">LSL </span><span class="number">#3</span>]</span><br><span class="line"><span class="keyword">b</span>LGetIsaDone</span><br><span class="line"></span><br><span class="line"><span class="symbol">LReturnZero</span>:</span><br><span class="line">// x0 is already zero</span><br><span class="line"><span class="keyword">mov</span>x1, <span class="number">#0</span></span><br><span class="line"><span class="keyword">movi</span><span class="built_in">d0</span>, <span class="number">#0</span></span><br><span class="line"><span class="keyword">movi</span><span class="built_in">d1</span>, <span class="number">#0</span></span><br><span class="line"><span class="keyword">movi</span><span class="built_in">d2</span>, <span class="number">#0</span></span><br><span class="line"><span class="keyword">movi</span><span class="built_in">d3</span>, <span class="number">#0</span></span><br><span class="line">MESSENGER_END_NIL</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">END_ENTRY _objc_msgSend</span><br></pre></td></tr></table></figure><p><code>ENTRY</code>是入口的意思，_objc_msgSend先判断对象是否为空，为空时，直接return，不为空继续往下走。先难道isa去对应位置的缓存中找<code>CacheLookup NORMAL</code></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">.macro</span> CacheLookup</span><br><span class="line">// x1 = <span class="keyword">SEL, </span>x16 = isa</span><br><span class="line">ldpx10, x11, [x16, <span class="symbol">#CACHE</span>] // x10 = <span class="keyword">buckets, </span>x11 = occupied<span class="title">|mask</span></span><br><span class="line"><span class="title">andw12, w1, w11// x12 = _cmd &amp; mask</span></span><br><span class="line"><span class="title">addx12, x10, x12, LSL #4 // x12 = buckets + ((_cmd &amp; mask)&lt;&lt;4)</span></span><br><span class="line"><span class="title"></span></span><br><span class="line"><span class="title">ldpx9, x17, [x12]// &#123;x9, x17&#125; = *bucket</span></span><br><span class="line"><span class="title">1:cmpx9, x1// if (bucket-&gt;sel != _cmd)</span></span><br><span class="line"><span class="title">b.ne2f//     scan more</span></span><br><span class="line"><span class="title">CacheHit $0// call or return imp</span></span><br><span class="line"><span class="title"></span></span><br><span class="line"><span class="title">2:// not hit: x12 = not-hit bucket</span></span><br><span class="line"><span class="title">CheckMiss $0// miss if bucket-&gt;sel == 0</span></span><br><span class="line"><span class="title">cmpx12, x10// wrap if bucket == buckets</span></span><br><span class="line"><span class="title">b.eq3f</span></span><br><span class="line"><span class="title">ldpx9, x17, [x12, #-16]!// &#123;x9, x17&#125; = *--bucket</span></span><br><span class="line"><span class="title">b1b// loop</span></span><br><span class="line"><span class="title"></span></span><br><span class="line"><span class="title">3:// wrap: x12 = first bucket, w11 = mask</span></span><br><span class="line"><span class="title">addx12, x12, w11, UXTW #4// x12 = buckets+(mask&lt;&lt;4)</span></span><br><span class="line"><span class="title"></span></span><br><span class="line"><span class="title">// Clone scanning loop to miss instead of hang when cache is corrupt.</span></span><br><span class="line"><span class="title">// The slow path may detect any corruption and halt later.</span></span><br><span class="line"><span class="title"></span></span><br><span class="line"><span class="title">ldpx9, x17, [x12]// &#123;x9, x17&#125; = *bucket</span></span><br><span class="line"><span class="title">1:cmpx9, x1// if (bucket-&gt;sel != _cmd)</span></span><br><span class="line"><span class="title">b.ne2f//     scan more</span></span><br><span class="line"><span class="title">CacheHit $0// call or return imp</span></span><br><span class="line"><span class="title"></span></span><br><span class="line"><span class="title">2:// not hit: x12 = not-hit bucket</span></span><br><span class="line"><span class="title">CheckMiss $0// miss if bucket-&gt;sel == 0</span></span><br><span class="line"><span class="title">cmpx12, x10// wrap if bucket == buckets</span></span><br><span class="line"><span class="title">b.eq3f</span></span><br><span class="line"><span class="title">ldpx9, x17, [x12, #-16]!// &#123;x9, x17&#125; = *--bucket</span></span><br><span class="line"><span class="title">b1b// loop</span></span><br><span class="line"><span class="title"></span></span><br><span class="line"><span class="title">3:// double wrap</span></span><br><span class="line"><span class="title">JumpMiss $0</span></span><br><span class="line"><span class="title"></span></span><br><span class="line"><span class="title">.endmacro</span></span><br></pre></td></tr></table></figure><p>CacheLookup的汇编代码看不懂，但是它的注释写的挺详细，以及一些关键词，我们呢也能分析出大致的流程。<br>拿着isa在对应的class里面找cache及里面的buckets<br>根据哈希计算(_cmd &amp; mask)的结果去buckets里面找<br>找到了调用<code>CacheHit</code>，返回imp<br>没找到的话调<code>CheckMiss</code>，用loop循环找<br>最终还没找到的话<code>JumpMiss</code><br>因为参数是<code>NORMAL</code>，<code>JumpMiss</code>的处理流程会调用<code>__objc_msgSend_uncached</code><br>因为是未缓存的方法，<code>__objc_msgSend_uncached</code>流程内会调用<code>MethodTableLookup</code>，也就是方法列表查找<br>方法列表查找内部调用<code>__class_lookupMethodAndLoadCache3</code><br>我们搜索<code>__class_lookupMethodAndLoadCache3</code>发现找不到匹配的关键字，因为在OC中，函数转到汇编函数时会多一个<code>_</code>，我们去掉下划线，搜索<code>_class_lookupMethodAndLoadCache3</code>，就来到了runtime的api</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IMP _class_lookupMethodAndLoadCache3(<span class="keyword">id</span> obj, SEL sel, Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> lookUpImpOrForward(cls, sel, obj, </span><br><span class="line">                              <span class="literal">YES</span><span class="comment">/*initialize*/</span>, <span class="literal">NO</span><span class="comment">/*cache*/</span>, <span class="literal">YES</span><span class="comment">/*resolver*/</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">IMP lookUpImpOrForward(Class cls, SEL sel, id inst, </span><br><span class="line">                       bool initialize, bool cache, bool resolver)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; Optimistic cache lookup</span><br><span class="line">    &#x2F;&#x2F; 需要从缓存中取</span><br><span class="line">    if (cache) &#123; </span><br><span class="line">        &#x2F;&#x2F; 从缓存中取</span><br><span class="line">        imp &#x3D; cache_getImp(cls, sel);</span><br><span class="line">        &#x2F;&#x2F; 取到了直接返回</span><br><span class="line">        if (imp) return imp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; cls未初始化要先初始化</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 从当前cls取，取到了直接返回</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 说明缓存中没取到，去当前cls的方法列表找&#96;getMethodNoSuper_nolock&#96;</span><br><span class="line">    &#123;</span><br><span class="line">        Method meth &#x3D; getMethodNoSuper_nolock(cls, sel);</span><br><span class="line">        if (meth) &#123;</span><br><span class="line">            &#x2F;&#x2F; 找到了把此方法填入当前cls的缓存中</span><br><span class="line">            log_and_fill_cache(cls, meth-&gt;imp, sel, inst, cls);</span><br><span class="line">            imp &#x3D; meth-&gt;imp;</span><br><span class="line">            goto done;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 当前cls没找到，回通过superclass指针去父类里面找，流程很类似，也是先从父类的缓存中找，没找到会去父类的方法列表中找</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 还是没找到，尝试动态解析</span><br><span class="line">    &#x2F;&#x2F; No implementation found. Try method resolver once.</span><br><span class="line">        _class_resolveMethod(cls, sel, inst);</span><br><span class="line">        &#x2F;&#x2F; goto retry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> method_t *search_method_list(<span class="keyword">const</span> method_list_t *mlist, SEL sel)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> methodListIsFixedUp = mlist-&gt;isFixedUp();</span><br><span class="line">    <span class="keyword">int</span> methodListHasExpectedSize = mlist-&gt;entsize() == <span class="keyword">sizeof</span>(method_t);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(methodListIsFixedUp &amp;&amp; methodListHasExpectedSize, <span class="number">1</span>)) &#123;</span><br><span class="line">         <span class="comment">// 有序的话就用二分查找</span></span><br><span class="line">        <span class="keyword">return</span> findMethodInSortedMethodList(sel, mlist);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Linear search of unsorted method list</span></span><br><span class="line">        <span class="comment">// 无序的话就用线性遍历查找</span></span><br><span class="line">        <span class="keyword">for</span> (auto&amp; meth : *mlist) &#123;</span><br><span class="line">            <span class="keyword">if</span> (meth.name == sel) <span class="keyword">return</span> &amp;meth;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心点就是先去当前类的缓存中找，找不到去当前类的方法列表中找，还找不到去父类缓存中找，找不到去父类的方法列表中找，还找不到尝试走动态解析。<br>思路很清晰，没什么难点，可以通过一个图来表示这个过程</p><p><strong>消息方法</strong><br><img src="https://cdn.ticsmatic.com/img/2020-05-26/15904795338816.png" alt="objc_msgSend-消息发送"></p><h2 id="objc-msgSend动态方法解析-resolve"><a href="#objc-msgSend动态方法解析-resolve" class="headerlink" title="objc_msgSend动态方法解析(resolve)"></a>objc_msgSend动态方法解析(resolve)</h2><p>在<code>lookUpImpOrForward</code>函数内先走消息查找逻辑，找不到时会走到动态方法解析阶段，这部分代码如下</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// No implementation found. Try method resolver once.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (resolver  &amp;&amp;  !triedResolver) &#123;</span><br><span class="line">        runtimeLock.unlockRead();</span><br><span class="line">        _class_resolveMethod(cls, sel, inst);</span><br><span class="line">        runtimeLock.read();</span><br><span class="line">        <span class="comment">// Don't cache the result; we don't hold the lock so it may have </span></span><br><span class="line">        <span class="comment">// changed already. Re-do the search from scratch instead.</span></span><br><span class="line">        triedResolver = <span class="literal">YES</span>;</span><br><span class="line">        <span class="keyword">goto</span> retry;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>方法找不到时，动态方法解析阶段内部会调用<code>resolveInstanceMethod</code>或<code>resolveClassMethod</code>方法，可以在这两个方法内部做动态添加函数。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _class_resolveMethod(Class cls, SEL sel, <span class="keyword">id</span> inst)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (! cls-&gt;isMetaClass()) &#123;</span><br><span class="line">        <span class="comment">// try [cls resolveInstanceMethod:sel]</span></span><br><span class="line">        _class_resolveInstanceMethod(cls, sel, inst);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// try [nonMetaClass resolveClassMethod:sel]</span></span><br><span class="line">        <span class="comment">// and [cls resolveInstanceMethod:sel]</span></span><br><span class="line">        _class_resolveClassMethod(cls, sel, inst);</span><br><span class="line">        <span class="keyword">if</span> (!lookUpImpOrNil(cls, sel, inst, </span><br><span class="line">                            <span class="literal">NO</span><span class="comment">/*initialize*/</span>, <span class="literal">YES</span><span class="comment">/*cache*/</span>, <span class="literal">NO</span><span class="comment">/*resolver*/</span>)) </span><br><span class="line">        &#123;</span><br><span class="line">            _class_resolveInstanceMethod(cls, sel, inst);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如我们调用一个未实现的对象方法<code>[person test]</code>，程序运行时，调用<code>test</code>方法时会走动态方法解析，我们实现<code>resolveInstanceMethod</code>方法，并在此方法内部动态添加<code>test</code>函数的实现，即可让程序继续正常执行。</p><p>当走到动态方法方法解析阶段时，<code>lookUpImpOrForward</code>函数接续往下走，会<code>goto retry</code>，也就是重新走消息发送流程。如果程序正确的动态添加了方法，那么消息发送流程会继续正确的执行，如果没有，会走到消息转发流程。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)other &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(test)) &#123;</span><br><span class="line">        <span class="comment">// 获取其他方法</span></span><br><span class="line">        Method method = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(other));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 动态添加test方法的实现</span></span><br><span class="line">        <span class="comment">// class_addMethod会把函数添加到Class里面的class_rw_t里面的methods</span></span><br><span class="line">        class_addMethod(<span class="keyword">self</span>, sel,</span><br><span class="line">                        method_getImplementation(method),</span><br><span class="line">                        method_getTypeEncoding(method));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回YES代表有动态添加方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时调用<code>test</code>函数，实际上内部调用的是<code>other</code>函数<br>如果是调用为实现的类方法，即给类发送消息，也会走同样的流程，不过在动态解析的时候，要记得是给类的元类动态添加方法。</p><p><strong>动态方法解析</strong><br><img src="https://cdn.ticsmatic.com/img/2020-05-26/15904810756472.png" alt="objc_msgSend-动态方法解析"></p><h2 id="objc-msgSend消息转发-forward"><a href="#objc-msgSend消息转发-forward" class="headerlink" title="objc_msgSend消息转发(forward)"></a>objc_msgSend消息转发(forward)</h2><p>如果动态方法解析阶段没有找到方法的实现，会走到消息转发阶段</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// No implementation found, and method resolver didn't help. </span></span><br><span class="line"><span class="comment">// Use forwarding.</span></span><br><span class="line"></span><br><span class="line">imp = (IMP)_objc_msgForward_impcache;</span><br></pre></td></tr></table></figure><p><code>_objc_msgForward</code>具体流程不开源，我们在<code>objc-msg-arm64.s</code>文件中搜索到如下汇编代码</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">ENTRY</span> __objc_msgForward</span><br><span class="line"></span><br><span class="line"><span class="keyword">adrp</span>x17, __objc_forward_handler<span class="comment">@PAGE</span></span><br><span class="line"><span class="keyword">ldr</span>x17, [x17, __objc_forward_handler<span class="comment">@PAGEOFF]</span></span><br><span class="line"><span class="keyword">br</span>x17</span><br><span class="line"></span><br><span class="line"><span class="symbol">END_ENTRY</span> __objc_msgForward</span><br></pre></td></tr></table></figure><p>但是在<code>_objc_forward_handler</code>没有找到消息转发的相关实现。<br>同时，如果我们调用一个未实现的方法时，运行时会报错，类似如下</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>   CoreFoundation <span class="number">0x00007fff3077c8ef</span> ___forwarding___ + <span class="number">1485</span></span><br></pre></td></tr></table></figure><p>关于<code>___forwarding___</code>，也就是调用消息转发流程的关键，有人根据汇编写出C语言的伪代码。<a href="https://cdn.ticsmatic.com/source/2020-05-26/diceng/day13/__forwarding__.c" target="_blank" rel="noopener"><strong>forwarding</strong>.c</a></p><p><code>___forwarding___.c</code>简化的伪代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __forwarding__(<span class="keyword">void</span> *frameStackPointer, <span class="keyword">int</span> isStret) &#123;</span><br><span class="line">    id receiver = *(id *)frameStackPointer;</span><br><span class="line">    SEL sel = *(SEL *)(frameStackPointer + <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *selName = sel_getName(sel);</span><br><span class="line">    Class receiverClass = object_getClass(receiver);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 forwardingTargetForSelector:</span></span><br><span class="line">    <span class="keyword">if</span> (class_respondsToSelector(receiverClass, @selector(forwardingTargetForSelector:))) &#123;</span><br><span class="line">        id forwardingTarget = [receiver forwardingTargetForSelector:sel];</span><br><span class="line">        <span class="keyword">if</span> (forwardingTarget &amp;&amp; forwardingTarget != receiver) &#123;</span><br><span class="line">            <span class="keyword">return</span> objc_msgSend(forwardingTarget, sel, ...);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 methodSignatureForSelector 获取方法签名后再调用 forwardInvocation</span></span><br><span class="line">    <span class="keyword">if</span> (class_respondsToSelector(receiverClass, @selector(methodSignatureForSelector:))) &#123;</span><br><span class="line">        NSMethodSignature *methodSignature = [receiver methodSignatureForSelector:sel];</span><br><span class="line">        <span class="keyword">if</span> (methodSignature &amp;&amp; class_respondsToSelector(receiverClass, @selector(forwardInvocation:))) &#123;</span><br><span class="line">            NSInvocation *invocation = [NSInvocation _invocationWithMethodSignature:methodSignature frame:frameStackPointer];</span><br><span class="line"></span><br><span class="line">            [receiver forwardInvocation:invocation];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">void</span> *returnValue = <span class="literal">NULL</span>;</span><br><span class="line">            [invocation getReturnValue:&amp;value];</span><br><span class="line">            <span class="keyword">return</span> returnValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (class_respondsToSelector(receiverClass,@selector(doesNotRecognizeSelector:))) &#123;</span><br><span class="line">        [receiver doesNotRecognizeSelector:sel];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The point of no return.</span></span><br><span class="line">    kill(getpid(), <span class="number">9</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以根据C的伪代码分析调用流程。</p><p>先判断是否实现<code>forwardingTargetForSelector</code>，如果实现了此方法，且返回一个对象，那么会同时把这个消息转发到这个对象上去。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">if</span> (aSelector == <span class="keyword">@selector</span>(test)) &#123;</span><br><span class="line">        <span class="keyword">return</span> [[MJCat alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个Demo中，是吧test方法这个消息，转发到<code>MJCat</code>的实例对象，也就是去调用<code>MJCat</code>对象的<code>test</code>方法。这就是消息转发的由来。</p><p>如果没有实现<code>forwardingTargetForSelector</code>方法，或者这个方法返回的对象为空，消息转发流程会继续走到<code>methodSignatureForSelector</code>，拿方法的签名，拿到对象的方法签名后，会调用<code>forwardInvocation</code>方法，返回值为空时，此时才调用<code>doesNotRecognizeSelector</code>方法，抛出错误。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法签名：返回值类型、参数类型</span></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">if</span> (aSelector == <span class="keyword">@selector</span>(test)) &#123;</span><br><span class="line">        <span class="built_in">NSMethodSignature</span> *methodSign = [<span class="built_in">NSMethodSignature</span> signatureWithObjCTypes:<span class="string">"v@:"</span>];</span><br><span class="line">        <span class="keyword">return</span> methodSign;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NSInvocation封装了一个方法调用，包括：方法调用者、方法名、方法参数</span></span><br><span class="line"><span class="comment">// anInvocation.target 方法调用者</span></span><br><span class="line"><span class="comment">// anInvocation.selector 方法名</span></span><br><span class="line"><span class="comment">// [anInvocation getArgument:NULL atIndex:0]</span></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation &#123;</span><br><span class="line">    <span class="comment">// 这个函数内部可以根据业务场景实现，没有具体要求</span></span><br><span class="line">    <span class="comment">// anInvocation.target = [[MJCat alloc] init];</span></span><br><span class="line">    <span class="comment">// [anInvocation invoke];</span></span><br><span class="line">    <span class="comment">// [anInvocation invokeWithTarget:[[MJCat alloc] init]];</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不仅实例方法支持动态方法解析、消息转发阶段，类方法也是支持的，因为消息发送的本质是要求<code>接受者、方法名</code>。类对象也是属于对象，当然也是支持这个流程的。前面也提到过，实例方法、类方法其实没有本质区别，只不过存储的位置不一样而已。</p><p><strong>消息转发</strong><br><img src="https://cdn.ticsmatic.com/img/2020-05-26/15905052826584.png" alt="objc_msgSend-消息转发"></p><p>这一部分可以参考<a href="https://cdn.ticsmatic.com/source/2020-05-26/diceng/day13/Interview01-forward.zip" target="_blank" rel="noopener">消息转发-Demo</a>进行试验。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>简介OC的消息机制：<br>OC中的方法调用其实都转成了objc_msgSend函数的调用，给receiver（方法调用者）发送了一条消息（selector方法名）<br>objc_msgSend有3大阶段<br>消息发送（去类、父类中查找）、动态方法解析、消息转发</p><p>消息转发机制流程<br>先判断是否实现了<code>forwardingTargetForSelector:</code>方法，如果实现了此方法且此方法的返回值不为nil，那么就会给返回值对象发送对应的消息SE</p><p>如果<code>forwardingTargetForSelector</code>返回值为nil，那么会调用<code>methodSignatureForSelector:</code>方法，如果此方法返回值不为nil，那么会调用<code>forwardInvocation:</code>方法，否则调用<code>doesNotRecognizeSelector:</code>方法。</p><h2 id="参考和源码"><a href="#参考和源码" class="headerlink" title="参考和源码"></a>参考和源码</h2><p><a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">objc4</a></p><p>源码：<br><a href="https://cdn.ticsmatic.com/source/2020-05-26/diceng/day13/__forwarding__.c" target="_blank" rel="noopener"><strong>forwarding</strong>.c</a><br><a href="https://cdn.ticsmatic.com/source/2020-05-26/diceng/day13/Interview01-forward.zip" target="_blank" rel="noopener">消息转发-Demo</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>class</title>
      <link href="/p/ed4b199f/"/>
      <url>/p/ed4b199f/</url>
      
        <content type="html"><![CDATA[<p>学习MJ的视频课程，整理总结知识点–class、super</p><a id="more"></a><h2 id="isKindOfClass-和-isMemberOfClass"><a href="#isKindOfClass-和-isMemberOfClass" class="headerlink" title="isKindOfClass 和 isMemberOfClass"></a>isKindOfClass 和 isMemberOfClass</h2><p><code>isKindOfClass</code>和<code>isMemberOfClass</code>的源码如下</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">- (Class)<span class="keyword">class</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> object_getClass(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)isMemberOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">return</span> object_getClass((<span class="keyword">id</span>)<span class="keyword">self</span>) == cls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)isMemberOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> <span class="keyword">class</span>] == cls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)isKindOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">for</span> (Class tcls = object_getClass((<span class="keyword">id</span>)<span class="keyword">self</span>); tcls; tcls = tcls-&gt;superclass) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tcls == cls) <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)isKindOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">for</span> (Class tcls = [<span class="keyword">self</span> <span class="keyword">class</span>]; tcls; tcls = tcls-&gt;superclass) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tcls == cls) <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)isSubclassOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">for</span> (Class tcls = <span class="keyword">self</span>; tcls; tcls = tcls-&gt;superclass) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tcls == cls) <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果如下</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> person = [[MJPerson alloc] init];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%d"</span>, [person isMemberOfClass:[MJPerson <span class="keyword">class</span>]]); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%d"</span>, [person isMemberOfClass:[<span class="built_in">NSObject</span> <span class="keyword">class</span>]]); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%d"</span>, [person isKindOfClass:[MJPerson <span class="keyword">class</span>]]); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%d"</span>, [person isKindOfClass:[<span class="built_in">NSObject</span> <span class="keyword">class</span>]]); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%d"</span>, [MJPerson isMemberOfClass:object_getClass([MJPerson <span class="keyword">class</span>])]); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%d"</span>, [MJPerson isKindOfClass:object_getClass([<span class="built_in">NSObject</span> <span class="keyword">class</span>])]); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h2 id="super面试题"><a href="#super面试题" class="headerlink" title="super面试题"></a>super面试题</h2><p>这里有一道面试题，如下，相应的Demo<a href="https://cdn.ticsmatic.com/source/2020-05-27/diceng/day15/Interview02-super.zip" target="_blank" rel="noopener">Interview02-super</a></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MJPerson</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line">- (<span class="keyword">void</span>)print;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MJPerson</span></span></span><br><span class="line">- (<span class="keyword">void</span>)print &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"my name is %@"</span>, <span class="keyword">self</span>-&gt;_name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">id</span> cls = [MJPerson <span class="keyword">class</span>];</span><br><span class="line">    <span class="keyword">void</span> *obj = &amp;cls;</span><br><span class="line">    [(__bridge <span class="keyword">id</span>)obj print];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>问<code>[(__bridge id)obj print]</code>执行结果？</p><p>从<code>viewDidLoad</code>函数内开始分析：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> cls = [MJPerson <span class="keyword">class</span>]; <span class="comment">// 栈中定义一个变量cls，cls指向MJPerson这个类</span></span><br><span class="line"><span class="keyword">void</span> *obj = &amp;cls; <span class="comment">// 栈中定义一个变量obj，obj指向cls的地址</span></span><br><span class="line">[(__bridge <span class="keyword">id</span>)obj print]; <span class="comment">// 给变量obj发送print消息</span></span><br></pre></td></tr></table></figure><p>我们先分析一个正常的调用场景的过程，如下</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> person = [[MJPerson alloc] init];</span><br><span class="line">[person print];</span><br></pre></td></tr></table></figure><p><code>person</code>指针指向MJPerson的一个实例对象，当调用<code>print</code>方法时，结合我们前面所学的Class的底层结构知道，会先通过person的isa指针拿到MJPerson这个类，在类中查找<code>print</code>方法并调用。<br>person指向的实例对象的底层结构是一个结构体，这个结构体的第一个成员是isa指针，也就意味着person指针指向的实例对象地址，同时也是实例对象的isa的地址，而实例对象isa的指向的地址是MJPerson这个类的地址，内部就会有类似如下的指针指向关系。<br><code>person ----&gt; isa ----&gt; MJPerson</code></p><p>我们再回过去分析上面的问题，它的指针指向关系如下：<br><code>obj ----&gt; cls ----&gt; MJPerson</code></p><p>两者虽然内容不一样，但指向关系相同。所以我们可以分析<code>[(__bridge id)obj print];</code>的流程，首先取obj指针指向的地址，为<code>cls</code>，等价于正常方法调用的流程的取isa指针；然后取isa指向的对象地址，正常流程是MJPerson，而<code>cls</code>指针指向的地址也是MJPerson，所以能正常调用<code>print</code>方法。</p><p>那么打印的<code>self.name</code>结果是什么呢</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)print &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"my name is %@"</span>, <span class="keyword">self</span>.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面我们可以分析出，<code>[(__bridge id)obj print]</code>这段代码可以正确的执行，我们知道，<code>_name</code>是MJPerson实例对象里面的一个属性，而实例对象结构体第一个成员是isa指针，接下来是<code>_name</code>，也就是<code>print</code>函数的<code>self.name</code>是isa地址后面8个字节的空间的内容。</p><p>而<code>obj</code>是存储在栈空间的一个变量，<strong>栈空间是从高地址-&gt;低地址依次分配内存</strong>的，我们先从简单的分析入手，把代码改成如下这样：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> *str = <span class="string">@"123"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">id</span> cls = [MJPerson <span class="keyword">class</span>];</span><br><span class="line">    <span class="keyword">void</span> *obj = &amp;cls;</span><br><span class="line">    [(__bridge <span class="keyword">id</span>)obj print];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时打印的的结果是<code>my name is 123</code>，我们分析下此时栈空间的内存地址结构</p><table><thead><tr><th>低地址-&gt;高地址</th><th>指针指向的内存区域</th></tr></thead><tbody><tr><td>obj</td><td>指针指向cls</td></tr><tr><td>cls</td><td>指针指向MJPerson</td></tr><tr><td>str</td><td>指针指向”123”</td></tr></tbody></table><p>我们回到函数<code>[(__bridge id)obj print]</code>的调用流程进行分析，调用过程中会取obj的<code>isa</code>，并且把isa的地址增加<code>_name</code>的大小作为偏移量，也就是8字节。也就是会取<code>obj</code>指向的<code>cls</code>，并把<code>cls</code>的地址增加8个字节的偏移量作为<code>_name</code>的内存地址，此时便宜后刚好是<code>str</code>的内存区域。就解释了打印的结果是<code>123</code>。</p><p>那么我们回到原本的问题，如下</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">id</span> cls = [MJPerson <span class="keyword">class</span>];</span><br><span class="line">    <span class="keyword">void</span> *obj = &amp;cls;</span><br><span class="line">    [(__bridge <span class="keyword">id</span>)obj print];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时<code>cls</code>的地址增加8字节是谁呢，这里有一个<code>[super viewDidLoad];</code>调用，我们之前的文章分析过，<code>[super message];</code>用clang重写会生成如下代码</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_super arg = &#123;<span class="keyword">self</span>, [<span class="built_in">UIViewController</span> <span class="keyword">class</span>]&#125;;</span><br><span class="line">objc_msgSendSuper(arg, sel_registerName(<span class="string">"viewDidLoad"</span>));</span><br></pre></td></tr></table></figure><p>这个过程会生成一个<code>objc_super</code>类型的结构体，结构体的第一个成员是<code>self</code>，也就是<code>ViewController</code>的实例对象。此时的函数内栈内存地址图如下</p><table><thead><tr><th>低地址-&gt;高地址</th><th>指针指向的内存区域</th></tr></thead><tbody><tr><td>obj</td><td>指针指向cls</td></tr><tr><td>cls</td><td>指针指向MJPerson</td></tr><tr><td>self</td><td>指针指向ViewController实例对象</td></tr><tr><td>类指针</td><td>指针指向[UIViewController class]</td></tr></tbody></table><p>所以根据偏移量计算，<code>_name</code>的位置刚好是<code>self</code>对象，所以程序运行的结果如下</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[(__bridge <span class="keyword">id</span>)obj print]; <span class="comment">// my name is &lt;ViewController: 0x600002eade10&gt;</span></span><br></pre></td></tr></table></figure><h2 id="super本质"><a href="#super本质" class="headerlink" title="super本质"></a>super本质</h2><p>对于<code>[super message]</code>这里有一些知识要补充。</p><p><code>[super message]</code>的底层本质，我们上面也总结过，我们是根据源码导出的编译环境下的C++代码总结的，实际上并不能完全代表运行时的样子。</p><p>时机上运行时，真正调用的和编译时是不一样的，我们通过断点调试<code>[super viewDidLoad]</code>的执行过程，选择<code>Xcode-&gt;Debug-&gt;Debug Workflow-&gt;Always Show Disassembly</code>，来查看真实调用时转化的汇编代码，关键部分如下</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x10b457383</span> &lt;+<span class="number">35</span>&gt;:  movq   <span class="number">0x2b9e</span>(%rip), %rsi        ; <span class="string">"viewDidLoad"</span></span><br><span class="line"><span class="number">0x10b45738a</span> &lt;+<span class="number">42</span>&gt;:  leaq   <span class="number">-0x20</span>(%rbp), %rdi</span><br><span class="line"><span class="number">0x10b45738e</span> &lt;+<span class="number">46</span>&gt;:  callq  <span class="number">0x10b4578f4</span>               ; symbol stub <span class="keyword">for</span>: objc_msgSendSuper2</span><br></pre></td></tr></table></figure><p>我们看到<code>[super message]</code>真实调用的底层函数是<code>objc_msgSendSuper2</code>，我们在苹果开源的<a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">objc4</a>没有找到<code>objc_msgSendSuper2</code>的C实现，不过有汇编实现，如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">OBJC_EXPORT id _Nullable</span><br><span class="line">objc_msgSendSuper2(struct objc_super * _Nonnull super, SEL _Nonnull op, ...)</span><br><span class="line">    OBJC_AVAILABLE(10.6, 2.0, 9.0, 1.0, 2.0);</span><br><span class="line">    </span><br><span class="line">ENTRY _objc_msgSendSuper2</span><br><span class="line">UNWIND _objc_msgSendSuper2, NoFrame</span><br><span class="line">MESSENGER_START</span><br><span class="line"></span><br><span class="line">ldpx0, x16, [x0]&#x2F;&#x2F; x0 &#x3D; real receiver, x16 &#x3D; class</span><br><span class="line">ldrx16, [x16, #SUPERCLASS]&#x2F;&#x2F; x16 &#x3D; class-&gt;superclass</span><br><span class="line">CacheLookup NORMAL</span><br><span class="line"></span><br><span class="line">END_ENTRY _objc_msgSendSuper2</span><br></pre></td></tr></table></figure><p>我们可以分析出objc_msgSendSuper2函数的第1个参数是receiver，第2个参数是class，但是它会通过<code>class-&gt;superclass</code>获取父类。我们编译阶段导出的源码第2个参数直接是superclass。两者还是有一些细微差别的。</p><h3 id="验证-objc-msgSendSuper2的实现"><a href="#验证-objc-msgSendSuper2的实现" class="headerlink" title="验证_objc_msgSendSuper2的实现"></a>验证_objc_msgSendSuper2的实现</h3><p>上面关于<code>_objc_msgSendSuper2</code>的实现是我们根据汇编代码推出来的，实际上我们还可以通过运行时进行调试来验证我们推到的结论。</p><p>我们在<code>[(__bridge id)obj print];</code>添加断点，进行Debug，如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p obj</span><br><span class="line">(MJPerson *) $0 &#x3D; 0x00007ffee94da4e8</span><br><span class="line">(lldb) x&#x2F;4g 0x00007ffee94da4e8</span><br><span class="line">0x7ffee94da4e8: 0x0000000106725010 0x00007ff795704800</span><br><span class="line">0x7ffee94da4f8: 0x0000000106724f48 0x00007fff516daaa8</span><br><span class="line">(lldb) po 0x0000000106725010</span><br><span class="line">MJPerson</span><br><span class="line"></span><br><span class="line">(lldb) po 0x00007ff795704800</span><br><span class="line">&lt;ViewController: 0x7ff795704800&gt;</span><br><span class="line"></span><br><span class="line">(lldb) po 0x0000000106724f48</span><br><span class="line">ViewController</span><br></pre></td></tr></table></figure><p>我们发现obj紧挨着的下一个内存指向的是MJPerson，接下来指向的是ViewController的实例对象，再接下来指向的是ViewController的类。</p><p>如下表所示，验证了我们的猜想</p><table><thead><tr><th>低地址-&gt;高地址</th><th>指针指向的内存区域</th></tr></thead><tbody><tr><td>obj 0x00007ffee94da4e8</td><td>指针指向cls</td></tr><tr><td>cls 0x0000000106725010</td><td>指针指向MJPerson</td></tr><tr><td>self 0x00007ff795704800</td><td>指针指向ViewController实例对象</td></tr><tr><td>类指针 0x0000000106724f48</td><td>指针指向ViewController</td></tr></tbody></table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于super面试题的分析，我们要知道这结构要点</p><ol><li>熟悉OC的消息发送；拿到receiver，取receiver的isa，根据isa找class</li><li>熟悉实例对象的内存结构；isa后面跟着成员变量</li><li>栈空间是从高地址-&gt;低地址依次分配内存</li><li>[super message]会先生生成一个<code>objc_super</code>的结构体，然后转化为<code>objc_msgSendSuper(结构体, SEL)</code>进行调用</li></ol><p>super调用，底层会转换为objc_msgSendSuper2函数的调用，接收2个参数<br>struct objc_super2<br>SEL</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_super2</span> &#123;</span></span><br><span class="line">    id receiver;            <span class="comment">// receiver是消息接收者</span></span><br><span class="line">    Class current_class;    <span class="comment">// current_class是receiver的Class对象</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="参考和源码"><a href="#参考和源码" class="headerlink" title="参考和源码"></a>参考和源码</h2><p>源码：<br><a href="https://cdn.ticsmatic.com/source/2020-05-27/diceng/day15/Interview02-super.zip" target="_blank" rel="noopener">Interview02-super</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>block的copy、访问对象类型变量的底层实现</title>
      <link href="/p/a3ade774/"/>
      <url>/p/a3ade774/</url>
      
        <content type="html"><![CDATA[<p>学习MJ的视频课程，整理总结知识点–block的copy、访问对象类型变量的底层实现</p><p>本文结合block的特性，探讨ARC下block自动copy的时机；以及block内访问外部的对象类型变量时底层实现；</p><a id="more"></a><h2 id="block的copy"><a href="#block的copy" class="headerlink" title="block的copy"></a>block的copy</h2><p>在上一节的block学习中我们遇到，在ARC环境下，block有时会被自动拷贝到堆空间去，我们可以分析一下原因。</p><p>常见的场景就是block里面访问一个局部变量，根据上一节所学，MRC下访问auto变量的block是存储在栈上的，但是我们在ARC环境下演练测试发现它是存储在堆空间上。因为栈空间内存是系统自动做处理的，堆空间才是开发者手动控制。如果让block保留在栈空间，很可能当我们调用block的时候，它已经被系统自动回收了，肯定不是我们想要的结果，所以在ARC下block会被自动copy到堆空间上，有开发者控制它的释放时机(不过这些工作实际是由ARC机制处理了)</p><p><strong>ARC下block进行自动copy的根本目的是为了防止block在栈空间上被不合时宜的自动释放，而此时调用被释放的block就会出错</strong>，而copy到堆空间就不会自动释放。</p><p>从这个根本原因出发，我们可以总结一下在ARC环境下，block在哪些场景会被自动copy到堆上。首先，我们知道需要copy操作的一般是<code>NSStackBlock</code>类型的block，而NSStackBlock类型的block的产生是因为block访问了auto变量。</p><p>所以我们可以推出一个关键点：<strong>在ARC下，访问了auto变量的block，默认都会进行copy操作，防止它在栈上被自动释放</strong>。包括以下几种：</p><ol><li>block作为函数返回值时(<code>Masonry</code>中)</li><li>将block赋值给__strong指针时</li><li>block作为一些函数的参数时(cocoa API useringBlock参数)、（GCD API block参数）</li></ol><h2 id="对象类型的auto变量"><a href="#对象类型的auto变量" class="headerlink" title="对象类型的auto变量"></a>对象类型的auto变量</h2><p>在之前的测试中，我们更多的是用block访问基本类型的auto变量，现在我们研究block访问对象类型的auto变量的底层。</p><p>参见<a href="https://cdn.ticsmatic.com/source/2020-05-14/diceng/day09/Interview02-Auto-variable-of-object-type.zip" target="_blank" rel="noopener">Demo</a>，新建一个自定义类，研究它的实例对象释放时机</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            MJPerson *person = [[MJPerson alloc] init];</span><br><span class="line">            person.age = <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// person dealloc</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下，person对象在出了大括号后，就会调用自己的dealloc方法进行释放。</p><p>当我们用一个block访问person的属性时</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MJBlock block;</span><br><span class="line">&#123;</span><br><span class="line">    MJPerson *person = [[MJPerson alloc] init];</span><br><span class="line">    person.age = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    block = ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"---------%d"</span>, person.age);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// person not dealloc</span></span><br></pre></td></tr></table></figure><p>此时发现person出了大括号的作用域，没有调用dealloc，直到block销毁时，person才销毁。</p><p>我们简化一下代码如下</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MJBlock block;</span><br><span class="line">MJPerson *person = [[MJPerson alloc] init];</span><br><span class="line">            person.age = <span class="number">10</span>;</span><br><span class="line">block = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"---------%d"</span>, person.age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们研究此时的block源码，分析为什么会是这样。clang编译后的block源码如下</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line">  MJPerson *person;</span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, MJPerson *_person, <span class="keyword">int</span> flags=<span class="number">0</span>) : person(_person) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>block结构体里面有person的指针，而block在堆空间，在ARC下，block会强引用着person，所以当block销毁时person才会销毁。</p><p>我们还可以验证在MRC环境下person的释放时机，此时block是在栈空间的。会发现在MRC下，person出了自己的大括号作用域后，就销毁了。</p><p>我们可与得出一个结论：栈空间上的block是不会对对象类型的auto变量强引用，堆空间上的block会对对象类型的auto变量强引用。</p><p>我们再使用weak类型的person实验一下此时person的释放时机</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MJBlock block;</span><br><span class="line">&#123;</span><br><span class="line">    MJPerson *person = [[MJPerson alloc] init];</span><br><span class="line">    person.age = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    __<span class="keyword">weak</span> MJPerson *weakPerson = person;</span><br><span class="line">    block = ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"---------%d"</span>, person.age);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"------"</span>);</span><br></pre></td></tr></table></figure><p>会发现person在出了自己的大括号作用域后就销毁了，说明此时block是没有强引用着person对象，我们看下使用<code>__weak</code>时的block源码<br>此时用clang命令会报错<code>cannot create __weak reference because the current deployment target does</code><br>因为__weak是属于运行时的特性，clang默认是编译期，我们要指定clang的runtime环境才能导出源文件。<br>修改clang命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -rewrite-objc -fobjc-arc -fobjc-runtime&#x3D;ios-9.0.0  main.m -o main2.cpp</span><br></pre></td></tr></table></figure><p>我们看此时的block源码如下</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line">  MJPerson *__<span class="keyword">weak</span> weakPerson;</span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, MJPerson *__<span class="keyword">weak</span> _weakPerson, <span class="keyword">int</span> flags=<span class="number">0</span>) : weakPerson(_weakPerson) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>会发现block里面的person对象是<code>MJPerson *__weak weakPerson;</code>类型，从字面意思上理解就是block不强引用这个person对象了，这也就解释了为什么__weak的person对象在出了自己的大括号作用域后就销毁了，因为没有别的对象对它强引用了。</p><p>我们再看下此时block的desc结构体</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  <span class="keyword">void</span> (*<span class="keyword">copy</span>)(<span class="keyword">struct</span> __main_block_impl_0*, <span class="keyword">struct</span> __main_block_impl_0*);</span><br><span class="line">  <span class="keyword">void</span> (*dispose)(<span class="keyword">struct</span> __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br></pre></td></tr></table></figure><p>会发现此时的__main_block_desc_0结构体，相对于访问基本类型的auto变量时多了两个函数指针<code>void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*); void (*dispose)(struct __main_block_impl_0*);</code>而这两个函数的实现如下</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_copy_0(<span class="keyword">struct</span> __main_block_impl_0*dst, <span class="keyword">struct</span> __main_block_impl_0*src) &#123;</span><br><span class="line">    _Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;weakPerson, (<span class="keyword">void</span>*)src-&gt;weakPerson, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_dispose_0(<span class="keyword">struct</span> __main_block_impl_0*src) &#123;</span><br><span class="line">    _Block_object_dispose((<span class="keyword">void</span>*)src-&gt;weakPerson, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明当<code>BLOCK_FIELD_IS_OBJECT</code>时，会多两个函数实现，分别是<code>_Block_object_assign</code>、<code>_Block_object_dispose</code>。</p><p>实际上<code>_Block_object_assign</code>就是block决定是否引用person对象的关键，当block内部的person是<code>MJPerson *__weak weakPerson;</code>，<code>_Block_object_assign</code>就也是用__weak关联这个person</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>关于block访问对象类型的auto变量，做一个总结</p><ol><li><p>如果block是在栈上，将不会对auto变量产生强引用</p></li><li><p>如果block被拷贝到堆上<br>会调用block内部的copy函数<br>copy函数内部会调用_Block_object_assign函数<br>_Block_object_assign函数会根据auto变量的修饰符（<strong>strong、</strong>weak、__unsafe_unretained）做出相应的操作，形成强引用（retain）或者弱引用</p></li><li><p>如果block从堆上移除<br>会调用block内部的dispose函数<br>dispose函数内部会调用_Block_object_dispose函数<br>_Block_object_dispose函数会自动释放引用的auto变量（release）<br><img src="https://cdn.ticsmatic.com/img/2020-05-21/15900262341143.png" alt="copy-and-dispose"></p></li></ol><h2 id="参考和源码"><a href="#参考和源码" class="headerlink" title="参考和源码"></a>参考和源码</h2><p>Demo源码：<br><a href="https://cdn.ticsmatic.com/source/2020-05-14/diceng/day08/Interview01-Block.zip" target="_blank" rel="noopener">Block底层-Demo</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>block的copy、访问对象类型变量的底层实现、__block的底层实现</title>
      <link href="/p/5ee3d56b/"/>
      <url>/p/5ee3d56b/</url>
      
        <content type="html"><![CDATA[<p>学习MJ的视频课程，整理总结知识点–__block的底层实现</p><p>本文根据前面所学的block的特性，结合Demo来讲解关于<strong>block的底层的一些东西。包括</strong>block的底层源码，</p><a id="more"></a><h2 id="block"><a href="#block" class="headerlink" title="__block"></a>__block</h2><p>关于block还要一个比较常见的场景就是<strong>block修饰，这一部分参见[</strong>block底层-Demo](<a href="https://cdn.ticsmatic.com/source/2020-05-21/diceng/day09/Interview04-__block.zip" target="_blank" rel="noopener">https://cdn.ticsmatic.com/source/2020-05-21/diceng/day09/Interview04-__block.zip</a>)</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// __block int age = 10;</span></span><br><span class="line"><span class="keyword">void</span> (^block)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">    age = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%d"</span>, age);</span><br><span class="line">&#125;;</span><br><span class="line">block();</span><br></pre></td></tr></table></figure><p>我们知道如果不加__block，编译器是会报错。根据前面所学的block变量捕获，我们知道当block访问的外部变量是auto类型时，如果这个变量是基本类型，block会先把这个变量捕获到内部，所以block内部的age变量和外边的age此时已经不属于同一块内存空间了，自然就不能修改。</p><p>那怎么才能修改age的值，有以下两种方法<br>1.用static或全局变量修饰age变量<br>2.用__block修饰age变量</p><p>第1种方法我们我们知道此时block内部要么捕获age的指针地址，要么不捕获age，直接访问age，都是可以对age进行修改。<br>第2种加上__block后为什么也可以呢？我们通过源码进行分析这一过程，首先还是用clang导出block源码，如下</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line">  __Block_byref_age_0 *age; <span class="comment">// by ref</span></span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, __Block_byref_age_0 *_age, <span class="keyword">int</span> flags=<span class="number">0</span>) : age(_age-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而此时<code>__Block_byref_age_0</code>的结构如下</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __Block_byref_age_0 &#123;</span><br><span class="line">  <span class="keyword">void</span> *__isa;</span><br><span class="line">__Block_byref_age_0 *__forwarding;</span><br><span class="line"> <span class="keyword">int</span> __flags;</span><br><span class="line"> <span class="keyword">int</span> __size;</span><br><span class="line"> <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而此时block内部的代码如下</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  __Block_byref_age_0 *age = __cself-&gt;age; <span class="comment">// bound by ref</span></span><br><span class="line"></span><br><span class="line">            (age-&gt;__forwarding-&gt;age) = <span class="number">20</span>;</span><br><span class="line">            <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_k2_y136z2p908718gwl0q6xh92w0000gn_T_main_149db6_mi_0, (age-&gt;__forwarding-&gt;age));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>定义<code>__block int age = 10;</code>转化为源码如下</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__Block_byref_age_0 age = &#123;</span><br><span class="line">    (<span class="keyword">void</span>*)<span class="number">0</span>,</span><br><span class="line">    (__Block_byref_age_0 *)&amp;age,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="keyword">sizeof</span>(__Block_byref_age_0),</span><br><span class="line">    <span class="number">10</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们发现，用<strong>block修饰后，age被包装成`</strong>Block_byref_age_0 *age;<code>，变为结构体，而这个结构体内部存放的有age的值。block内部的age变为</code><strong>Block_byref_age_0 *age; // by ref<code>。 block函数实现部分</code>age-&gt;</strong>forwarding<code>指向自己的结构体地址，可以通过</code>(age-&gt;<strong>forwarding-&gt;age) = 20;`修改内部age的值。这也解释为什么</strong>block可以修改值的本质原因。</p><p>概述一下<strong>block修饰的作用：<br>__block修饰的变量会被包装成一个对象(`</strong>Block_byref_xx_0<code>)，这个对象的结构体内部有用于存储真实的变量的成员。block内部有</code>__Block_byref_xx_0<code>成员变量用来访问和修改变量</code>xx`。</p><p>__block修饰符小结：</p><ol><li>__block可以用于解决block内部无法修改auto变量值的问题</li><li>编译器会将<strong>block变量包装成一个对象(`</strong>Block_byref_xx_0`)</li><li>__block不能修饰全局变量、静态变量（static）</li></ol><p>再用一张图片做一下总结<br><img src="https://cdn.ticsmatic.com/img/2020-05-21/15900322500373.png" alt="__block修饰的变量"></p><h2 id="block修饰的变量的地址"><a href="#block修饰的变量的地址" class="headerlink" title="__block修饰的变量的地址"></a>__block修饰的变量的地址</h2><p>我们通过下面这段代码研究输出的<code>age</code>的地址</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">void</span> (^block)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">    age = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%d"</span>, age);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%p"</span>, &amp;age); <span class="comment">// p/x &amp;(blockImpl-&gt;age-&gt;age)</span></span><br></pre></td></tr></table></figure><p>这段代码的底层源码上面我们已经分析过了，block内部有一个<code>__Block_byref_age_0 *age; // by ref</code>的成员变量，而<code>__Block_byref_age_0</code>结构体内部有一个<code>int age;</code>的成员变量。那么上面的代码输出的age地址是<code>__Block_byref_age_0</code>的地址，还是<code>__Block_byref_age_0</code>内部的<code>int age</code>的地址？</p><p>其实我们分析也可以得知，输出的应该是<code>__Block_byref_age_0</code>内部的<code>int age</code>的地址。<br>一方面OC的语言设计者是不希望暴露block的内部细节给开发者，因为开发者平时没必要关注内部的细节。还有KVO动态生成子类，但是返回的class还是原来的类也是这样，为了屏蔽这个动态的子类。另一方面，我们在block内部给age赋值时，block源码内部也是通过结构体拿到<code>int age</code>进行赋值操作，所以读取的话，理论上应该也是返回这个<code>int age</code>。</p><p>我们可以通过实现block的源码来验证一个观点，参见<a href="https://cdn.ticsmatic.com/source/2020-05-21/diceng/day10/Interview01-__block.zip" target="_blank" rel="noopener">__block转结构体-Demo</a></p><h2 id="block内存管理"><a href="#block内存管理" class="headerlink" title="__block内存管理"></a><code>__block</code>内存管理</h2><p>如果认真看<code>__block</code>编译后的源码会发现，<strong>__block修饰的变量</strong>的底层源码和<strong>block访问对象类型的auto变量</strong>的底层源码有很多的相似之处。</p><blockquote><p>参见对比源码中<a href="https://cdn.ticsmatic.com/source/2020-05-21/diceng/day09/Interview04-__block.zip" target="_blank" rel="noopener">__block底层-Demo</a>中<code>main.cpp</code>文件</p></blockquote><p>比如__block的变量会被包装成对象，拥有这个对象，对这个对象进行内存管理。block源码内部都会有copy和dispose函数等。block内部都会通过<code>_Block_object_assign</code>函数引用者block要访问的外部变量。block销毁时，也都会调用<code>_Block_object_dispose</code>函数进行解除引用。</p><p>但是也是有一些不同点，对__block的内存管理可以总结如下：</p><ol><li><p>当block在栈上时，并不会对__block变量产生强引用</p></li><li><p>当block被copy到堆时</p><ul><li>会调用block内部的copy函数</li><li>copy函数内部会调用_Block_object_assign函数</li><li><strong>_Block_object_assign函数会对__block变量形成强引用（retain）</strong></li><li>当block拷贝到堆上时，内部访问的变量如果在栈上也会拷贝到，如果在堆上，引用计数会+1。这样来达到block来管理内部访问的变量<br><img src="https://cdn.ticsmatic.com/img/2020-05-21/15900698725809.png" alt="__block变量01">)<img src="https://cdn.ticsmatic.com/img/2020-05-21/15900698762232.png" alt="__block变量02"></li></ul></li><li><p>当block从堆中移除时</p><ul><li>会调用block内部的dispose函数</li><li>dispose函数内部会调用_Block_object_dispose函数</li><li>_Block_object_dispose函数会自动释放引用的<strong>block变量（release）<br>![</strong>block-dispose01](<a href="https://cdn.ticsmatic.com/img/2020-05-21/15900714319132.png" target="_blank" rel="noopener">https://cdn.ticsmatic.com/img/2020-05-21/15900714319132.png</a>)<br><img src="https://cdn.ticsmatic.com/img/2020-05-21/15900716940751.png" alt="__block-dispose02"></li></ul></li></ol><h2 id="forwarding"><a href="#forwarding" class="headerlink" title="__forwarding"></a><code>__forwarding</code></h2><p>我们获取在前面已经发现，<code>__block</code>变量内部默认有一个<code>__forwarding</code>指针，而且在block实现内部，比如上面我们修改<code>age</code>的值时，也是通过<code>__forwarding</code>来访问age的(<code>(age-&gt;__forwarding-&gt;age) = 20;</code>)。</p><p>为什么不直接通过结构体访问里面的<code>age</code>，而是间接通过<code>__forwarding</code>指针来访问<code>age</code>？</p><p><img src="https://cdn.ticsmatic.com/img/2020-05-21/15900717248002.png" alt="__forwarding01"><br><img src="https://cdn.ticsmatic.com/img/2020-05-21/15900720545743.png" alt="__forwarding02"></p><h2 id="对象类型的auto变量、-block变量小结"><a href="#对象类型的auto变量、-block变量小结" class="headerlink" title="对象类型的auto变量、__block变量小结"></a>对象类型的auto变量、__block变量小结</h2><p>当block在栈上时，对它们都不会产生强引用</p><p>当block拷贝到堆上时，都会通过copy函数来处理它们</p><ol><li>__block变量（假设变量名叫做a）<br><code>_Block_object_assign((void*)&amp;dst-&gt;a, (void*)src-&gt;a, 8/*BLOCK_FIELD_IS_BYREF*/);</code></li><li>对象类型的auto变量（假设变量名叫做p）<br><code>_Block_object_assign((void*)&amp;dst-&gt;p, (void*)src-&gt;p, 3/*BLOCK_FIELD_IS_OBJECT*/);</code></li></ol><p>当block从堆上移除时，都会通过dispose函数来释放它们<br>__block变量（假设变量名叫做a）<br><code>_Block_object_dispose((void*)src-&gt;a, 8/*BLOCK_FIELD_IS_BYREF*/);</code></p><p>对象类型的auto变量（假设变量名叫做p）<br><code>_Block_object_dispose((void*)src-&gt;p, 3/*BLOCK_FIELD_IS_OBJECT*/);</code></p><h2 id="block修饰对象类型"><a href="#block修饰对象类型" class="headerlink" title="__block修饰对象类型"></a>__block修饰对象类型</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__block MJPerson *weakPerson = person;</span><br><span class="line">__block __<span class="keyword">weak</span> MJPerson *weakPerson = person;</span><br></pre></td></tr></table></figure><p>当__block变量在栈上时，不会对指向的对象产生强引用</p><p>当__block变量被copy到堆时</p><ol><li>会调用__block变量内部的copy函数</li><li>copy函数内部会调用_Block_object_assign函数</li><li>_Block_object_assign函数会根据所指向对象的修饰符（<strong>strong、</strong>weak、__unsafe_unretained）做出相应的操作，形成强引用（retain）或者弱引用（<strong>注意：这里仅限于ARC时会retain，MRC时不会retain</strong>）</li></ol><p>如果<strong>block变量从堆上移除<br>会调用</strong>block变量内部的dispose函数<br>dispose函数内部会调用_Block_object_dispose函数<br>_Block_object_dispose函数会自动释放指向的对象（release）</p><h2 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h2><p>因为block默认会对访问的对象进行强引用，如果此时对象已经对这个block强引用了，很容易就造成循环引用，从而导致内存泄露。如下</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MJPerson *person = [[MJPerson alloc] init];</span><br><span class="line">person.age = <span class="number">10</span>;</span><br><span class="line">person.block = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"age is %d"</span>, person.age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这段测试代码就会有循环引用的问题，因为block内部访问对象类型的<code>person</code>的变量，block此时默认会强引用这个<code>person</code>对象，而这个block又是<code>person</code>的成员变量，所以person会强引用着block。这就出现了循环引用。</p><h3 id="ARC下循环引用的解决"><a href="#ARC下循环引用的解决" class="headerlink" title="ARC下循环引用的解决"></a>ARC下循环引用的解决</h3><h4 id="weak"><a href="#weak" class="headerlink" title="__weak"></a>__weak</h4><p>通常的解决方法就是不让block强引用<code>person</code>对象，用__weak修饰person对象，如下</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MJPerson *person = [[MJPerson alloc] init];</span><br><span class="line">person.age = <span class="number">10</span>;</span><br><span class="line">__<span class="keyword">weak</span> MJPerson *weakPerson = person;</span><br><span class="line"><span class="comment">// __weak typeof(person) weakPerson = person;</span></span><br><span class="line">person.block = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"age is %d"</span>, weakPerson.age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样就打破了循环引用了，对象就可以正常的释放了。</p><h4 id="unsafe-unretained"><a href="#unsafe-unretained" class="headerlink" title="__unsafe_unretained"></a>__unsafe_unretained</h4><p>解决循环引用还有另一种方法，就是使用<code>__unsafe_unretained</code>，如下</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">unsafe_unretained</span> <span class="keyword">typeof</span>(person) weakPerson = person;</span><br><span class="line">person.block = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"age is %d"</span>, weakPerson.age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用<code>__unsafe_unretained</code>，block就不会对<code>person</code>产生强引用。但是它不安全，体现在当block内的<code>weakPerson</code>销毁时，block内指针存储的地址值不变，此时访问<code>weakPerson</code>就可能出现坏内存访问的问题。而用__weak时，指向的对象销毁时，会自动让指针置为nil。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; __weak：不会产生强引用，指向的对象销毁时，会自动让指针置为nil</span><br><span class="line">&#x2F;&#x2F; __unsafe_unretained：不会产生强引用，不安全，指向的对象销毁时，指针存储的地址值不变</span><br></pre></td></tr></table></figure><h4 id="block-1"><a href="#block-1" class="headerlink" title="___block"></a><code>___block</code></h4><p>解决循环引用还有一种方法就是使用<code>___block</code>修饰，如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="keyword">typeof</span>(person) weakPerson = person;</span><br><span class="line">person.block = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"age is %d"</span>, weakPerson.age);</span><br><span class="line">    weakPerson = <span class="literal">nil</span>;</span><br><span class="line">&#125;;</span><br><span class="line">person.block();</span><br></pre></td></tr></table></figure><p>分析：<br>此时内部会有3个对象，分别是block对象、<strong>block对象、</strong>block对象内部的person对象。<br>其中block对象会强引用着<strong>block对象，</strong>block对象内部会强引用着person对象，但是我们上面的代码，在block的实现里面，当block内代码走完时，手动把内部的person指针置为nil，此时<strong>block就不会对person对象强引用，就可以打破循环引用了。<br>![使用</strong>block打破循环引用](<a href="https://cdn.ticsmatic.com/img/2020-05-21/15900751183030.png" target="_blank" rel="noopener">https://cdn.ticsmatic.com/img/2020-05-21/15900751183030.png</a>)</p><h3 id="MRC下循环引用的解决"><a href="#MRC下循环引用的解决" class="headerlink" title="MRC下循环引用的解决"></a>MRC下循环引用的解决</h3><p>MRC不支持__weak，</p><ol><li>可以使用__unsafe_unretained</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">unsafe_unretained</span> <span class="keyword">typeof</span>(person) weakPerson = person;</span><br><span class="line">person.block = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"age is %d"</span>, weakPerson.age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li>可以使用<strong>_block，因为</strong>block修饰对象类型的变量，在MRC下是不会自动持有对象的<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="keyword">typeof</span>(person) weakPerson = person;</span><br><span class="line">person.block = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"age is %d"</span>, weakPerson.age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2>在解决循环引用时，有一种常见的写法是在block内部使用__strong，我们看这段代码</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    <span class="keyword">self</span>.block = ^&#123;</span><br><span class="line">        __<span class="keyword">strong</span> <span class="keyword">typeof</span>(weakSelf) strongSelf = weakSelf;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"age is %d"</span>, strongSelf-&gt;_age);</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>解决循环引用时，使用<strong>weak类型的对象，但是当执行block内部的逻辑代码时，如果self被释放，此时block访问释放的self就会挂，在block里面使用的</strong>strong修饰的weakSelf是为了在函数生命周期中防止self提前释放。strongSelf是一个自动变量当block执行完毕就会释放自动变量，strongSelf不会对self进行一直进行强引用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>block本质上也是一个OC对象，它内部也有个isa指针</p><p>block是封装了函数调用以及函数调用环境的OC对象</p><p>block的底层结构如图所示<br><img src="https://cdn.ticsmatic.com/img/2020-05-20/15899515914959.jpeg" alt="block底层结构"></p><h2 id="参考和源码"><a href="#参考和源码" class="headerlink" title="参考和源码"></a>参考和源码</h2><p>Demo源码：<br><a href="https://cdn.ticsmatic.com/source/2020-05-21/diceng/day09/Interview04-__block.zip" target="_blank" rel="noopener">__block底层-Demo</a><br><a href="https://cdn.ticsmatic.com/source/2020-05-21/diceng/day10/Interview01-__block.zip" target="_blank" rel="noopener">__block转结构体-Demo</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>block详解</title>
      <link href="/p/95e305cc/"/>
      <url>/p/95e305cc/</url>
      
        <content type="html"><![CDATA[<p>学习MJ的视频课程，整理总结知识点–block详解</p><blockquote><p>block是OC中实用频率很高的一个功能，同时在其它语言中也有相似的特性，比如swift中的闭包，Python中的闭包等。</p></blockquote><p>本文先通过简单介绍block的使用，然后通过<code>clang</code>重新编译导出block的一些源码来了解block的底层结构，随后会介绍block中的重要知识点<code>1. block中的变量捕获，2. block的类型</code></p><a id="more"></a><h2 id="block的使用"><a href="#block的使用" class="headerlink" title="block的使用"></a>block的使用</h2><p>在OC中使用block，大致如下</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现一个最简单的block</span></span><br><span class="line">^&#123;&#125;;</span><br><span class="line"><span class="comment">// 实现并调用</span></span><br><span class="line">^&#123;&#125;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明并指向一个block</span></span><br><span class="line"><span class="keyword">void</span> (^block)(<span class="keyword">void</span>) = ^&#123;&#125;;</span><br><span class="line"><span class="keyword">void</span> (^block2)(<span class="keyword">int</span>, <span class="keyword">int</span>) = ^(<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;&#125;;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">block();</span><br><span class="line">block2(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先声明block</span></span><br><span class="line"><span class="keyword">void</span> (^block3)(<span class="keyword">int</span>);</span><br><span class="line"><span class="comment">// 实现block</span></span><br><span class="line">block3 = ^(<span class="keyword">int</span> a)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">block3(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>我们要明白，哪些是block声明、哪些是实现、哪些是调用，使用上就不会弄混了。</p><h2 id="block源码解析"><a href="#block源码解析" class="headerlink" title="block源码解析"></a>block源码解析</h2><p>下面我们通过一个<a href="https://cdn.ticsmatic.com/source/2020-05-14/diceng/day08/Interview01-Block.zip" target="_blank" rel="noopener">Demo</a>分析block的底层源码</p><p>思路是把包含block代码的文件通过clang命令重写导出，就可以看到block的源码了。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> (^block)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"Hello, World!"</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        block();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>clang</code>命令重写导出为cpp文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -rewrite-objc main.m -o main0.cpp</span><br></pre></td></tr></table></figure><p>我们观察生成的<code>main0.cpp</code>文件中main函数部分，去掉里面不重要的类型转转换代码后，如下</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义block变量</span></span><br><span class="line"><span class="keyword">void</span> (*block)(<span class="keyword">void</span>) = &amp;__main_block_impl_0(</span><br><span class="line">                        __main_block_func_0,</span><br><span class="line">                        &amp;__main_block_desc_0_DATA</span><br><span class="line">                        );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行block内部的代码</span></span><br><span class="line"><span class="comment">// ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span></span><br><span class="line"><span class="comment">// 因为__block_impl是第一个变量，所以和__main_block_impl_0的地址相同，所以__main_block_impl_0可以强转为__block_impl进行</span></span><br><span class="line">block-&gt;FuncPtr(block);</span><br></pre></td></tr></table></figure><h3 id="main-block-impl-0"><a href="#main-block-impl-0" class="headerlink" title="__main_block_impl_0"></a>__main_block_impl_0</h3><p>我们从定义block变量入手分析，我们查看<code>__main_block_impl_0</code>，发现这一步是结构体有返回值，查看它的定义如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line">  <span class="comment">// c++构造函数（类似于OC的init方法），返回结构体对象</span></span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>__main_block_impl_0</code>的内部有<code>__block_impl</code>、<code>__main_block_desc_0</code>、以及一个构造函数<code>__main_block_impl_0</code>，类似OC的init方法，通过构造函数给结构体的变量赋值，最后返回结构体。</p><h3 id="block-impl"><a href="#block-impl" class="headerlink" title="__block_impl"></a>__block_impl</h3><p>接下来分析<code>__block_impl</code>，它的定义如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __block_impl &#123;</span><br><span class="line">    <span class="keyword">void</span> *isa;</span><br><span class="line">    <span class="keyword">int</span> Flags;</span><br><span class="line">    <span class="keyword">int</span> Reserved;</span><br><span class="line">    <span class="keyword">void</span> *FuncPtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>__block_impl</code>是一个结构体，它的内部两个地方需要注意，<code>void *isa</code>和<code>void *FuncPtr</code>。isa很像之前学习的OC对象，我们知道OC对象中的isa是指向类的，我们可以提出一个疑问：block是OC对象吗，它的isa指向哪里。</p><p>另外，<code>void *FuncPtr</code>是个指针，它指向哪里？我们在下面的文章中再讲解这两个问题。</p><h3 id="main-block-func-0"><a href="#main-block-func-0" class="headerlink" title="__main_block_func_0"></a>__main_block_func_0</h3><p>回到主题，已经明白了<code>__main_block_func_0</code>的结构，那么接下来可以查看<code>__main_block_func_0</code>的的接口，如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 封装了block执行逻辑的函数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_2r__m13fp2x2n9dvlr8d68yry500000gn_T_main_c60393_mi_0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个<code>__main_block_func_0</code>内部其实就是我们在OC中写的下面这段代码</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Hello, World!"</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>所以我们可以知道<code>__main_block_func_0</code>实际上就是block内执行的函数代码。</p><p>还有一个地方就是<code>__main_block_desc_0</code>，它的定义如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0)&#125;;</span><br></pre></td></tr></table></figure><p>从这里我们可以了解到，<code>__main_block_desc_0_DATA</code>是获取block结构体的大小，其中<code>reserved</code>是扩展保留字。</p><p>我们回到<code>__main_block_impl_0</code>的构造函数，我们发现<code>FuncPtr</code>是指向<code>__main_block_func_0</code>，也是就block的执行逻辑的函数，故可以理解为<code>FuncPtr</code>指向block的执行函数地址。</p><p>通过block的源码学习我们可以得知：<br>block本质是结构体，且有isa指针(实际上block本质也是一个OC对象)<br><code>__main_block_impl_0</code>是block的结构体的主要信息</p><p>根据block的底层源码学习，可以总结更直观的的图示，如下<br><img src="https://cdn.ticsmatic.com/img/2020-05-14/1589880805.png" alt="block底层"></p><h2 id="block变量捕获"><a href="#block变量捕获" class="headerlink" title="block变量捕获"></a>block变量捕获</h2><p>通过上面的雨那么分析，我们了解了block的底层结构，下面我们分析一下block中经常用到的变量捕获，同样使用上面的<a href="https://cdn.ticsmatic.com/source/2020-05-14/diceng/day08/Interview01-Block.zip" target="_blank" rel="noopener">Demo</a>进行分析</p><blockquote><p>当在block内访问外部变量时，可能会触发变量捕获。</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> height = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">void</span> (^block)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">    <span class="comment">// age的值捕获进来（capture）</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"age is %d, height is %d"</span>, age, height); </span><br><span class="line">    <span class="comment">// age is 10, height is 20</span></span><br><span class="line">&#125;;</span><br><span class="line">age = <span class="number">20</span>;</span><br><span class="line">height = <span class="number">20</span>;</span><br><span class="line">block();</span><br></pre></td></tr></table></figure><p>根据经验我们知道，当调用block时，输出的结果为<code>age is 10, height is 20</code>，下面我们分析为什么会是这样，并总结规律。</p><p>首先，我们对这部分代码用clang重写导出为<code>cpp</code>文件，观察源码中block相关的部分，我们发现</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">  <span class="keyword">int</span> *height;</span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">int</span> _age, <span class="keyword">int</span> *_height, <span class="keyword">int</span> flags=<span class="number">0</span>) : age(_age), height(_height) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们发现，结构体<code>__main_block_impl_0</code>里面多了两个字段<code>int age</code>、<code>int *height</code>，其中<code>age</code>是数值型，<code>height</code>是指针型。</p><p>我们分析调用顺序</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> height = <span class="number">10</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> (*block)(<span class="keyword">void</span>) = &amp;__main_block_impl_0(</span><br><span class="line">                        __main_block_func_0,</span><br><span class="line">                        &amp;__main_block_desc_0_DATA,</span><br><span class="line">                        age,</span><br><span class="line">                        &amp;height</span><br><span class="line">                        );</span><br></pre></td></tr></table></figure><p>可以发现<code>age</code>的值，直接被传递到<code>__main_block_impl_0</code>结构体中，这个结构体的构造函数会保存这个age的值，而<code>height</code>是指针传递，结构体中也有对应的<code>height</code>，但是是一个指针类型的。所以，结构体内部仅持有static类型变量的指针，当外接<code>height</code>的值发生改变时，block内获取到的height也会相应改变。</p><p>在block结构体内部创建<code>age</code>、<code>height</code>保存访问的外部变量的过程，我们称之为<code>变量捕获</code>。变量捕获是<strong>为了保证block内部能正常访问外部变量</strong>。</p><p>什么情况不需要变量捕获呢，其实我们可以推断一下，变量捕获的目的是为了保证block内部能正常访问外部的变量。假如访问的外部变量是一个全局变量，那么block随时都可以访问到这个全局变量，此时block就不需要捕获，而是直接访问这个全局变量。</p><p>总结：<br><img src="https://cdn.ticsmatic.com/img/2020-05-14/1589879780.png" alt="block变量捕获原则"><br>局部变量，block要访问的话就会捕获<br>全局变量，不会捕获，直接访问</p><p>还有一种比较常见的场景，比如在一个方法中，block访问self的属性</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MJPerson</span></span></span><br><span class="line">- (<span class="keyword">void</span>)test &#123;</span><br><span class="line">    <span class="keyword">void</span> (^block)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"-------%@"</span>, <span class="keyword">self</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    block();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>此时block是够会捕获self变量或者self.name变量呢，答案是会，我们可以查看clang导出的对应源码，如下</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __MJPerson__test_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __MJPerson__test_block_desc_0* Desc;</span><br><span class="line">  MJPerson *<span class="keyword">self</span>;</span><br><span class="line">  __MJPerson__test_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __MJPerson__test_block_desc_0 *desc, MJPerson *_<span class="keyword">self</span>, <span class="keyword">int</span> flags=<span class="number">0</span>) : <span class="keyword">self</span>(_<span class="keyword">self</span>) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看到确实是捕获了，而且捕获的是self这个变量。我们可以分析一下原因：<br>以为self是<code>test</code>函数的默认参数（self和cmd），而self又不是全局变量，根据上面的总结，block访问局部变量都会进行捕获，而要访问的<code>name</code>属于self的对象的一个属性，所以block就不捕获self，通过self访问其中的<code>name</code>。</p><h2 id="block类型"><a href="#block类型" class="headerlink" title="block类型"></a>block类型</h2><p>我们知道block有isa，那么这个isa是否来自<code>NSObject</code>，block的isa是否代表它是对象类型的结构</p><p>可以先假设block是对象类型，那么调用<code>[block class]</code>时，必然会返回对应的类型，通过下面这段代码进行测试</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (^block)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Hello"</span>);</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [block <span class="keyword">class</span>]); <span class="comment">// __NSGlobalBlock__</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [[block <span class="keyword">class</span>] superclass]); <span class="comment">// __NSGlobalBlock</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [[[block <span class="keyword">class</span>] superclass] superclass]); <span class="comment">// NSBlock</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [[[[block <span class="keyword">class</span>] superclass] superclass]  superclass]); <span class="comment">// NSObject</span></span><br></pre></td></tr></table></figure><p>通过上面代码可以确认block确实是有class的，isa指针是来自<code>NSObject</code>。我们可以进一步总结：</p><ol><li>block本质上也是一个OC对象，它内部也有个isa指针</li><li>block是封装了函数调用以及函数调用环境的OC对象</li></ol><p>实际上，block有3种类型，可以通过调用class方法或者isa指针查看具体类型，最终都是继承自NSBlock<br><strong>NSGlobalBlock</strong> （ <em>NSConcreteGlobalBlock ）<br><em>_NSStackBlock</em></em> （ <em>NSConcreteStackBlock ）<br><em>_NSMallocBlock</em></em> （ _NSConcreteMallocBlock ）</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 堆：动态分配内存,需要程序员申请申请，也需要程序员自己管理内存</span></span><br><span class="line"><span class="keyword">void</span> (^block1)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Hello"</span>);</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">void</span> (^block2)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Hello - %d"</span>, age);</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@ %@ %@"</span>, [block1 <span class="keyword">class</span>], [block2 <span class="keyword">class</span>], [^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%d"</span>, age); <span class="comment">// __NSGlobalBlock__ __NSMallocBlock__ __NSStackBlock__</span></span><br><span class="line">&#125; <span class="keyword">class</span>]);</span><br></pre></td></tr></table></figure><p>我们现在知道了block有3种类型，那么它们的区别是什么？</p><p>其实从名字分析，我们就看会发现一些特点<code>Global</code>，<code>Stack</code>，<code>Malloc</code>，实际上它们对应是在内存中的区域。如下<br><img src="https://cdn.ticsmatic.com/img/2020-05-20/15899504631173.png" alt="block所在的内存区域"></p><blockquote><p>程序区域：一般存放的是函数<br>数据区域：一般存放的是全局变量<br>堆区：动态分配内存，比如我们alloc出来的对象，需要开发者申请，释放对应的内存<br>栈区：自动分配内存局，系统自动管理，存放局部变量，函数中变量等</p></blockquote><p>block存储在不同的内存区域，是根据什么来划分的？我们先给出总结的结果</p><table><thead><tr><th>block类型</th><th>环境</th></tr></thead><tbody><tr><td><strong>NSGlobalBlock</strong></td><td>没有访问auto变量</td></tr><tr><td><strong>NSStackBlock</strong></td><td>访问了auto变量</td></tr><tr><td><strong>NSMallocBlock</strong></td><td><strong>NSStackBlock</strong>调用了copy</td></tr></tbody></table><blockquote><p>实际上我们现在在项目中很少遇到<code>__NSStackBlock__</code>类型的block，因为在ARC环境下，<code>__NSStackBlock__</code>类型的block在使用的是否，系统会自动把它copy到堆上去，成为<code>__NSMallocBlock__</code>类型，所以我们在测试的时候，需要把ARC环境关闭(Automatic Reference Counting改为NO)才能验证</p></blockquote><hr><blockquote><p>copy到堆上是为了不让程序自动管理，交由开发者管理它的释放时机</p></blockquote><p>每一种类型的block调用copy后的结果如下所示<br><img src="https://cdn.ticsmatic.com/img/2020-05-20/15899507304918.png" alt="block调用copy后"></p><p>关于判断存储的内存区域，我们有一个简单的方法，就是看内存地址和哪一个已知区域的地址接近</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">void</span> test() &#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"数据段：age %p"</span>, &amp;age);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"数据段：class %p"</span>, [MJPerson <span class="keyword">class</span>]);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"堆：obj %p"</span>, [[<span class="built_in">NSObject</span> alloc] init]);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"栈：a %p"</span>, &amp;a);</span><br><span class="line">    <span class="comment">// 同一个内存区域的内存地址值比较接近</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>根据本节所学的block知识，我们可以总结一下</p><ol><li>block本质上也是一个OC对象，它内部也有个isa指针</li><li>block是封装了函数调用以及函数调用环境的OC对象</li><li>block的底层结构如右图所示<br><img src="https://cdn.ticsmatic.com/img/2020-05-20/15899515914959.jpeg" alt="block底层结构"></li></ol><p><img src="https://cdn.ticsmatic.com/img/2020-05-14/1589879780.png" alt="block变量捕获原则"></p><p>auto变量的捕获<br><img src="https://cdn.ticsmatic.com/img/2020-05-14/1589880805.png" alt="block底层"></p><p>block有3种类型，可以通过调用class方法或者isa指针查看具体类型，最终都是继承自NSBlock类型<strong>NSGlobalBlock</strong> （ <em>NSConcreteGlobalBlock ）<em>_NSStackBlock</em></em> （ <em>NSConcreteStackBlock ）<em>_NSMallocBlock</em></em> （ _NSConcreteMallocBlock ）<br><img src="https://cdn.ticsmatic.com/img/2020-05-20/15899504631173.png" alt="block所在的内存区域"></p><table><thead><tr><th>block类型</th><th>环境</th></tr></thead><tbody><tr><td><strong>NSGlobalBlock</strong></td><td>没有访问auto变量</td></tr><tr><td><strong>NSStackBlock</strong></td><td>访问了auto变量</td></tr><tr><td><strong>NSMallocBlock</strong></td><td><strong>NSStackBlock</strong>调用了copy</td></tr></tbody></table><p>每一种类型的block调用copy后的结果如下所示<br><img src="https://cdn.ticsmatic.com/img/2020-05-20/15899507304918.png" alt="block调用copy后"></p><h2 id="参考和源码"><a href="#参考和源码" class="headerlink" title="参考和源码"></a>参考和源码</h2><p>Demo源码：<br><a href="https://cdn.ticsmatic.com/source/2020-05-14/diceng/day08/Interview01-Block.zip" target="_blank" rel="noopener">Block底层-Demo</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>load initialize的本质</title>
      <link href="/p/4235a91d/"/>
      <url>/p/4235a91d/</url>
      
        <content type="html"><![CDATA[<p>学习MJ的视频课程，整理总结知识点–load initialize的本质</p><p>这一篇通过<code>+load</code>和<code>+initialize</code>的官方文档并结合Demo来介绍这两个方法。同时会依据runtime源码来介绍<code>+load</code>和<code>+initialize</code>底层的逻辑。</p><a id="more"></a><p>[TOC]</p><h2 id="load介绍"><a href="#load介绍" class="headerlink" title="+load介绍"></a>+load介绍</h2><p>关于<code>+load</code>，我们知道<strong>+load方法会在runtime加载类、分类时调用</strong>，apple文档中关于load介绍如下</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Summary</span><br><span class="line"></span><br><span class="line">Invoked whenever a <span class="keyword">class</span> or category is added to the Objective-C runtime; implement <span class="keyword">this</span> method to perform <span class="keyword">class</span>-specific behavior upon loading.</span><br><span class="line"></span><br><span class="line">Declaration</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load;</span><br><span class="line">Discussion</span><br><span class="line"></span><br><span class="line">The load message is sent to classes and categories that are both dynamically loaded and statically linked, but only <span class="keyword">if</span> the newly loaded <span class="keyword">class</span> or category implements a method that can respond.</span><br><span class="line">The order of initialization is as follows:</span><br><span class="line">All initializers <span class="keyword">in</span> any framework you link to.</span><br><span class="line">All +load methods <span class="keyword">in</span> your image.</span><br><span class="line">All C++ <span class="keyword">static</span> initializers and C/C++ __attribute__(constructor) functions <span class="keyword">in</span> your image.</span><br><span class="line">All initializers <span class="keyword">in</span> frameworks that link to you.</span><br><span class="line"></span><br><span class="line">In addition:</span><br><span class="line">A <span class="keyword">class</span>’s +load method is called after all of its superclasses’ +load methods.</span><br><span class="line">A category +load method is called after the <span class="keyword">class</span>’s own +load method.</span><br><span class="line">In a custom implementation of load you can therefore safely message other unrelated classes from the same image, but any load methods implemented by those classes may not have run yet.</span><br><span class="line"></span><br><span class="line">Important</span><br><span class="line">Custom implementations of the load method <span class="keyword">for</span> Swift classes bridged to Objective-C are not called automatically.</span><br></pre></td></tr></table></figure><p>结合文档我们知道</p><ol><li>+load方法会在runtime加载类、分类时调用</li><li>每个类、分类的+load，在程序运行过程中只调用一次</li><li>先调用类的+load，再调用分类的+load</li><li>调用子类的+load之前会先调用父类的+load</li></ol><h2 id="load调用原理"><a href="#load调用原理" class="headerlink" title="+load调用原理"></a>+load调用原理</h2><p>我们知道<code>+load</code>是在runtime添加到运行时的时候调用，所以我们可以从runtime源码入手，查找并分析<code>+load</code>的调用原理</p><p>结合上一篇文章，我们知道runtime的初始化方法是<code>_objc_init</code>，这个函数内部有这个方法<code>_dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</code>，其中，<code>load_images</code><br>就是我们剖析<code>+load</code>机制的入口。我们看一下<code>load_images</code>函数的源码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* load_images</span></span><br><span class="line"><span class="comment">* Process +load in the given images which are being mapped in by dyld.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Locking: write-locks runtimeLock and loadMethodLock</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">load_images(<span class="keyword">const</span> <span class="keyword">char</span> *path __unused, <span class="keyword">const</span> <span class="keyword">struct</span> mach_header *mh)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Return without taking locks if there are no +load methods here.</span></span><br><span class="line">    <span class="keyword">if</span> (!hasLoadMethods((<span class="keyword">const</span> headerType *)mh)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    recursive_mutex_locker_t lock(loadMethodLock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Discover load methods</span></span><br><span class="line">    &#123;</span><br><span class="line">        rwlock_writer_t lock2(runtimeLock);</span><br><span class="line">        prepare_load_methods((<span class="keyword">const</span> headerType *)mh);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call +load methods (without runtimeLock - re-entrant)</span></span><br><span class="line">    call_load_methods();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数内部主要分3步（<strong>判断、查找并添加、调用</strong>），我们对这3个步骤用通俗易懂的语言进行概述：</p><ol><li>判断有没有<code>+load</code>方法，没有的话直接return；</li><li>有的话就添加到一个数据保存起来；</li><li>遍历这个数据，调用每个元素的<code>+load</code>方法。</li></ol><p>下面进行每一步的介绍。</p><h3 id="1-hasLoadMethods"><a href="#1-hasLoadMethods" class="headerlink" title="1. hasLoadMethods"></a>1. hasLoadMethods</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Quick scan for +load methods that doesn't take a lock.</span></span><br><span class="line"><span class="keyword">bool</span> hasLoadMethods(<span class="keyword">const</span> headerType *mhdr)</span><br><span class="line">&#123;</span><br><span class="line">    size_t count;</span><br><span class="line">    <span class="keyword">if</span> (_getObjc2NonlazyClassList(mhdr, &amp;count)  &amp;&amp;  count &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (_getObjc2NonlazyCategoryList(mhdr, &amp;count)  &amp;&amp;  count &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数概述为就是快速查找所有的class、category里面是否包含<code>+load</code>方法。<br>(注：实现了<code>+load</code>方法的class才属于<code>NonlazyClass</code>)</p><h3 id="2-prepare-load-methods"><a href="#2-prepare-load-methods" class="headerlink" title="2. prepare_load_methods"></a>2. prepare_load_methods</h3><p>判断完之后就是查找所有的<code>+load</code>方法，<code>prepare_load_methods</code>函数的主要代码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> prepare_load_methods(<span class="keyword">const</span> headerType *mhdr)</span><br><span class="line">&#123;</span><br><span class="line">    size_t count, i;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertWriting();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历有+load的class，添加到'loadable_classes'中(有superclass的，先递归添加superclass)，把class标记为'RW_LOADED'</span></span><br><span class="line">    classref_t *classlist = </span><br><span class="line">        _getObjc2NonlazyClassList(mhdr, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        schedule_class_load(remapClass(classlist[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历有+load的category，做一些逻辑判断，然后添加到'loadable_categories'</span></span><br><span class="line">    category_t **categorylist = _getObjc2NonlazyCategoryList(mhdr, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        category_t *cat = categorylist[i];</span><br><span class="line">        Class cls = remapClass(cat-&gt;cls);</span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>;  <span class="comment">// category for ignored weak-linked class</span></span><br><span class="line">        realizeClass(cls);</span><br><span class="line">        assert(cls-&gt;ISA()-&gt;isRealized());</span><br><span class="line">        add_category_to_loadable_list(cat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个过程把包含有<code>+load</code>方法的class添加到数组<code>loadable_classes</code>中，把包含有<code>+load</code>方法的category添加到数组<code>loadable_categories</code>中。</p><p><code>prepare_load_methods</code>过程中，内部有一个<code>schedule_class_load</code>方法需要讲解一下，它的实现如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* prepare_load_methods</span></span><br><span class="line"><span class="comment">* Schedule +load for classes in this image, any un-+load-ed </span></span><br><span class="line"><span class="comment">* superclasses in other images, and any categories in this image.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="comment">// Recursively schedule +load for cls and any un-+load-ed superclasses.</span></span><br><span class="line"><span class="comment">// cls must already be connected.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> schedule_class_load(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span>;</span><br><span class="line">    assert(cls-&gt;isRealized());  <span class="comment">// _read_images should realize</span></span><br><span class="line">    <span class="comment">// 判断class结构体信息中是否加载的标记</span></span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;data()-&gt;flags &amp; RW_LOADED) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ensure superclass-first ordering，通过递归的方式先取出superclass</span></span><br><span class="line">    schedule_class_load(cls-&gt;superclass);</span><br><span class="line">    <span class="comment">// 添加到数组中保存起来</span></span><br><span class="line">    add_class_to_loadable_list(cls);</span><br><span class="line">    <span class="comment">// cls标记为已加载</span></span><br><span class="line">    cls-&gt;setInfo(RW_LOADED); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数内部有个递归调用，先去class的superclass添加到数组中，这就解释了<strong>子类<code>+load</code>方法调用时，会先调用父类的<code>+load</code>这一现象</strong>。</p><h3 id="3-call-load-methods"><a href="#3-call-load-methods" class="headerlink" title="3. call_load_methods"></a>3. call_load_methods</h3><p>添加到<code>loadable_classes</code>数组和数组<code>loadable_categories</code>后，就是遍历数组，调用数组元素的<code>+load</code>方法。函数主要内容如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* call_load_methods</span></span><br><span class="line"><span class="comment">* Call all pending class and category +load methods.</span></span><br><span class="line"><span class="comment">* Class +load methods are called superclass-first. </span></span><br><span class="line"><span class="comment">* Category +load methods are not called until after the parent class's +load.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="keyword">void</span> call_load_methods(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> loading = <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">bool</span> more_categories;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Re-entrant calls do nothing; the outermost call will finish the job.</span></span><br><span class="line">    <span class="keyword">if</span> (loading) <span class="keyword">return</span>;</span><br><span class="line">    loading = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *pool = objc_autoreleasePoolPush();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 1. Repeatedly call class +loads until there aren't any more</span></span><br><span class="line">        <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            call_class_loads();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. Call category +loads ONCE</span></span><br><span class="line">        more_categories = call_category_loads();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. Run more +loads if there are classes OR more untried categories</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>  ||  more_categories);</span><br><span class="line"></span><br><span class="line">    objc_autoreleasePoolPop(pool);</span><br><span class="line"></span><br><span class="line">    loading = <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察<code>call_load_methods</code>函数的实现我们得知，内部<strong>会先调用class的<code>+load</code>方法，之后才会调用category的<code>+load</code>方法</strong>。</p><p>接下来看下runtime是怎么自动调用<code>+load</code>方法的，在<code>call_class_loads</code>函数内部我们可以找到答案，<code>call_class_loads</code>的概要源码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> call_class_loads(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Detach current loadable list.</span></span><br><span class="line">    <span class="keyword">struct</span> loadable_class *classes = loadable_classes;</span><br><span class="line">    <span class="keyword">int</span> used = loadable_classes_used;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; used; i++) &#123;</span><br><span class="line">          <span class="comment">// 取出class</span></span><br><span class="line">        Class cls = classes[i].cls;</span><br><span class="line">        <span class="comment">// 拿到保存的'+load'方法</span></span><br><span class="line">        load_method_t load_method = (load_method_t)classes[i].method;</span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 直接手动调用'+load'方法</span></span><br><span class="line">        (*load_method)(cls, SEL_load);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Destroy the detached list.</span></span><br><span class="line">    <span class="keyword">if</span> (classes) free(classes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以我们可以得知，<strong><code>+load</code>方法是默认通过函数地址直接调用，而不是通过OC通用的runtime消息机制</strong></p><h2 id="load总结"><a href="#load总结" class="headerlink" title="+load总结"></a>+load总结</h2><ol><li>+load方法会在runtime加载类、分类时调用</li><li>每个类、分类的+load，在程序运行过程中只调用一次</li><li>调用顺序<ul><li>先调用类的+load<ul><li>按照编译先后顺序调用（先编译，先调用）</li><li>调用子类的+load之前会先调用父类的+load</li></ul></li><li>再调用分类的+load<ul><li>按照编译先后顺序调用（先编译，先调用）</li></ul></li></ul></li></ol><h2 id="initialize介绍"><a href="#initialize介绍" class="headerlink" title="+initialize介绍"></a>+initialize介绍</h2><p>关于<code>+initialize</code>，我们知道<strong>+initialize方法会在类第一次接收到消息时调用</strong>，apple文档中关于initialize介绍如下</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Summary</span><br><span class="line"></span><br><span class="line">Initializes the <span class="keyword">class</span> before it receives its first message.</span><br><span class="line"></span><br><span class="line">Declaration</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)initialize;</span><br><span class="line"></span><br><span class="line">Discussion</span><br><span class="line"></span><br><span class="line">The runtime sends initialize to each <span class="keyword">class</span> <span class="keyword">in</span> a program just before the <span class="keyword">class</span>, or any <span class="keyword">class</span> that inherits from it, is sent its first message from within the program. Superclasses receive <span class="keyword">this</span> message before their subclasses.</span><br><span class="line">The runtime sends the initialize message to classes <span class="keyword">in</span> a thread-safe manner. That is, initialize is run by the first thread to send a message to a <span class="keyword">class</span>, and any other thread that tries to send a message to that <span class="keyword">class</span> will block until initialize completes.</span><br><span class="line">The superclass implementation may be called multiple times <span class="keyword">if</span> subclasses <span class="keyword">do</span> not implement initialize—the runtime will call the inherited implementation—or <span class="keyword">if</span> subclasses explicitly call [<span class="keyword">super</span> initialize]. If you want to protect yourself from being run multiple times, you can structure your implementation along these lines:</span><br><span class="line">+ (<span class="keyword">void</span>)initialize &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">self</span> == [ClassName <span class="keyword">self</span>]) &#123;</span><br><span class="line">    <span class="comment">// ... do the initialization ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Because initialize is called <span class="keyword">in</span> a blocking manner, it’s important to limit method implementations to the minimum amount of work necessary possible. Specifically, any code that takes locks that might be required by other classes <span class="keyword">in</span> their initialize methods is liable to lead to deadlocks. Therefore, you should not rely on initialize <span class="keyword">for</span> complex initialization, and should instead limit it to straightforward, <span class="keyword">class</span> local initialization.</span><br></pre></td></tr></table></figure><p>结合文档和之前的知识我们知道</p><ol><li>+initialize方法会在类第一次接收到消息时调用</li><li>先调用父类的+initialize，再调用子类的+initialize</li><li>(先初始化父类，再初始化子类，每个类只会初始化1次)</li><li>+initialize方法是线程安全的，要注意防止+initialize死锁，不要再+initialize内做太复杂的事情</li></ol><h2 id="initialize原理"><a href="#initialize原理" class="headerlink" title="+initialize原理"></a>+initialize原理</h2><p>我们知道了<code>+initialize</code>的特性，接下来我们通过runtime源码分析<code>+initialize</code>的原理。我们已经知道<code>+initialize</code>是第一次接收到消息时调用，我们以此为切入点进行分析。</p><p><code>第一次接收到消息</code>，意味着第一次<code>objc_msgSend(cls, @selector(xxx))</code>，怎么知道是第一次呢，猜测应该是在<code>objc_msgSend</code>前先进行判断有没有<code>initialize</code>标记，没有的话先调用<code>+initialize</code>，然后再继续原有流程。</p><p>还有一个查找源码的切入点是<code>+initialize</code>调用之后的<strong>标记值</strong>，因为我们已经知道一个class只会<code>initialize</code>一次，<code>+load</code>也是只会调用一次。同时在前面学习<code>+load</code>调用流程时从源码中知道，load完成时会有一步做标记<code>cls-&gt;setInfo(RW_LOADED);</code>，我们猜测：<code>+initialize</code>也会有类似的标记，仿照格式应该为<code>RW_INITIALIZED</code>。我们去runtime源码中搜索，果真找到这个<code>RW_INITIALIZED</code>，它对应的函数如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> isInitialized() &#123;</span><br><span class="line">    <span class="keyword">return</span> getMeta()-&gt;data()-&gt;flags &amp; RW_INITIALIZED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过我们的目的是分析什么时候调用<code>+initialize</code>，已经知道了这个<code>initialize</code>前的判断方法<code>isInitialized()</code>，我们就可以<code>顺瓜摸藤</code>，通过在objc源码中搜索<code>isInitialized()</code>这个方法，同时知道这个方法应该在<code>objc_msgSend</code>前调用，所以我们可以进一步缩小搜索范围。</p><p>通过分析搜索结果，我们几乎可以确定唯一与结果相关的就是<code>lookUpImpOrForward</code>函数，该函数概要内容如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* lookUpImpOrForward.</span></span><br><span class="line"><span class="comment">* The standard IMP lookup. </span></span><br><span class="line"><span class="comment">* initialize==NO tries to avoid +initialize (but sometimes fails)</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line">IMP lookUpImpOrForward(Class cls, SEL sel, <span class="keyword">id</span> inst, </span><br><span class="line">                       <span class="keyword">bool</span> initialize, <span class="keyword">bool</span> cache, <span class="keyword">bool</span> resolver)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialize  &amp;&amp;  !cls-&gt;isInitialized()) &#123;</span><br><span class="line">        runtimeLock.unlockRead();</span><br><span class="line">        _class_initialize (_class_getNonMetaClass(cls, inst));</span><br><span class="line">        runtimeLock.read();</span><br><span class="line">        <span class="comment">// If sel == initialize, _class_initialize will send +initialize and </span></span><br><span class="line">        <span class="comment">// then the messenger will send +initialize again after this </span></span><br><span class="line">        <span class="comment">// procedure finishes. Of course, if this is not being called </span></span><br><span class="line">        <span class="comment">// from the messenger then it won't happen. 2778172</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数内部有个逻辑，就是判断有没有initialized，没有的话，就调用<code>_class_initialize</code>方法进行初始化。这样我们就从晦涩的源码中找到我们的线索，我们就通过这条线索来分析<code>+initialize</code>方法的底层原理。</p><p>我们通过搜索<code>lookUpImpOrForward</code>函数，发现是<code>class_getClassMethod</code>调用来<code>lookUpImpOrForward</code>的。我们正向分析一下。如果要对class发消息，肯定要判断消息对应的<code>Method</code>是否存在，这就需要<code>class_getClassMethod</code>这个函数来实现，正向推理也合理。</p><p>接下来我们继续分析<code>_class_initialize</code>的实现，探究initialize过程做了哪些事情。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* class_initialize.  Send the '+initialize' message on demand to any</span></span><br><span class="line"><span class="comment">* uninitialized class. Force initialization of superclasses first.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="keyword">void</span> _class_initialize(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    assert(!cls-&gt;isMetaClass());</span><br><span class="line"></span><br><span class="line">    Class supercls;</span><br><span class="line">    <span class="keyword">bool</span> reallyInitialize = <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure super is done initializing BEFORE beginning to initialize cls.</span></span><br><span class="line">    <span class="comment">// See note about deadlock above.</span></span><br><span class="line">    <span class="comment">// 先判断supercls是否初始化，没有的话通过递归先初始化supercls</span></span><br><span class="line">    supercls = cls-&gt;superclass;</span><br><span class="line">    <span class="keyword">if</span> (supercls  &amp;&amp;  !supercls-&gt;isInitialized()) &#123;</span><br><span class="line">        _class_initialize(supercls);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Try to atomically set CLS_INITIALIZING.</span></span><br><span class="line">    &#123;</span><br><span class="line">        monitor_locker_t lock(classInitLock);</span><br><span class="line">        <span class="keyword">if</span> (!cls-&gt;isInitialized() &amp;&amp; !cls-&gt;isInitializing()) &#123;</span><br><span class="line">            cls-&gt;setInitializing();</span><br><span class="line">            reallyInitialize = <span class="literal">YES</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (reallyInitialize) &#123;</span><br><span class="line">        <span class="comment">// We successfully set the CLS_INITIALIZING bit. Initialize the class.</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Record that we're initializing this class so we can message it.</span></span><br><span class="line">        _setThisThreadIsInitializingClass(cls);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (MultithreadedForkChild) &#123;</span><br><span class="line">            <span class="comment">// LOL JK we don't really call +initialize methods after fork().</span></span><br><span class="line">            performForkChildInitialize(cls, supercls);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Send the +initialize message.</span></span><br><span class="line">        <span class="comment">// Note that +initialize is sent to the superclass (again) if </span></span><br><span class="line">        <span class="comment">// this class doesn't implement +initialize. 2157218</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Exceptions: A +initialize call that throws an exception </span></span><br><span class="line">        <span class="comment">// is deemed to be a complete and successful +initialize.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Only __OBJC2__ adds these handlers. !__OBJC2__ has a</span></span><br><span class="line">        <span class="comment">// bootstrapping problem of this versus CF's call to</span></span><br><span class="line">        <span class="comment">// objc_exception_set_functions().</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __OBJC2__</span></span><br><span class="line">        <span class="keyword">@try</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 真正初始化的逻辑</span></span><br><span class="line">            callInitialize(cls);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (PrintInitializing) &#123;</span><br><span class="line">                _objc_inform(<span class="string">"INITIALIZE: thread %p: finished +[%s initialize]"</span>,</span><br><span class="line">                             pthread_self(), cls-&gt;nameForLogging());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __OBJC2__</span></span><br><span class="line">        <span class="keyword">@catch</span> (...) &#123;</span><br><span class="line">            <span class="keyword">if</span> (PrintInitializing) &#123;</span><br><span class="line">                _objc_inform(<span class="string">"INITIALIZE: thread %p: +[%s initialize] "</span></span><br><span class="line">                             <span class="string">"threw an exception"</span>,</span><br><span class="line">                             pthread_self(), cls-&gt;nameForLogging());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">@throw</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">@finally</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Done initializing.</span></span><br><span class="line">            lockAndFinishInitializing(cls, supercls);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合源码我们知道，<code>+initialize</code>时，<strong>先调用父类的+initialize，再调用子类的+initialize</strong></p><p>我们看下真正执行<code>+initialize</code>的代码<code>callInitialize</code>，源码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> callInitialize(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    ((<span class="keyword">void</span>(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>callInitialize</code>函数很简单，看源码我们得知，<strong><code>+initialize</code>是通过runtime的消息机制调用</strong>的(而<code>+load</code>是加载时通过函数地址直接调用)</p><h2 id="initialize总结"><a href="#initialize总结" class="headerlink" title="+initialize总结"></a>+initialize总结</h2><p>结合源码分析，我们可以分析apple是如何实现<strong>+initialize方法会在类第一次接收到消息时调用</strong>(Initializes the class before it receives its first message.)</p><ol><li>进行<code>objc_msgSend</code>前先进行方法查找(通过<code>class_getClassMethod</code>)</li><li><code>class_getClassMethod</code>内部调用<code>class_getInstanceMethod</code>，利用元类进行查找</li><li><code>class_getInstanceMethod</code>内部通过<code>lookUpImpOrNil</code>判断函数是否存在</li><li><code>lookUpImpOrNil</code>查找函数的实现或者进行消息转发<code>lookUpImpOrForward</code></li><li><code>lookUpImpOrForward</code>判断class是否初始化，没有的话进行初始化<code>_class_initialize</code></li><li><code>_class_initialize</code>内部先初始化superclass，之后调用初始化方法<code>callInitialize</code></li><li><code>callInitialize</code>内部就是<code>((void(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize);</code>，调用class的<code>initialize</code>方法。</li></ol><p><code>+initialize</code>整个流程完毕，接下来我们再对<code>+initialize</code>做一个总结</p><ol><li>+initialize方法会在类第一次接收到消息时调用</li><li>调用顺序<ul><li>先调用父类的+initialize，再调用子类的+initialize</li><li>(先初始化父类，再初始化子类，每个类只会初始化1次)</li></ul></li><li>虽有初始化只会一次，但是当子类没有实现<code>+initialize</code>时，父类的<code>+initialize</code>会被调用多次，但是父类仍然只会初始化1次，被调用多次是因为继承的原因(子类没有回去父类查找)</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综合全文，对<code>+load</code>和<code>+initialize</code>总结</p><p>load、initialize方法的区别什么？</p><ol><li><p>调用方式<br>1&gt; load是根据函数地址直接调用<br>2&gt; initialize是通过objc_msgSend调用</p></li><li><p>调用时机<br>1&gt; load是runtime加载类、分类的时候调用（只会调用1次）<br>2&gt; initialize是类第一次接收到消息的时候调用，每一个类只会initialize一次（父类的initialize方法可能会被调用多次）</p></li></ol><p>load、initialize的调用顺序？<br>1.load<br>1&gt; 先调用类的load<br>a) 先编译的类，优先调用load<br>b) 调用子类的load之前，会先调用父类的load</p><p>2&gt; 再调用分类的load<br>a) 先编译的分类，优先调用load</p><p>2.initialize<br>1&gt; 先初始化父类<br>2&gt; 再初始化子类（可能最终调用的是父类的initialize方法）</p><h2 id="参考和源码"><a href="#参考和源码" class="headerlink" title="参考和源码"></a>参考和源码</h2><p>Apple Source Browser - <a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">objc</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关联对象(Associated)详解</title>
      <link href="/p/4bdf012b/"/>
      <url>/p/4bdf012b/</url>
      
        <content type="html"><![CDATA[<p>学习MJ的视频课程，整理总结知识点–关联对象(Associated)详解</p><p>本文通过runtime中<code>objc_setAssociatedObject</code>源码为切入点，同时结合category的底层结构(<code>struct category_t</code>)、对象的底层结构(<code>objc_object</code>)，类的底层结构(<code>objc_class</code>)来讲解OC中的对象关联对象。主要回答：1、为什么分类不能添加属性(根本原因)、2、分类中怎样才能添加属性(关联对象)、3、关联对象的原理。</p><a id="more"></a><h2 id="分类为什么不能添加属性"><a href="#分类为什么不能添加属性" class="headerlink" title="分类为什么不能添加属性"></a>分类为什么不能添加属性</h2><p>最初学习OC编程的时候，已经知道category中不能直接添加属性，当时很好奇为什么category这么方便的东西不能直接使用属性，后来查资料知道不能直接添加属性是因为底层结构设计导致不允许。当时也只是停留在概念阶段，对于底层原因不够明了，这次通过较系统的学习，有了一定的知识储备后，再来讲解分类为什么不能添加属性。</p><p>结合我之前的<code>Category的本质</code>文章，我们已经知道category的底层结构是<code>struct category_t</code>，它在编译阶段是结构体，在运行时，runtime会把category的结构体里面的信息加载到对应的class中去。同时，我们也知道<code>struct category_t</code>的结构体有保存的主要有实例方法列表<code>instanceMethods</code>、类方法列表<code>classMethods</code>、协议列表<code>protocols</code>、实例属性列表<code>instanceProperties</code>、类属性列表<code>_classProperties</code>等。但没有成员成员变量列表<code>ivars</code>。这就直接表明category中没有成员变量这个东西。所以即使利用<code>@property</code>关键字给分类增加属性，也只能增加set方法和get方法的声明，不会有实现，也会有对应的成员变量。</p><p>真实因为category的结构体中不能保存成员变量，就决定了在OC中category是没有成员变量的，这是直接原因。</p><p>下面，我们思考下category不能直接添加属性，根本原因是什么？为什么在设计category底层结构时不增加一个类似成员变量的东西? 下面我结合之前的文章，分析并解答。</p><p>结合我之前的<code>OC对象的本质</code>这篇文章可以知道，<strong>成员变量在内存中是存储在OC对象内部的</strong>，这一点很重要。而方法列表、属性列表、协议列表是存储在类的内部。同时，OC对象的大小和内存布局是在编译完后就决定的了。而category存储的信息是在运行时才添加到class上，但此时，对象的大小和 内存布局已确定，假如category中有成员变量，假如成员变量能添加到对象里，那么对象的结构和大小肯定要变化，两者相悖。所以category中的是不能有成员变量的。</p><p>毕竟category是Objective-C 2.0之后添加的语言特性，category的主要作用是为已经存在的类添加方法。同时，OC是基于C语言这门静态语言的扩展，虽然OC有小巧的runtime实现动态性，但它并不完全是一门动态语言。</p><p>在语言设计上，OC在1.0版本时，更多的是在C语言这门静态语言的扩展，然后加上Smalltalk的消息机制。在OC2.0时，优化了runtime，但是category的设计目的是为类增加方法，加上C语言这个底子及OC1.0设计时的历史原因，OC2.0中category增加成员变量比较困难，同时重要性不是很高，所以category不能直接成员变量。但是提供了 <em>第三方管理者</em> 来实现category间接添加属性。</p><p>这部分在objc源码中也能有所体现</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Class realizeClassWithoutSwift(Class cls, Class previously)</span><br><span class="line">&#123;</span><br><span class="line">    auto ro = (<span class="keyword">const</span> class_ro_t *)cls-&gt;data();</span><br><span class="line">    auto isMeta = ro-&gt;flags &amp; RO_META;</span><br><span class="line">    <span class="keyword">if</span> (ro-&gt;flags &amp; RO_FUTURE) &#123;</span><br><span class="line">        <span class="comment">// This was a future class. rw data is already allocated.</span></span><br><span class="line">        rw = cls-&gt;data();</span><br><span class="line">        ro = cls-&gt;data()-&gt;ro();</span><br><span class="line">        ASSERT(!isMeta);</span><br><span class="line">        cls-&gt;changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Normal class. Allocate writeable class data.</span></span><br><span class="line">        rw = objc::zalloc&lt;class_rw_t&gt;();</span><br><span class="line">        rw-&gt;set_ro(ro);</span><br><span class="line">        rw-&gt;flags = RW_REALIZED|RW_REALIZING|isMeta;</span><br><span class="line">        cls-&gt;setData(rw);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>类的方法、属性等在编译期保存在data()的位置，在运行期，直到<code>realizeClassWithoutSwift</code>执行之后，才放到了<code>class_rw_t</code>指向的只读区域<code>const class_ro_t</code>。</p><blockquote><p>ps：这块内容主要是自己结合源码分析进行的总结，有错误或不严谨的地方请指出</p></blockquote><h2 id="分类怎样才能添加属性"><a href="#分类怎样才能添加属性" class="headerlink" title="分类怎样才能添加属性"></a>分类怎样才能添加属性</h2><p>我们已经知道了分类不能添加属性的直接原因和根本，但是我们在使用category时，很多时候还是需要用属性的set和get方法的。接下来我们探讨分类中间接添加属性的方式。</p><p>默认情况下，因为分类底层结构的限制，不能添加成员变量到分类中。但可以通过关联对象来间接实现</p><p>关联对象提供了以下API</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加关联对象</span></span><br><span class="line"><span class="keyword">void</span> objc_setAssociatedObject(<span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> * key, <span class="keyword">id</span> value, objc_AssociationPolicy policy)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得关联对象</span></span><br><span class="line"><span class="keyword">id</span> objc_getAssociatedObject(<span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> * key)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除所有的关联对象</span></span><br><span class="line"><span class="keyword">void</span> objc_removeAssociatedObjects(<span class="keyword">id</span> object)</span><br></pre></td></tr></table></figure><h3 id="key的常见用法"><a href="#key的常见用法" class="headerlink" title="key的常见用法"></a>key的常见用法</h3><p>用于关联对象的key<code>const void * key</code>，说明只要求是个指向常量的指针，使用static时为了限制key的作用域。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *MyKey = &amp;MyKey;</span><br><span class="line">objc_setAssociatedObject(obj, MyKey, value, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">objc_getAssociatedObject(obj, MyKey);</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> MyKey;</span><br><span class="line">objc_setAssociatedObject(obj, &amp;MyKey, value, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">objc_getAssociatedObject(obj, &amp;MyKey);</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用属性名作为key</span></span><br><span class="line">bjc_setAssociatedObject(obj, <span class="string">@"property"</span>, value, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">objc_getAssociatedObject(obj, <span class="string">@"property"</span>);</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用get方法的@selecor作为key</span></span><br><span class="line">objc_setAssociatedObject(obj, <span class="keyword">@selector</span>(<span class="keyword">getter</span>), value, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">objc_getAssociatedObject(obj, <span class="keyword">@selector</span>(<span class="keyword">getter</span>));</span><br></pre></td></tr></table></figure><p>这里更推荐最后一种写法，原因如下</p><ol><li>明了是为哪个属性进行的绑定，比较接近属性set和get</li><li>不用额外定义key</li><li>自带语法提示</li></ol><h2 id="关联对象的原理"><a href="#关联对象的原理" class="headerlink" title="关联对象的原理"></a>关联对象的原理</h2><p>关联对象是runtime的一部分，所以我们直接看源码即可</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> objc_setAssociatedObject(<span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">id</span> value, objc_AssociationPolicy policy) &#123;</span><br><span class="line">    _object_set_associative_reference(object, (<span class="keyword">void</span> *)key, value, policy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置关联对象的核心源码</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _object_set_associative_reference(<span class="keyword">id</span> object, <span class="keyword">void</span> *key, <span class="keyword">id</span> value, uintptr_t policy) &#123;</span><br><span class="line">    <span class="comment">// retain the new value (if any) outside the lock.</span></span><br><span class="line">    ObjcAssociation old_association(<span class="number">0</span>, <span class="literal">nil</span>);</span><br><span class="line">    <span class="keyword">id</span> new_value = value ? acquireValue(value, policy) : <span class="literal">nil</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        AssociationsHashMap &amp;associations(manager.associations());</span><br><span class="line">        disguised_ptr_t disguised_object = DISGUISE(object);</span><br><span class="line">        <span class="keyword">if</span> (new_value) &#123;</span><br><span class="line">            <span class="comment">// break any existing association.</span></span><br><span class="line">            AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">            <span class="keyword">if</span> (i != associations.end()) &#123;</span><br><span class="line">                <span class="comment">// secondary table exists</span></span><br><span class="line">                ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">                <span class="keyword">if</span> (j != refs-&gt;end()) &#123;</span><br><span class="line">                    old_association = j-&gt;second;</span><br><span class="line">                    j-&gt;second = ObjcAssociation(policy, new_value);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    (*refs)[key] = ObjcAssociation(policy, new_value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// create the new association (first time).</span></span><br><span class="line">                ObjectAssociationMap *refs = new ObjectAssociationMap;</span><br><span class="line">                associations[disguised_object] = refs;</span><br><span class="line">                (*refs)[key] = ObjcAssociation(policy, new_value);</span><br><span class="line">                object-&gt;setHasAssociatedObjects();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// setting the association to nil breaks the association.</span></span><br><span class="line">            AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">            <span class="keyword">if</span> (i !=  associations.end()) &#123;</span><br><span class="line">                ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">                <span class="keyword">if</span> (j != refs-&gt;end()) &#123;</span><br><span class="line">                    old_association = j-&gt;second;</span><br><span class="line">                    refs-&gt;erase(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// release the old value (outside of the lock).</span></span><br><span class="line">    <span class="keyword">if</span> (old_association.hasValue()) ReleaseValue()(old_association);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以总结如下流程<br><img src="https://cdn.ticsmatic.com/img/2020-05-13/15893637992826.png" alt="关联对象"><br>得出如下结论：</p><ol><li>关联对象存储在全局的统一的一个AssociationsManager中</li><li>AssociationsManager里面有一个_map，管理每个对象的对象关联ObjectAssociationMap</li><li>ObjectAssociationMap的key保存的就是外界传递进来的参数<code>key</code>，value保存的就是关联值，里面包含<code>policy</code>、<code>value</code>。</li><li>设置关联对象为nil，就相当于是移除关联对象</li><li>AssociationsManager添加了锁，并自己做旧值的释放</li></ol><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>至于protocol，我们看它的源码</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> protocol_t : objc_object &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *mangledName;</span><br><span class="line">    <span class="keyword">struct</span> protocol_list_t *protocols;</span><br><span class="line">    method_list_t *instanceMethods;</span><br><span class="line">    method_list_t *classMethods;</span><br><span class="line">    method_list_t *optionalInstanceMethods;</span><br><span class="line">    method_list_t *optionalClassMethods;</span><br><span class="line">    property_list_t *instanceProperties;</span><br><span class="line">    uint32_t size;   <span class="comment">// sizeof(protocol_t)</span></span><br><span class="line">    uint32_t flags;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过源码可知，protocol的结构有一点类似category。<br>而且，protocol也是没有成员变量列表的，有getter、setter方法的声明，但是没有方法的实现。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>category不能直接添加属性的原因<br>直接原因：category内部没有用于存储ivar的地方<br>根本原因：</p><ol><li>OC是最初是基于C语言+Smalltalk，category是OC2.0才有的特性，当时的语言发展史已经决定了类在编译阶段就决定了对象的大小和内存布局。而且OC对象的成员变量是保存在对象中的。</li><li>category的设计初衷是为类添加方法。<br>这两个条件决定了为category添加变量的需求不是很高，相对于对OC底层大幅改动从而实现在category中直接添加变量，语言的设计者采取<code>第三方管理者(关联对象)</code>来间接实现添加成员变量</li></ol></li><li><p>关联对象使用<br>个人建议使用@selector(getter)作为关联对象的key</p></li><li><p>关联对象的原理<br>使用一个全局的AssociationsManager，它的内部有一个map，map的key对应要关联的对象，value保存的是ObjectAssociationMap，这个ObjectAssociationMap关联key和值信息。<br>这一部分看上面总结的图会更清晰</p></li></ol><h2 id="参考和源码"><a href="#参考和源码" class="headerlink" title="参考和源码"></a>参考和源码</h2><p>Apple Source Browser - <a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">objc</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Category的本质</title>
      <link href="/p/e15d38f8/"/>
      <url>/p/e15d38f8/</url>
      
        <content type="html"><![CDATA[<p>学习MJ的视频课程，整理总结知识点–Category的本质</p><a id="more"></a><p>[TOC]</p><h2 id="Category基本使用"><a href="#Category基本使用" class="headerlink" title="Category基本使用"></a>Category基本使用</h2><p>category 是对装饰模式的一种具体实现。它的主要作用是在不改变原有类的前提下，动态地给这个类添加一些方法。</p><p>category 还可以对类进行模块拆解，甚至模拟多继承等操作。具体可参考官方文档<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/DevPedia-CocoaCore/Category.html" target="_blank" rel="noopener">Category</a></p><h2 id="Category底层结构"><a href="#Category底层结构" class="headerlink" title="Category底层结构"></a>Category底层结构</h2><p>我们知道category的基本用法，前面我们也已经知道了NSObject、class的底层结构，及调用机制。那么category的结构是什么样的，OC是通过怎样的机制来实现category？</p><p>想知道category的底层结构(基于经验，完全可以大胆的推测它是结构体)，结合前面的经验，我们可以去两个地方查线索。</p><ol><li>用<code>clang</code>重写category的编译文件来查看项目中的源码</li><li>阅读<a href="https://opensource.apple.com/source/objc4/objc4-723/runtime/objc-runtime-new.h.auto.html" target="_blank" rel="noopener">objc-runtime-new.h</a>开源的源码，搜索<code>category</code>关键字进行查看</li></ol><p>这里通过Demo，用<code>clang</code>重写category的编译文件，分析重写后生成的cpp文件，来探索category的底层结构。</p><p>创建<code>MJPerson.h</code>、<code>MJPerson.m</code>，创建<code>MJPerson+Test.h</code>、<code>MJPerson+Test.m</code>，然后通过class重写<code>MJPerson+Test.m</code>文件，生成为C++文件，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -rewrite-objc MJPerson+Test.m -o MJPerson+Test.cpp</span><br></pre></td></tr></table></figure><p>打开<code>MJPerson+Test.cpp</code>文件，我们看到如下代码，简单阅读一下，这个看起来就是我们要找到的<code>MJPerson+Test.m</code>重写后的另一种表达样式。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> _category_t _OBJC_$_CATEGORY_MJPerson_$_Test __attribute__ ((used, section (<span class="string">"__DATA,__objc_const"</span>))) = </span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"MJPerson"</span>,</span><br><span class="line"><span class="number">0</span>, <span class="comment">// &amp;OBJC_CLASS_$_MJPerson,</span></span><br><span class="line">(<span class="keyword">const</span> <span class="keyword">struct</span> _method_list_t *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_MJPerson_$_Test,</span><br><span class="line">(<span class="keyword">const</span> <span class="keyword">struct</span> _method_list_t *)&amp;_OBJC_$_CATEGORY_CLASS_METHODS_MJPerson_$_Test,</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们还可以找到<code>_CATEGORY_INSTANCE_METHODS_MJPerson_</code>，<code>_CATEGORY_CLASS_METHODS_MJPerson_</code>的具体实现结构。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> <span class="comment">/*_method_list_t*/</span> &#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> entsize;  <span class="comment">// sizeof(struct _objc_method)</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> method_count;</span><br><span class="line"><span class="keyword">struct</span> _objc_method method_list[<span class="number">2</span>];</span><br><span class="line">&#125; _OBJC_$_CATEGORY_INSTANCE_METHODS_MJPerson_$_Test __attribute__ ((used, section (<span class="string">"__DATA,__objc_const"</span>))) = &#123;</span><br><span class="line"><span class="keyword">sizeof</span>(_objc_method),</span><br><span class="line"><span class="number">2</span>,</span><br><span class="line">&#123;&#123;(<span class="keyword">struct</span> objc_selector *)<span class="string">"run"</span>, <span class="string">"v16@0:8"</span>, (<span class="keyword">void</span> *)_I_MJPerson_Test_run&#125;,</span><br><span class="line">&#123;(<span class="keyword">struct</span> objc_selector *)<span class="string">"test"</span>, <span class="string">"v16@0:8"</span>, (<span class="keyword">void</span> *)_I_MJPerson_Test_test&#125;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>同时，我们还能在<code>MJPerson+Test.cpp</code>文件中找打如下代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> _category_t &#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line"><span class="keyword">struct</span> _class_t *cls;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">struct</span> _method_list_t *instance_methods;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">struct</span> _method_list_t *class_methods;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">struct</span> _protocol_list_t *protocols;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">struct</span> _prop_list_t *properties;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看起来很像category结构体的标准格式。</p><ol><li><code>name</code>注意，并不是category小括号里写的名字，而是类的名字</li><li><code>cls</code>要扩展的类对象，编译期间这个值是不会有的，在app被runtime加载时才会根据name对应到类对象</li><li><code>instance_methods</code>这个category所有的-方法</li><li><code>class_methods</code>这个category所有的+方法</li><li><code>protocols</code>这个category实现的protocol，比较不常用在category里面实现协议，但是确实支持的</li><li><code>properties</code>这个category所有的property，这也是category里面可以定义属性的原因，不过这个property不会@synthesize实例变量，一般有需求添加实例变量属性时会采用objc_setAssociatedObject和objc_getAssociatedObject方法绑定方法绑定，不过这种方法生成的与一个普通的实例变量完全是两码事。</li></ol><p>上面这些是我们利用编译器重写OC代码生成的C++源码，同时我们还可以在apple开源的<a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">objc</a>中找到category的源码，在<code>objc-runtime-new.h</code>文件中看到定义的源码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> category_t &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    classref_t cls;</span><br><span class="line">    <span class="keyword">struct</span> method_list_t *instanceMethods;</span><br><span class="line">    <span class="keyword">struct</span> method_list_t *classMethods;</span><br><span class="line">    <span class="keyword">struct</span> protocol_list_t *protocols;</span><br><span class="line">    <span class="keyword">struct</span> property_list_t *instanceProperties;</span><br><span class="line">    <span class="comment">// Fields below this point are not always present on disk.</span></span><br><span class="line">    <span class="keyword">struct</span> property_list_t *_classProperties;</span><br><span class="line"></span><br><span class="line">    method_list_t *methodsForMeta(<span class="keyword">bool</span> isMeta) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isMeta) <span class="keyword">return</span> classMethods;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> instanceMethods;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    property_list_t *propertiesForMeta(<span class="keyword">bool</span> isMeta, <span class="keyword">struct</span> header_info *hi);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Category底层结构部分Demo的<a href="https://cdn.ticsmatic.com/source/2020-05-06/Interview03-Category.zip" target="_blank" rel="noopener">下载地址</a></p><h2 id="Category源码分析"><a href="#Category源码分析" class="headerlink" title="Category源码分析"></a>Category源码分析</h2><p>通过解读category的源码，我们知道category的底层结构长这个样子</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> category_t &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    classref_t cls;</span><br><span class="line">    <span class="keyword">struct</span> method_list_t *instanceMethods;</span><br><span class="line">    <span class="keyword">struct</span> method_list_t *classMethods;</span><br><span class="line">    <span class="keyword">struct</span> protocol_list_t *protocols;</span><br><span class="line">    <span class="keyword">struct</span> property_list_t *instanceProperties;</span><br><span class="line">    <span class="comment">// Fields below this point are not always present on disk.</span></span><br><span class="line">    <span class="keyword">struct</span> property_list_t *_classProperties;</span><br><span class="line"></span><br><span class="line">    method_list_t *methodsForMeta(<span class="keyword">bool</span> isMeta) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isMeta) <span class="keyword">return</span> classMethods;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> instanceMethods;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    property_list_t *propertiesForMeta(<span class="keyword">bool</span> isMeta, <span class="keyword">struct</span> header_info *hi);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们知道OC中所有的方法调用都会转成runtime的<code>objc_msgSend</code>，这个函数需要两个参数<code>id, SEL</code>，函数通过这个<code>id</code>参数查找对象的isa指针，通过isa找到class的方法列表，在方法列表中匹配<code>SEL</code>进行调用。</p><p>但是在之前的class源码解读中(<code>struct objc_class : objc_object {...}</code>)，我们已经知道，实例方法信息都是存储在class的方法列表中(<code>struct objc_class -&gt; class_rw_t* data() -&gt; method_array_t methods</code>，注：在不同的objc源码版本中可能会有细微差异)</p><p>那么category里的方法信息存储在哪里？是否就在本来的category_t中？ 程序运行时如何调用到category里面的信息？</p><p>实际上，category的信息最终也会合并到class中，且在runtime加载完成后，category的原始信息在类结构里将不会存在。</p><p>我们先通过打印class的方法列表</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印class的方法列表，发现category中的方法也会被打印出来，看起来分类的方法似乎存在于Class中了</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> outCount;</span><br><span class="line">Method *methodlist = class_copyMethodList([MJPerson <span class="keyword">class</span>], &amp;outCount);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</span><br><span class="line">    Method method = methodlist[i];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="built_in">NSStringFromSelector</span>(method_getName(method)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现Class的方法列表中包含了category的方法，可以说明category的信息会添加到class中。</p><p>下面我们通过runtime的加载入口为切入点，来解读category的信息是如何添加到到class中。</p><p>这需要探究下runtime对category的加载过程，这里就简单说一下</p><ol><li>objc runtime的加载入口是一个叫<code>_objc_init</code>的方法，在library加载前由libSystem dyld调用，进行初始化操作</li><li>调用<code>map_images</code>方法将文件中的<code>image</code>map到内存</li><li>调用<code>_read_images</code>方法初始化map后的image，这是一个很重要的函数。这里面干了很多的事情，像load所有的类、协议和category，著名的<code>+ load</code>方法就是这一步调用的<br>仔细看category的初始化，调用了<code>_getObjc2CategoryList</code>方法获取所有的categories<code>category_t **catlist = _getObjc2CategoryList(hi, &amp;count);</code>，接下来runtime终于开始了category的处理，简化的代码如下</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Process this category. </span></span><br><span class="line"><span class="comment">// First, register the category with its target class. </span></span><br><span class="line"><span class="comment">// Then, rebuild the class's method lists (etc) if </span></span><br><span class="line"><span class="comment">// the class is realized. </span></span><br><span class="line"><span class="keyword">bool</span> classExists = <span class="literal">NO</span>;</span><br><span class="line"><span class="keyword">if</span> (cat-&gt;instanceMethods ||  cat-&gt;protocols  ||  cat-&gt;instanceProperties) </span><br><span class="line">&#123;</span><br><span class="line">    addUnattachedCategoryForClass(cat, cls, hi);</span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;isRealized()) &#123;</span><br><span class="line">        remethodizeClass(cls);</span><br><span class="line">        classExists = <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cat-&gt;classMethods  ||  cat-&gt;protocols  ||  (hasClassProperties &amp;&amp; cat-&gt;_classProperties)) </span><br><span class="line">&#123;</span><br><span class="line">    addUnattachedCategoryForClass(cat, cls-&gt;ISA(), hi);</span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;ISA()-&gt;isRealized()) &#123;</span><br><span class="line">        remethodizeClass(cls-&gt;ISA());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先分成两拨，一拨是实例对象相关的调用<code>addUnattachedCategoryForClass</code>，一拨是类对象相关的调用<code>addUnattachedCategoryForClass</code>，判断每一拨里面是否实现有方法、协议、属性，有的话就<code>remethodizeClass</code>重新组织class信息结构。</p><p>在<code>remethodizeClass</code>函数中有一个重要方法<code>attachCategories</code>。<code>attachCategories(cls, cats, true);</code>将分类列表<code>cats</code>的附加到类<code>cls</code>。</p><p>接下来讲解<code>attachCategories</code>函数，不粘贴大片的代码，我用注释说明主要做的事情，需要的可以去看源码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Attach method lists and properties and protocols from categories to a class.</span></span><br><span class="line"><span class="comment">// Assumes the categories in cats are all loaded and sorted by load order, </span></span><br><span class="line"><span class="comment">// oldest categories first.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> </span><br><span class="line">attachCategories(Class cls, category_list *cats, <span class="keyword">bool</span> flush_caches)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 1. 分配方法数组、属性数组、协议数组空间</span></span><br><span class="line"><span class="comment">// 2. 遍历分类数组cats，取出方法、属性、协议并添加到对应的数组中</span></span><br><span class="line"><span class="comment">// 3. 拿到cls的信息表auto rw = cls-&gt;data(); 往cls里面添加categories的方法数组、属性数组、协议数组，最后把数组空间释放。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的第3步(<code>rw-&gt;methods.attachLists(mlists, mcount)</code>)，往cls里面添加数组数据的时候，我们讲解一下个重要方法<code>attachLists</code>.</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> attachLists(List* <span class="keyword">const</span> * addedLists, uint32_t addedCount) &#123;</span><br><span class="line">    <span class="keyword">if</span> (addedCount == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasArray()) &#123;</span><br><span class="line">        <span class="comment">// many lists -&gt; many lists</span></span><br><span class="line">        uint32_t oldCount = array()-&gt;count;</span><br><span class="line">        uint32_t newCount = oldCount + addedCount;</span><br><span class="line">        <span class="comment">// 计算新数组个数后重新分配空间</span></span><br><span class="line">        setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));</span><br><span class="line">        array()-&gt;count = newCount;</span><br><span class="line">        <span class="comment">// cls自身的数组部分移动到新数组0位置</span></span><br><span class="line">        memmove(array()-&gt;lists + addedCount, array()-&gt;lists, oldCount * <span class="keyword">sizeof</span>(array()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">        <span class="comment">// 增加的部分copy到新数组0位置</span></span><br><span class="line">        memcpy(array()-&gt;lists, addedLists, addedCount * <span class="keyword">sizeof</span>(array()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>attachLists</code>流程有3个关键的地方，<code>realloc</code>、<code>memmove</code>、<code>memcpy</code>，有一个非常重要的地方，就是<code>memcpy</code>，在categories加载的过程中就是把categories的信息(方法、属性、协议)添加到新数组的其实位置。因为runtime的方法调用机制就是找到对应的方法后方法查找流程就结束，然后进行方法调用。正是因为每次categories的信息都是添加到cls的方法数组的最前面，所以遇到category和class方法同名时，优先调用的是category的方法。</p><p>学习了categories的加载机制，我们还可以解释另外一个问题，就是同一个class的多个category，每个category都有同样方法，则最后参与编译的分类方法优先调用。</p><p>因为在<code>attachCategories</code>过程中，有这样一段代码</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建用于存储同一个class的所有category方法的数组</span></span><br><span class="line">method_list_t **mlists = (method_list_t **)malloc(cats-&gt;count * <span class="keyword">sizeof</span>(*mlists));</span><br><span class="line">        </span><br><span class="line"><span class="keyword">while</span> (i--) &#123;</span><br><span class="line">        auto&amp; entry = cats-&gt;list[i];</span><br><span class="line"></span><br><span class="line">        method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta);</span><br><span class="line">        <span class="keyword">if</span> (mlist) &#123;</span><br><span class="line">            <span class="comment">// 向数组中添加方法</span></span><br><span class="line">            mlists[mcount++] = mlist;</span><br><span class="line">            fromBundle |= entry.hi-&gt;isBundle();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为是<code>i--</code>的while循环，所以最后加载的category会添加到数组的最前端。这样runtime在方法查找的时候，会优先查找到最前面的方法，也就意味着最后参与编译的分类方法优先调用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>Category编译之后的底层结构是<code>struct category_t</code>，里面存储着分类的对象方法、类方法、属性、协议信息在程序运行的时候，runtime会将Category的数据，合并到类信息中（类对象、元类对象中）</li><li>category信息添加到class时有几个重要的函数<ul><li>_objc_init // runtime的加载入口</li><li>map_images // 将文件中的imagemap到内存</li><li>_read_images // <strong>重要</strong>：初始化map后的image</li><li>_getObjc2CategoryList // 获取所有的categories</li><li>remethodizeClass // 为了添加category重修Class</li><li>attachCategories // 添加categories到Class</li><li>attachLists // Class的结构体重新分配大小，把category中的信息添加的最前面</li></ul></li></ol><h2 id="参考和源码"><a href="#参考和源码" class="headerlink" title="参考和源码"></a>参考和源码</h2><p>参考：<br><a href="https://blog.sunnyxx.com/2014/03/05/objc_category_secret/" target="_blank" rel="noopener">objc category的秘密</a></p><p>Demo源码：<br><a href="https://cdn.ticsmatic.com/source/2020-05-06/diceng/day06/Interview03-Category.zip" target="_blank" rel="noopener">Category的底层结构-Demo.zip</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>KVC的本质</title>
      <link href="/p/6fefa1e2/"/>
      <url>/p/6fefa1e2/</url>
      
        <content type="html"><![CDATA[<p>学习MJ的视频课程，整理并记录知识点–KVC的本质</p><a id="more"></a><p>[TOC]</p><p>KVC的全称是<code>Key-Value Coding</code>，俗称“键值编码”，可以通过一个key来访问某个属性</p><p>常见的API有</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">id</span>)value forKeyPath:(<span class="built_in">NSString</span> *)keyPath;</span><br><span class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">id</span>)value forKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="keyword">id</span>)valueForKeyPath:(<span class="built_in">NSString</span> *)keyPath;</span><br><span class="line">- (<span class="keyword">id</span>)valueForKey:(<span class="built_in">NSString</span> *)key;</span><br></pre></td></tr></table></figure><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="设值"><a href="#设值" class="headerlink" title="设值"></a>设值</h3><p>1、我们可以通过<code>-setValue:forKey:</code>，或者<code>-setValue:forKeyPath:</code>给对象的属性赋值，也可以直接调用对象的属性赋值，如下三个方法的效果等价。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">person.age = <span class="number">10</span>;</span><br><span class="line">[person setValue:@<span class="number">10</span> forKey:<span class="string">@"age"</span>];</span><br><span class="line">[person setValue:@<span class="number">10</span> forKeyPath:<span class="string">@"age"</span>];</span><br></pre></td></tr></table></figure><p><code>-setValue:forKey:</code>、<code>-setValue:forKeyPath:</code>这两个方法的调用结果一样，函数名很相似，它们两个的区别是什么？</p><p>我们先看它的<a href="https://developer.apple.com/documentation/objectivec/nsobject/1418139-setvalue?language=objc" target="_blank" rel="noopener">API文档</a></p><blockquote><p>Discussion</p><p>The default implementation of this method gets the destination object for each relationship using valueForKey:, and sends the final object a setValue:forKey: message.</p></blockquote><p>可以概述如下：<code>-setValue:forKeyPath:</code>支持路径方式的参数（<code>[person setValue:@10 forKeyPath:@&quot;cat.weight&quot;];</code>），<br>它会新利用路径查找到指定的层级，内部最终是会调用<code>-setValue:forKey:</code></p><p>2、KVC的另一种使用场景就是我么利用它进行对象的私有属性赋值。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[searchField setValue:[<span class="built_in">UIColor</span> whiteColor] forKeyPath:<span class="string">@"_placeholderLabel.textColor"</span>];</span><br></pre></td></tr></table></figure><p>但是在iOS13以后，系统对象通过KVC设置私有属性已被禁止。</p><h3 id="取值"><a href="#取值" class="headerlink" title="取值"></a>取值</h3><p>相对应的取值方式为<code>-valueForKey:</code>、<code>-valueForKeyPath:</code>，使用很简单</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">person.age;</span><br><span class="line">[person valueForKey:<span class="string">@"age"</span>];</span><br><span class="line">[person valueForKeyPath:<span class="string">@"age"</span>];</span><br></pre></td></tr></table></figure><h2 id="setValue-forKey-的原理"><a href="#setValue-forKey-的原理" class="headerlink" title="-setValue:forKey:的原理"></a>-setValue:forKey:的原理</h2><p><code>-setValue:forKey:</code>是<code>Foundation</code>的函数，我们看不到源码，不过这个API的接口文档很详细。<a href="https://developer.apple.com/documentation/objectivec/nsobject/1415969-setvalue?language=objc" target="_blank" rel="noopener">-setValue:forKey:</a></p><p>同时，在<code>Foundation</code>的头文件中，函数的描述如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Given a value and a key that identifies an attribute, set the value of the attribute. Given an object and a key that identifies a to-one relationship, relate the object to the receiver, unrelating the previously related object if there was one. Given a collection object and a key that identifies a to-many relationship, relate the objects contained in the collection to the receiver, unrelating previously related objects if there were any.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">The default implementation of this method does the following:</span></span><br><span class="line"><span class="comment">    1. Searches the class of the receiver for an accessor method whose name matches the pattern -set&lt;Key&gt;:. If such a method is found the type of its parameter is checked. If the parameter type is not an object pointer type but the value is nil -setNilValueForKey: is invoked. The default implementation of -setNilValueForKey: raises an NSInvalidArgumentException, but you can override it in your application. Otherwise, if the type of the method's parameter is an object pointer type the method is simply invoked with the value as the argument. If the type of the method's parameter is some other type the inverse of the NSNumber/NSValue conversion done by -valueForKey: is performed before the method is invoked.</span></span><br><span class="line"><span class="comment">    2. Otherwise (no accessor method is found), if the receiver's class' +accessInstanceVariablesDirectly property returns YES, searches the class of the receiver for an instance variable whose name matches the pattern _&lt;key&gt;, _is&lt;Key&gt;, &lt;key&gt;, or is&lt;Key&gt;, in that order. If such an instance variable is found and its type is an object pointer type the value is retained and the result is set in the instance variable, after the instance variable's old value is first released. If the instance variable's type is some other type its value is set after the same sort of conversion from NSNumber or NSValue as in step 1.</span></span><br><span class="line"><span class="comment">    3. Otherwise (no accessor method or instance variable is found), invokes -setValue:forUndefinedKey:. The default implementation of -setValue:forUndefinedKey: raises an NSUndefinedKeyException, but you can override it in your application.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Compatibility notes:</span></span><br><span class="line"><span class="comment">    - For backward binary compatibility with -takeValue:forKey:'s behavior, a method whose name matches the pattern -_set&lt;Key&gt;: is also recognized in step 1. KVC accessor methods whose names start with underscores were deprecated as of Mac OS 10.3 though.</span></span><br><span class="line"><span class="comment">    - For backward binary compatibility, -unableToSetNilForKey: will be invoked instead of -setNilValueForKey: in step 1, if the implementation of -unableToSetNilForKey: in the receiver's class is not NSObject's.</span></span><br><span class="line"><span class="comment">    - The behavior described in step 2 is different from -takeValue:forKey:'s, in which the instance variable search order is &lt;key&gt;, _&lt;key&gt;.</span></span><br><span class="line"><span class="comment">    - For backward binary compatibility with -takeValue:forKey:'s behavior, -handleTakeValue:forUnboundKey: will be invoked instead of -setValue:forUndefinedKey: in step 3, if the implementation of -handleTakeValue:forUnboundKey: in the receiver's class is not NSObject's.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">nullable</span> <span class="keyword">id</span>)value forKey:(<span class="built_in">NSString</span> *)key;</span><br></pre></td></tr></table></figure><p>我们可以结合文档，整理出<code>-setValue:forKey:</code>内部的主要逻辑如下：<br><img src="https://cdn.ticsmatic.com/img/2020-05-03/15884770977532.png" alt="-setValue:forKey:"></p><p>KVC底层调用<br><code>willChangeValueForKey:</code>、<code>didChangeValueForKey:</code></p><h2 id="valueForKey-的原理"><a href="#valueForKey-的原理" class="headerlink" title="-valueForKey:的原理"></a>-valueForKey:的原理</h2><p><code>-valueForKey:</code>函数核心原理和<code>-setValue:forKey:</code>很类似，一个是设置值，一个是取值。它的原理如下：<br><img src="https://cdn.ticsmatic.com/img/2020-05-22/15901113874382.png" alt="-valueForKey:"></p><h2 id="KVC触发KVO的observer"><a href="#KVC触发KVO的observer" class="headerlink" title="KVC触发KVO的observer"></a>KVC触发KVO的observer</h2><p>KVC是键值编码、KVO的键值监听，从定义的描述可推测两者之前似乎有关联。他们关联也就是<strong>键值</strong>，一个是设置修改键值、一个是监听键值的修改。那么通过KVC修改属性会触发KVO么？答案是：会</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加KVO监听</span></span><br><span class="line">[person addObserver:observer forKeyPath:<span class="string">@"age"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span> context:<span class="literal">NULL</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过KVC修改age属性</span></span><br><span class="line">[person setValue:@<span class="number">10</span> forKeyPath:<span class="string">@"age"</span>];</span><br></pre></td></tr></table></figure><p>我们在<code>KVO</code>的那一章中介绍过，触发KVO的关键代码是<code>-willChangeValueForKey:</code>，<code>-didChangeValueForKey:</code>，</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span>.person1 willChangeValueForKey:<span class="string">@"age"</span>];</span><br><span class="line"><span class="keyword">self</span>.person1-&gt;_age = <span class="number">10</span>;</span><br><span class="line">[<span class="keyword">self</span>.person1 didChangeValueForKey:<span class="string">@"age"</span>];</span><br></pre></td></tr></table></figure><p>我们可以在<code>person</code>的class中实现<code>-willChangeValueForKey:</code>，<code>-didChangeValueForKey:</code>，进行调试，结论是，通过KVC设置属性会调用这两个方法，也就会触发KVO</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>知道KVC的调用顺序<br>通过KVC设置属性会触发KVO</p><h2 id="源码和参考"><a href="#源码和参考" class="headerlink" title="源码和参考"></a>源码和参考</h2><p>apple document：<a href="https://developer.apple.com/documentation/objectivec/nsobject/1415969-setvalue?language=objc" target="_blank" rel="noopener">setvalue</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>KVO的实现原理</title>
      <link href="/p/4dec9c48/"/>
      <url>/p/4dec9c48/</url>
      
        <content type="html"><![CDATA[<p>学习MJ的视频课程，整理并记录知识点–KVO的实现原理</p><a id="more"></a><p>[TOC]</p><p>KVO的全称是Key-Value Observing，俗称“键值监听”，可以用于监听某个对象属性值的改变。</p><h2 id="KVO的使用"><a href="#KVO的使用" class="headerlink" title="KVO的使用"></a>KVO的使用</h2><p>先回忆下，关于KVO的使用，通常的代码类似如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. Add KVO</span></span><br><span class="line"><span class="built_in">NSKeyValueObservingOptions</span> options = <span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span>;</span><br><span class="line">    [<span class="keyword">self</span>.person1 addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"age"</span> options:options context:<span class="string">@"123"</span>];</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 2. Trigger </span></span><br><span class="line"><span class="keyword">self</span>.person1.age = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. Observing </span></span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>, <span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"监听到%@的%@属性值改变了 - %@ - %@"</span>, object, keyPath, change, context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove observe</span></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    [<span class="keyword">self</span>.person1 removeObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"age"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="KVO本质分析"><a href="#KVO本质分析" class="headerlink" title="KVO本质分析"></a>KVO本质分析</h2><p>我们通过一个对照组来逐步分析KVO的本质实现，如下</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建另一个实例对象，设置同样的属性</span></span><br><span class="line"><span class="keyword">self</span>.person2.age = <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p><code>person1</code>和<code>person2</code>都会调用<code>setAge:</code>方法，但不添加监听的<code>person2</code>是不会触发KVO的方法的，这两个对象有什么区别呢？</p><p>我们分析下这两个对象，根据前面的学习，我们知道，instance对象只存变量，方法存储在class对象中，我们可以尝试打印<code>person1</code>和<code>person2</code>的isa</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p self.person1-&gt;isa</span><br><span class="line">(Class) $0 &#x3D; NSKVONotifying_MJPerson</span><br><span class="line"></span><br><span class="line">(lldb) p self.person2-&gt;isa</span><br><span class="line">(Class) $0 &#x3D; MJPerson</span><br></pre></td></tr></table></figure><p>两者的isa指向不一样，从哪里出来一个<code>NSKVONotifying_MJPerson</code>类。</p><p>我们知道实例对象的isa是指指向class的，但是<code>person1</code>的class却成了<code>NSKVONotifying_MJPerson</code>，这个<code>NSKVONotifying_MJPerson</code>的产生必然与添加observer有关，那么它的superclass是谁？</p><p>我们打印会发现<code>NSKVONotifying_MJPerson</code>的superclass是<code>MJPerson</code>。原来在给<code>person1</code>添加observer时，会动态创建一个叫<code>NSKVONotifying_MJPerson</code>的子类，然后<code>person1</code>的isa会指向这个新创建的子类。</p><h2 id="KVO本质分析验证"><a href="#KVO本质分析验证" class="headerlink" title="KVO本质分析验证"></a>KVO本质分析验证</h2><p><code>person1</code>的isa指向<code>NSKVONotifying_MJPerson</code>，当调用<code>setAge:</code>方法时，肯定是去<code>NSKVONotifying_MJPerson</code>中找，而<code>setAge:</code>是触发监听者的关键，那么动态创建的这个子类的<code>setAge:</code>方法肯定和之前的不一样。我们尝试打印这个动态类的方法列表：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在添加observer后，利用runtime打印person1的方法列表</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> outCount2;</span><br><span class="line">Method *methodList2 = class_copyMethodList(object_getClass(<span class="keyword">self</span>.person1), &amp;outCount2);</span><br><span class="line"><span class="built_in">NSMutableString</span> *methodNames = [<span class="built_in">NSMutableString</span> string];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; outCount2; i++) &#123;</span><br><span class="line">    Method method = methodList2[i];</span><br><span class="line">    [methodNames appendFormat:<span class="string">@"%@&#123; %p &#125;, "</span>, <span class="built_in">NSStringFromSelector</span>(method_getName(method)), (IMP)method_getImplementation(method)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ... setAge:, class, dealloc, _isKVOA</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, methodNames);</span><br></pre></td></tr></table></figure><p>我们发现这个动态生成的class里面同样有<code>setAge:</code>方法，另外多了<code>class, dealloc, _isKVOA</code>这几个方法。</p><p>同时我们获取了每个方法的实现(IMP指针)，这样我们就可以通过LLDB查看<code>IMP</code>指针指向的内存了，作为对照组，我们先查看未添加observer的<code>person2</code>对象</p><p>如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p methodNames</span><br><span class="line">(__NSCFString *) $0 &#x3D; 0x0000600001e7e220 @&quot;setAge:&#123; 0x101e13720 &#125;, age&#123; 0x101e13700 &#125;, &quot;</span><br><span class="line">(lldb) p (IMP)0x101e13720</span><br><span class="line">(IMP) $1 &#x3D; 0x0000000101e13720 (Interview01&#96;-[MJPerson setAge:] at MJPerson.h:12)</span><br><span class="line">(lldb) p (IMP)0x101e13700</span><br><span class="line">(IMP) $2 &#x3D; 0x0000000101e13700 (Interview01&#96;-[MJPerson age] at MJPerson.h:12)</span><br></pre></td></tr></table></figure><p>我们可以看到未添加observer的对象的<code>setAge:</code>的实现，是位于<code>Interview01(二进制文件)</code>下的<code>MJPerson</code>类。</p><p>我们对添加了observer的对象进行信息打印，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p methodNames</span><br><span class="line">(__NSCFString *) $2 &#x3D; 0x0000600002143ed0 @&quot;setAge:&#123; 0x1040ebcf2 &#125;, class&#123; 0x1040ea06e &#125;, dealloc&#123; 0x1040e9e12 &#125;, _isKVOA&#123; 0x1040e9e0a &#125;, &quot;</span><br><span class="line">(lldb) p (IMP)0x1040ebcf2</span><br><span class="line">(IMP) $3 &#x3D; 0x00000001040ebcf2 (Foundation&#96;_NSSetIntValueAndNotify)</span><br></pre></td></tr></table></figure><p>我们看到<code>setAge:</code>方法的实现是调用了<code>Foundation</code>框架里面的<code>_NSSetIntValueAndNotify</code>方法。说明<code>setAge:</code>方法的实现已经不一样了，由于苹果的Foundation框架是不开源的，我们无法查看<code>_NSSetIntValueAndNotify</code>函数的内部实现，不过我们结合已知的信息，查资料，可以得出<code>_NSSetIntValueAndNotify</code>的内部实现为下伪代码</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line"><span class="keyword">void</span> _NSSetIntValueAndNotify()</span><br><span class="line">&#123;   </span><br><span class="line">    [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"age"</span>];</span><br><span class="line">    [<span class="keyword">super</span> setAge:age];</span><br><span class="line">    [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"age"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line">- (<span class="keyword">void</span>)didChangeValueForKey:(<span class="built_in">NSString</span> *)key</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 通知监听器，某某属性值发生了改变</span></span><br><span class="line">    [observer observeValueForKeyPath:key ofObject:<span class="keyword">self</span> change:<span class="literal">nil</span> context:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="窥探Foundation"><a href="#窥探Foundation" class="headerlink" title="窥探Foundation"></a>窥探Foundation</h2><p>如何验证Foundation下面确实有<code>_NSSetIntValueAndNotify</code>方法？</p><p>我们平时使用<code>Foundation.framework</code>都是已经编译后的二进制文件，不过我们可以利用反编译工具<a href="https://www.hopperapp.com/" target="_blank" rel="noopener">hopper</a>来查看<code>Foundation</code>里面的方法名和汇编代码（想拿到<code>Foundation</code>二进制文件我们通过已越狱的手机获取或者去网上搜索，hopper工具的使用这里不作介绍）。</p><p>除了Hopper，在mac上，我们还可以系统给提供的工具<code>nm(OVERVIEW: llvm symbol table dumper)</code>命令来导出函数符号表:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nm Foundation | grep ValueAndNotify</span><br></pre></td></tr></table></figure><p>我们可以确定，<code>Foundation</code>里面确实有<code>_NSSet...ValueAndNotify</code>方法。</p><h2 id="子类的内部方法"><a href="#子类的内部方法" class="headerlink" title="子类的内部方法"></a>子类的内部方法</h2><p>除了<code>setAge:</code>, 子类还有这几个方法<code>class</code>、<code>dealloc</code>、<code>_isKVOA</code></p><p>我们知道NSObject中是有class方法的，是通过<code>object_getClass()</code>方法获取的，这个子类重写class方法，是为了返回<code>MJPerson</code>这个类，也就是它原本的class，这么做是为了隐藏这个类的存在，让开发者无感，避免歧义。</p><p>子类的<code>dealloc</code>方法是为了做监听的收尾工作</p><p>结合上面的知识我们可以得出这个子类的内存结构图<br><img src="https://cdn.ticsmatic.com/img/2020-04-30/15882378127671.png" alt="KVO子类"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当添加observer时，runtime会动态创建一个子类，重写被监听属性的set方法。</p><p>KVO一定会调用<code>willChangeValueForKey:</code>、<code>didChangeValueForKey:</code>方法</p><p>思路：<br>分析两个对象，发现isa不一样，通过isa找到class，通过class找到方法列表以及<code>_NSSetIntValueAndNotify</code>方法，分析<code>_NSSetIntValueAndNotify</code>方法。引出<code>willChangeValueForKey:</code>、<code>didChangeValueForKey:</code></p><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p>1、iOS用什么方式实现对一个对象的KVO?(KVO的本质是什么)</p><ul><li>利用RuntimeAPI动态生成一个子类, 并且让instance对象的isa指向这个全新的子类</li><li>当修改instance对象的属性时, 会调用Fundation的_NSSet*ValueAndNotify函数<ul><li>willChangeValueForKey:</li><li>父类原来的setter方法</li><li>didChangeValueForKey:<ul><li>内部会触发监听器Observer的监听方法(observeValueForKeyPath:ofObject:change:context:)</li></ul></li></ul></li></ul><p>2、如果直接修改对象的成员变量, 是否会触发监听器的(observeValueForKeyPath:ofObject:change:context:)方法?</p><p>直接修改对象的成员变量, 而不调用set方法, 将不会触发观察者的observeValueForKeyPath:ofObject:change:context:方法</p><p>3、如何手动触发KVO?</p><ul><li>已知实例对象被观察的属性, 在调用set方法进行修改时, 会触发_NSSet*ValueAndNotify函数</li><li>并触发willChangeValueForKey:和didChangeValueForKey:这两个方法, 所以我们可以手动添加这两个方法, 来触发KVO</li><li>现在已知直接修改成员变量时, 不会触发KVO, 那么就在修改成员变量的前后添加这两个方法</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span>.person1 willChangeValueForKey:<span class="string">@"age"</span>];</span><br><span class="line"><span class="keyword">self</span>.person1-&gt;_age = <span class="number">21</span>;</span><br><span class="line">[<span class="keyword">self</span>.person1 didChangeValueForKey:<span class="string">@"age"</span>];</span><br></pre></td></tr></table></figure><blockquote><p>注意:<br>willChangeValueForKey:和didChangeValueForKey:, 两个方法必须同时出现, 如果只有一个, 将不会触发KVO</p></blockquote><h2 id="源码和参考"><a href="#源码和参考" class="headerlink" title="源码和参考"></a>源码和参考</h2><p>Demo源码：<a href="https://cdn.ticsmatic.com/source/2020-04-30/diceng/day04/kvo.zip" target="_blank" rel="noopener">KVO-Demo.zip</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>isa和superclass</title>
      <link href="/p/ffcce99c/"/>
      <url>/p/ffcce99c/</url>
      
        <content type="html"><![CDATA[<p>学习MJ的视频课程，整理并记录知识点–isa和superclass</p><a id="more"></a><p>[TOC]</p><p>结合之前的文章，我们已经知道objc中的对象是如下的内存结构如下：<br><img src="https://cdn.ticsmatic.com/img/2020-04-28/15880517785252.png" alt="OC对象的分类"></p><p>这里我们探究isa指针和superclass指针的作用。</p><h2 id="对象的isa指针"><a href="#对象的isa指针" class="headerlink" title="对象的isa指针"></a>对象的isa指针</h2><p>提出问题：对象的isa指针指向哪里？</p><p>分析：</p><ol><li>我们知道实例对象只保存成员变量信息，它对应的对象方法信息是保存在实例对应的类(class)对象中(因为同一个类的生成的实例默认的对象方法肯定一样，因为系统不会不优雅的为每个实例对象都开辟空间保存同样的方法<strong>信息</strong>)。</li><li>那么我们用实例对象调方法时，肯定要知道这个方法的信息，这些信息存储位置必然和类有关，所以实例对象必然能找到它对应的类，我们结合<code>OC对象的本质</code>一节，已经得知，一个没有任何变量的实例对象都有isa指针，做排除法也可得知，实例对象的isa指针指向它的类(class)对象。</li><li>同理，类(class)对象的方法信息是存储在它的元类(meta-class)中；类(class)对象的isa指针必然指向它的元类(meta-class)对象。</li></ol><p>这三种对象之间是通过isa指针联系起来的<br><img src="https://cdn.ticsmatic.com/img/2020-04-28/15880528090770.png" alt="isa指针"></p><ul><li>instance的isa指向class，当调用对象方法时，通过instance的isa找到class，最后找到对象方法的实现进行调用</li><li>class的isa指向meta-class，当调用类方法时，通过class的isa找到meta-class，最后找到类方法的实现进行调用</li></ul><h2 id="class的superclass指针"><a href="#class的superclass指针" class="headerlink" title="class的superclass指针"></a>class的superclass指针</h2><p><code>superclass</code>我们知道它是指向父类对象(super class)，这里不再啰嗦，可以看下图<br><img src="https://cdn.ticsmatic.com/img/2020-04-28/15880540516884.png" alt="class的superclass指针"></p><h2 id="meta-class的superclass指针"><a href="#meta-class的superclass指针" class="headerlink" title="meta-class的superclass指针"></a>meta-class的superclass指针</h2><p>meta-class 主要存放的是class的类方法，meta-class之间也是有对应的superclass指针的，这里不再啰嗦，可以看下图<br><img src="https://cdn.ticsmatic.com/img/2020-04-28/15880548273688.png" alt="meta-class的superclass指针"></p><h2 id="isa、superclass总结"><a href="#isa、superclass总结" class="headerlink" title="isa、superclass总结"></a>isa、superclass总结</h2><p>附上一张比较比较有名的来总结isa、superclass指针，如下<br><img src="https://cdn.ticsmatic.com/img/2020-04-28/15880551848704.png" alt="isa、superclass总结"></p><p>有两个地方需要注意：</p><ol><li>meta-class的isa指向基类的meta-class</li><li>基类的meta-class的superclass指针，指向基类的class</li></ol><p>总结：isa和superclass是重要的两根线，来<em>联通</em> instance、class、meta-class</p><p>关于方法的调用顺序我们知道，无论是实例对象还是类对象，都是先在当前类找看是否有和这个方法的实现，没有的话回去父类找，直到找到或者抛出异常。</p><p>下面我们举class方法的调用例子，来加深理解，源码在这里<a href="https://cdn.ticsmatic.com/source/2020-04-28/Interview02-isa%E5%92%8Csuperclass.zip" target="_blank" rel="noopener">下载</a><br>主要代码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MJPerson</span> : <span class="title">NSObject</span></span></span><br><span class="line">+ (<span class="keyword">void</span>)test;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MJPerson</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">Text</span>)</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">Test</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//+ (void)test &#123;</span></span><br><span class="line"><span class="comment">//    NSLog(@"+[NSObject test] - %p", self);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)test &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"-[NSObject test] - %p"</span>, <span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">// 调用一个没有实现的类方法，结果会怎样？</span></span><br><span class="line">        [MJPerson test];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>演示中，我们使用<code>MJPerson</code>调用类方法<code>test</code>，但是<code>test</code>方法是没有实现的，只有基类实现了一个对象方法。调用结果会崩溃吗？答案是程序不会崩溃，类可以调用到对象方法，看起来似乎有点让人震惊。</p><p>我们分析一下调用流程来解释为什么会是这样：<br>首先是类对象调用方法，类对象的方法信息放在元类里面，MJPerson会去自己的元类对象找，没有找到(因为已经被注释了)。继续去父类的元类对象找(NSObject的元类)，也没找到。但是，因为NSObject的元类还有superclass，就是NSObject，所以会继续去NSObject中找<code>test</code>方法的实现，找到了，然后调用这个方法，调用流程结束。<br>流程如下：<br><img src="https://cdn.ticsmatic.com/img/2020-04-28/15880607955400.png" alt="类调用对象方法"><br><a href="[Interview03-isa.zip](https://cdn.ticsmatic.com/source/2020-04-28/Interview03-isa.zip)">Demo下载</a></p><p>meta-class底层机构和class是一致，都是class，不要被方法的符号迷惑（+、-），objc消息机制只要求对象、方法名，实例方法、类方法没有本质却别。只会依据调用规则通过isa和superclass指针来查找，流程简述如下<code>isa -&gt; superclass -&gt; suerpclass -&gt; superclass -&gt; .... superclass == nil</code></p><p>和<code>Java</code>不一样，OC不是严格的面向对象，是对C语言的扩展，增加消息机制。</p><h2 id="isa指针窥探"><a href="#isa指针窥探" class="headerlink" title="isa指针窥探"></a>isa指针窥探</h2><p>前面我们知道instance对象的isa指向类对象，这里通过查看内存进行验证。</p><p>我们通过断点debug能找到一个对象的变量信息，但是isa变量的信息我们却看不到，此时，我们可以利用前面学习的LLDB调试指令，打印内存地址<code>p/x (long)instance-&gt;isa</code>，当这个打印结果和class对象的地址一直，即可验证instance对象的isa指向类对象。</p><p>但实际上的打印结果发现却发现两者不一致，因为苹果规定<em>从64bit开始，isa需要和<code>ISA_MASK</code>进行一次与运算，才能计算出真实地址</em>。</p><p>那么class对象的isa是不是也需要进行一次<code>ISA_MASK</code>的与运算，我们来验证一下。</p><p>通过<code>p/x (long)class对象-&gt;isa</code>报错，提示<code>member reference base type &#39;Class&#39; is not a structure or union</code>，我们只能先把class转成struct。</p><p>根据class的结构类型，定义<code>MJPerson</code>对应的结构体，如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> mj_objc_class &#123;</span><br><span class="line">    Class isa;</span><br><span class="line">    Class superclass;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在使用时，直接将class桥接转成对应的结构体</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> mj_objc_class *personClass = (__bridge <span class="keyword">struct</span> mj_objc_class *)([MJPerson <span class="keyword">class</span>]);</span><br></pre></td></tr></table></figure><p>此时我们就能打印结构体的isa指针了。我们打印指针地址，与上<code>ISA_MASK</code>后得到的地址确实为MJPerson的meta-class地址。总结如下图：<br><img src="https://cdn.ticsmatic.com/img/2020-04-28/15880678487777.png" alt="ISA_MASK"></p><h2 id="class和meta-class的结构"><a href="#class和meta-class的结构" class="headerlink" title="class和meta-class的结构"></a>class和meta-class的结构</h2><p>本小节窥探class、meta-class内存的结构，来证明我们之前推测的class的struct结构模型。</p><p>想了解class的结构细节，我们还是需要去看<a href="https://opensource.apple.com/source/objc4/" target="_blank" rel="noopener">objc</a>的源码，在<code>objc-runtime-new.h</code>文件中，我们能看到<code>objc_class</code>大致结构如下：<br><img src="https://cdn.ticsmatic.com/img/2020-04-29/15881252034701.png" alt="objc_class"></p><p>思路：<strong>我们可以自己创建一个class，然后仿照<code>objc_class</code>的定义，构建类似的结构体，然后把class桥接转换成结构体，如果结构体内有对应的值，说明假设成立。</strong></p><p>这里我就不粘贴代码了，这里已经通过真实的Demo进行测试，可以下载进行演示和验证<a href="[Interview04-class的结构.zip](https://cdn.ticsmatic.com/source/2020-04-28/Interview04-class-struct.zip)">Demo下载</a></p><h2 id="源码和参考"><a href="#源码和参考" class="headerlink" title="源码和参考"></a>源码和参考</h2><ul><li><a href="https://opensource.apple.com/source/objc4/objc4-723/runtime/objc-private.h.auto.html" target="_blank" rel="noopener">objc-private.h</a></li><li><a href="https://opensource.apple.com/source/objc4/objc4-723/runtime/objc-runtime-new.h.auto.html" target="_blank" rel="noopener">objc-runtime-new.h</a></li></ul><p>Demo源码：</p><ul><li><a href="https://cdn.ticsmatic.com/source/2020-04-28/diceng/day03/Interview02-isa-and-superclass.zip" target="_blank" rel="noopener">Interview02-isa和superclass.zip</a></li><li><a href="https://cdn.ticsmatic.com/source/2020-04-28/diceng/day03/Interview03-isa.zip" target="_blank" rel="noopener">Interview03-isa.zip</a></li><li><a href="https://cdn.ticsmatic.com/source/2020-04-28/diceng/day03/Interview04-class-struct.zip" target="_blank" rel="noopener">Interview04-class的结构.zip</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>OC对象的分类</title>
      <link href="/p/5a039b46/"/>
      <url>/p/5a039b46/</url>
      
        <content type="html"><![CDATA[<p>学习MJ的视频课程，整理总结知识点–Objective-C中的对象</p><a id="more"></a><p>[TOC]</p><p>Objective-C中的对象，简称OC对象，主要分为3种</p><ol><li>instance对象（实例对象）</li><li>class对象（类对象）</li><li>meta-class对象（元类对象）</li></ol><h2 id="1-instance对象"><a href="#1-instance对象" class="headerlink" title="1. instance对象"></a>1. instance对象</h2><p>instance对象是通过类alloc出来的对象，每次调用alloc都会产生新的instance对象。</p><p>实例对象主要存储的是成员变量的具体值。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSObject</span> *object1 = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line"><span class="built_in">NSObject</span> *object2 = [[<span class="built_in">NSObject</span> alloc] init];</span><br></pre></td></tr></table></figure><p>object1、object2是NSObject的instance对象（实例对象）它们是不同的两个对象，分别占据着两块不同的内存。</p><p>instance对象在内存中存储的信息包括:</p><ol><li>isa指针</li><li>其他成员变量</li></ol><p><img src="https://cdn.ticsmatic.com/img/2020-04-26/15878983196923.png" alt="instance对象在内存中存储的信息"></p><p>即：实例对象的地址是isa指针的地址，isa指针所在的内存空间后面紧跟着的是其它成员变量所占的内存空间。</p><h2 id="2-class对象"><a href="#2-class对象" class="headerlink" title="2. class对象"></a>2. class对象</h2><p>类对象主要存储的这个类的信息</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class objectClass1 = [object1 <span class="keyword">class</span>];</span><br><span class="line">Class objectClass2 = [object2 <span class="keyword">class</span>];</span><br><span class="line">Class objectClass3 = object_getClass(object1);</span><br><span class="line">Class objectClass4 = object_getClass(object2);</span><br><span class="line">Class objectClass5 = [<span class="built_in">NSObject</span> <span class="keyword">class</span>];</span><br></pre></td></tr></table></figure><p>objectClass1 ~ objectClass5都是NSObject的class对象（类对象），它们是同一个对象，每个类在内存中有且只有一个class对象</p><p>class对象在内存中存储的信息主要包括：</p><ul><li>isa指针</li><li>superclass指针</li><li>类的属性信息（@property）</li><li>类的对象方法信息（instance method）</li><li>类的协议信息（protocol）</li><li>类的成员变量信息（ivar）</li></ul><p><img src="https://cdn.ticsmatic.com/img/2020-04-26/15878983521066.png" alt="class对象在内存中存储的信息"></p><h2 id="3-meta-class-元类对象"><a href="#3-meta-class-元类对象" class="headerlink" title="3. meta-class 元类对象"></a>3. meta-class 元类对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 将类对象当做参数传入，获得元类对象</span><br><span class="line">Class objectMetaClass &#x3D; object_getClass(objectClass5);</span><br></pre></td></tr></table></figure><ul><li>objectMetaClass是NSObject的meta-class对象（元类对象）</li><li>每个类在内存中有且只有一个meta-class对象</li><li>meta-class对象和class对象的内存结构是一样的，但是用途不一样，</li><li>在内存中存储的信息主要包括isa指针superclass指针类的类方法信息（class method）</li><li>……</li></ul><p><img src="https://cdn.ticsmatic.com/img/2020-04-26/15878994097357.png" alt="meta-class对象"></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否为元类对象 runtime api</span></span><br><span class="line"><span class="built_in">BOOL</span> result = class_isMetaClass(objectClass3);</span><br></pre></td></tr></table></figure><h2 id="其它：objc-getClass-object-getClass函数"><a href="#其它：objc-getClass-object-getClass函数" class="headerlink" title="其它：objc_getClass, object_getClass函数"></a>其它：objc_getClass, object_getClass函数</h2><p>源码位于苹果开源的objc项目，相关部分如下</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* objc_getClass.  Return the id of the named class.  If the class does</span></span><br><span class="line"><span class="comment">* not exist, call _objc_classLoader and then objc_classHandler, either of </span></span><br><span class="line"><span class="comment">* which may create a new class.</span></span><br><span class="line"><span class="comment">* Warning: doesn't work if aClassName is the name of a posed-for class's isa!</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line">Class objc_getClass(<span class="keyword">const</span> <span class="keyword">char</span> *aClassName)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!aClassName) <span class="keyword">return</span> Nil;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// NO unconnected, YES class handler</span></span><br><span class="line">    <span class="keyword">return</span> look_up_class(aClassName, <span class="literal">NO</span>, <span class="literal">YES</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传入字符串类名，去查找对应的类对象</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* object_getClass.</span></span><br><span class="line"><span class="comment">* Locking: None. If you add locking, tell gdb (rdar://7516456).</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line">Class object_getClass(<span class="keyword">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果是instance对象，返回class对象</span></span><br><span class="line">    <span class="comment">// 如果是class对象，返回meta-class对象</span></span><br><span class="line">    <span class="comment">// 如果是meta-class对象，返回基类(NSObject)的meta-class对象</span></span><br><span class="line">    <span class="keyword">if</span> (obj) <span class="keyword">return</span> obj-&gt;getIsa();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> Nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>object_getClass</code>参数对象的isa指针，查找到它类、元类对象</li><li><code>objc_getClass</code>根据参数的字符，去匹配对应的class</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Objective-C中的对象，简称OC对象，主要分为3种</p><ol><li>instance对象（实例对象）</li><li>class对象（类对象）</li><li>meta-class对象（元类对象）</li></ol><p>他们的在内存中存储的信息大致如下：<br><img src="https://cdn.ticsmatic.com/img/2020-04-28/15880517785252.png" alt="OC对象的分类"></p><h2 id="参考和源码"><a href="#参考和源码" class="headerlink" title="参考和源码"></a>参考和源码</h2><p>Apple Source Browser - <a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">objc</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>OC对象的本质</title>
      <link href="/p/74ed6556/"/>
      <url>/p/74ed6556/</url>
      
        <content type="html"><![CDATA[<p>学习MJ的视频课程，整理总结知识点–OC对象的本质</p><a id="more"></a><p>[TOC]</p><blockquote><p>Objective-C是一种通用、高级、面向对象的编程语言。它扩展了标准的ANSI C编程语言，将Smalltalk式的消息传递机制加入到ANSI C中。当前主要支持的编译器有GCC和Clang（采用LLVM作为后端）<a href="https://zh.wikipedia.org/wiki/Objective-C" target="_blank" rel="noopener">维基：Objective-C</a></p></blockquote><h2 id="Objective-C和C-C"><a href="#Objective-C和C-C" class="headerlink" title="Objective-C和C_C++"></a>Objective-C和C_C++</h2><p>想探究OC对象的本质，我们可以逐步深入。我们知道，最了解一个编程语言的，莫过于它的编译器了，而我们知道Xcode内置的编译器的前端是<code>clang</code>，clang是一个<code>C、C++、Object-C</code>的轻量级编译器。<code>Objective-C</code>兼容<code>C</code>语言，我们可以通过clang编译器将Objective-C代码重写成更基础的C/C++代码，这样就能看到Object-C在C/C++下的等价实现。但是使用<code>Xcode</code>构建ObjC项目时并不会先将Objective-C代码翻译为C++，这是因为clang编译器支持直接编译Objective-C代码。</p><p>(本文为了书写方便，将<code>Object-C</code>简写为<code>OC</code>)</p><h2 id="Objective-C对象数据结构"><a href="#Objective-C对象数据结构" class="headerlink" title="Objective-C对象数据结构"></a>Objective-C对象数据结构</h2><p>我们知道OC是基于C语言扩展出来的，C是没有对象的概念，那么OC的对象是基于什么结构实现的呢？</p><p>或许我们曾经通过Xcode看过<a href="https://opensource.apple.com/source/objc4/objc4-723/runtime/objc.h" target="_blank" rel="noopener">objc.h</a>的头文件，发现如下代码</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Represents an instance of a class.</span></span><br><span class="line"><span class="keyword">struct</span> objc_object &#123;</span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>同时我们知道，结构体里面可以存放不同类型的数据。我们或许猜测到<code>NSObject</code>的底层结构是基于结构体。</p><p>事实上OC对象确实是基于结构体的实现，下面我们通过重写源码进行验证。</p><p>我们以简单main.m函数代码为例，新建一个如下图所示的工程，然后通过<code>clang</code>命令把main函数及内部的<code>NSObject</code>重写为C++的实现，即可了解objc对象的实现。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="built_in">NSObject</span> *obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>终端切换到main.m所在的目录，然后执行clang命令，如下：<br>(关于命令的使用我们可以通过<code>clang --help</code>来了解)</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -rewrite-objc main.m -o main.cpp</span><br></pre></td></tr></table></figure><p>打开<code>main.cpp</code>文件，如下图，我们在最后看到<code>main.m</code>函数的实现，同时还可以一窥OC的消息机制</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line">        <span class="built_in">NSObject</span> *obj = ((<span class="built_in">NSObject</span> *(*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *)objc_msgSend)((<span class="keyword">id</span>)((<span class="built_in">NSObject</span> *(*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *)objc_msgSend)((<span class="keyword">id</span>)objc_getClass(<span class="string">"NSObject"</span>), sel_registerName(<span class="string">"alloc"</span>)), sel_registerName(<span class="string">"init"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，我们在<code>main.cpp</code>可以看到这样的一段代码</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NSObject_IMPL (NSObject_IMPLEMENTATION)</span></span><br><span class="line"><span class="keyword">struct</span> <span class="built_in">NSObject_IMPL</span> &#123;</span><br><span class="line">    Class isa;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>即说明了<strong>NSObject对象是通过结构体实现的，且内部只有一个Class(结构体)指针</strong>。</p><h2 id="NSObject的内存本质"><a href="#NSObject的内存本质" class="headerlink" title="NSObject的内存本质"></a>NSObject的内存本质</h2><p>通过上面的内容，我们已经知道NSObject对象的底层实现是结构体，且内部只有一个isa结构体指针，这个指针指向Class的起始地址。<br><img src="https://cdn.ticsmatic.com/img/2020-04-25/15878144233974.png" alt="NSObject的底层实现"></p><h2 id="class-getInstanceSize、malloc-size"><a href="#class-getInstanceSize、malloc-size" class="headerlink" title="class_getInstanceSize、malloc_size"></a>class_getInstanceSize、malloc_size</h2><p>知道了NSObject的内存结构后，接下来我们探讨一个NSObject对象占用多少内存？</p><p>思路：通过上面的小节，我们已经知道NSObject对象内部只有一个isa结构体指针，我们知道在64位中操作系统中，指针占用内存空间是8个字节，所以我们推测一个NSObject对象应该只占8个字节，事实是否如此？我们可以利用系统提供的<code>malloc_size</code>函数进行验证。</p><p>通过系统提供的函数即可获得，如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="built_in">NSObject</span> *obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获得NSObject实例对象的成员变量所占用的大小 &gt;&gt; 8</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%zd"</span>, class_getInstanceSize([<span class="built_in">NSObject</span> <span class="keyword">class</span>]));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获得obj指针所指向内存的大小 &gt;&gt; 16</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%zd"</span>, malloc_size((__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)obj));</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更进一步，我们可以研究<code>class_getInstanceSize、malloc_size</code>这两个函数的实现，因为苹果已经开源了<a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">objc</a>，我们可以查找相应的实现代码从而做到知其所以然。</p><p>苹果的源码开放地址为：<a href="https://opensource.apple.com/tarballs/" target="_blank" rel="noopener">Source Browser</a>，如果想研究苹果的源码一般都是访问这个地址。我们下载objc4的最新源码，然后解压打开源码。搜索我们要找的源码<code>class_getInstanceSize</code>，结果如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">size_t class_getInstanceSize(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> cls-&gt;alignedInstanceSize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到<code>alignedInstanceSize</code>函数的实现如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Class's ivar size rounded up to a pointer-size boundary.</span></span><br><span class="line">uint32_t alignedInstanceSize() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> word_align(unalignedInstanceSize());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从而得出结论：<code>class_getInstanceSize</code>是获得NSObject实例对象的成员变量所占用的空间大小(isa指针所占的空间)，占用的空间大小8字节。</p><p>但是我们通过<code>malloc_size</code>获取到的空间大小是16字节，为什么？</p><p>接下来我们探究<code>malloc_size</code>的实现。我们知道<code>malloc_size</code>是调用的<code>alloc</code>方法，而<code>alloc</code>会调用<code>allocWithZone</code>，我们在源码中搜索<code>allocWithZone</code>，会在<code>NSObject.mm</code>文件中看到类似如下的实现</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Call [cls alloc] or [cls allocWithZone:nil], with appropriate </span></span><br><span class="line"><span class="comment">// shortcutting optimizations.</span></span><br><span class="line"><span class="keyword">static</span> ALWAYS_INLINE <span class="keyword">id</span></span><br><span class="line">callAlloc(Class cls, <span class="keyword">bool</span> checkNil, <span class="keyword">bool</span> allocWithZone=<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __OBJC2__</span></span><br><span class="line">    <span class="keyword">if</span> (slowpath(checkNil &amp;&amp; !cls)) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())) &#123;</span><br><span class="line">        <span class="keyword">return</span> _objc_rootAllocWithZone(cls, <span class="literal">nil</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们研究<code>_objc_rootAllocWithZone</code>的实现会发现如下调用顺序：<br><code>_objc_rootAllocWithZone</code> -&gt;<code>_class_createInstanceFromZone</code></p><p>我们搜索<code>_class_createInstanceFromZone</code>的实现，会有如下发现：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> ALWAYS_INLINE <span class="keyword">id</span></span><br><span class="line">_class_createInstanceFromZone(Class cls, size_t extraBytes, <span class="keyword">void</span> *zone,</span><br><span class="line">                              <span class="keyword">int</span> construct_flags = OBJECT_CONSTRUCT_NONE,</span><br><span class="line">                              <span class="keyword">bool</span> cxxConstruct = <span class="literal">true</span>,</span><br><span class="line">                              size_t *outAllocatedSize = <span class="literal">nil</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(cls-&gt;isRealized());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read class's info bits all at once for performance</span></span><br><span class="line">    <span class="keyword">bool</span> hasCxxCtor = cxxConstruct &amp;&amp; cls-&gt;hasCxxCtor();</span><br><span class="line">    <span class="keyword">bool</span> hasCxxDtor = cls-&gt;hasCxxDtor();</span><br><span class="line">    <span class="keyword">bool</span> fast = cls-&gt;canAllocNonpointer();</span><br><span class="line">    size_t size;</span><br><span class="line"></span><br><span class="line">    size = cls-&gt;instanceSize(extraBytes);</span><br><span class="line">    <span class="keyword">if</span> (outAllocatedSize) *outAllocatedSize = size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">id</span> obj;</span><br><span class="line">    <span class="keyword">if</span> (zone) &#123;</span><br><span class="line">        obj = (<span class="keyword">id</span>)malloc_zone_calloc((malloc_zone_t *)zone, <span class="number">1</span>, size);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        obj = (<span class="keyword">id</span>)calloc(<span class="number">1</span>, size);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>然后发现关键的地方，变量size的值是通过<code>instanceSize</code>函数返回的，我们查找<code>instanceSize</code>的源码，然后会有如下发现</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">size_t instanceSize(size_t extraBytes) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (fastpath(cache.hasFastInstanceSize(extraBytes))) &#123;</span><br><span class="line">        <span class="keyword">return</span> cache.fastInstanceSize(extraBytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size_t size = alignedInstanceSize() + extraBytes;</span><br><span class="line">    <span class="comment">// CF requires all objects be at least 16 bytes.</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt; <span class="number">16</span>) size = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的源码有两个关键的地方</p><ol><li><p><code>alignedInstanceSize</code><br>我们在上面已经知道它返回的是成员变量所占用的空间大小，NSObject对象占用的大小为8字节。</p></li><li><p><code>// CF requires all objects be at least 16 bytes.</code>。<br>我们可以知道分配的size一旦小于16，CoreFoundation框架会返回最小值16。</p></li></ol><p>至于<code>alignedInstanceSize</code>函数以及CF框架为什么会是16，这里不再深究，感兴趣的可以搜索<code>内存对齐</code>。这里简述一下：<code>内存对齐(数据结构对齐)是方便访问，OC对象占用的空间大小都是16的倍数</code>，结构体的内存对齐最小单元是8字节</p><p>这里做一下总结：<br><strong>系统分配了16个字节给NSObject对象（通过malloc_size函数获得），但是NSObject内部只占用了8个字节的空间(64为环境下，可以通过class_getInstanceSize函数获得)</strong></p><h2 id="实时查看内存数据"><a href="#实时查看内存数据" class="headerlink" title="实时查看内存数据"></a>实时查看内存数据</h2><h3 id="View-Memory"><a href="#View-Memory" class="headerlink" title="View Memory"></a>View Memory</h3><p>了解一个对象所占用内存具体情况，我们可以利用Xcode的菜单栏上的<code>Debug</code> -&gt; <code>Debug Workfllow</code> -&gt; <code>View Memory</code>，来查看一个对象的内存占用情况。<br><img src="https://cdn.ticsmatic.com/img/2020-04-26/15878672862734.png" alt="屏幕快照 2020-04-26 上午10.08.44"></p><p>备注：内存中0000…一般代表未使用的空白空间</p><h3 id="LLDB"><a href="#LLDB" class="headerlink" title="LLDB"></a>LLDB</h3><p>我们还可以通过Xcode提供的<code>LLDB</code>进行断点调试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print、p：打印地址</span><br><span class="line">po：打印对象</span><br></pre></td></tr></table></figure><p>读取内存 <code>memory read</code> (简写为<code>x</code>)<br>例：<code>x/4xw 0x100550c20</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">memory read&#x2F;数量格式字节数 内存地址</span><br><span class="line">x&#x2F;数量格式字节数 内存地址</span><br></pre></td></tr></table></figure><p>修改内存中的值 <code>memory write</code><br>例： <code>memory write 0x100550c29 10</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">memory  write  内存地址  数值</span><br></pre></td></tr></table></figure><h2 id="自定义对象-Student-的本质"><a href="#自定义对象-Student-的本质" class="headerlink" title="自定义对象(Student)的本质"></a>自定义对象(Student)的本质</h2><p>我们研究NSObject对象后，继续研究简单的自定义对象，以<code>Student</code>对象为例，我们可以根据NSObject的内存结构推断出下面的结果。我们同样可以使用clang对这里的OC源码重新进行验证。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Student_IMPL &#123;</span><br><span class="line">    Class isa;</span><br><span class="line">    <span class="keyword">int</span> _no; </span><br><span class="line">    <span class="keyword">int</span> _age; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">@public</span></span><br><span class="line">    <span class="keyword">int</span> _no; <span class="comment">// 4个字节</span></span><br><span class="line">    <span class="keyword">int</span> _age; <span class="comment">// 4个字节</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Student</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        Student *stu = [[Student alloc] init];</span><br><span class="line">        <span class="comment">// 通过指针直接访问成员变量</span></span><br><span class="line">        stu-&gt;_no = <span class="number">4</span>;</span><br><span class="line">        stu-&gt;_age = <span class="number">5</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%zd"</span>, class_getInstanceSize([Student <span class="keyword">class</span>])); <span class="comment">// 16个字节 (8 + 4 + 4)</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%zd"</span>, malloc_size((__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)stu)); <span class="comment">// 16个字节</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 等价结构体</span></span><br><span class="line">        <span class="keyword">struct</span> Student_IMPL *stuImpl = (__bridge <span class="keyword">struct</span> Student_IMPL *)stu;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"no is %d, age is %d"</span>, stuImpl-&gt;_no, stuImpl-&gt;_age); <span class="comment">// no is 4, age is 5</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Student的内存布局"><a href="#Student的内存布局" class="headerlink" title="Student的内存布局"></a>Student的内存布局</h2><p>Student对象占用了16个字节的内存空间，前8个字节放isa指针，接下来4位放_no变量，最后4位放_age变量。<br><img src="https://cdn.ticsmatic.com/img/2020-04-26/15878700947621.png" alt="Student内存布局"></p><p>我们还可以通过<code>View Memory</code>验证，以及通过LLDB重写内存验证这一结论。</p><p>通过上面的验证，可以知道Student的真实结构如下<br><img src="https://cdn.ticsmatic.com/img/2020-04-26/15878705451221.png" alt="Student结构"></p><h2 id="更复杂的继承结构"><a href="#更复杂的继承结构" class="headerlink" title="更复杂的继承结构"></a>更复杂的继承结构</h2><p><img src="https://cdn.ticsmatic.com/img/2020-04-26/15878710559254.png" alt="屏幕快照 2020-04-26 上午11.16.39"></p><p>结论：Person对象占用了16个字节的内存空间，Student也占用了16个字节的内存空间。</p><p>备注：Student对象的Person_IVARS其实占用了16个字节的内存空间，但是有4个字节的未使用空间，_no变量大小为4个字节，刚好利用这4个内存空间。</p><p>我们可以通过<code>malloc_size</code>函数进行验证这个结论</p><h2 id="属性和方法"><a href="#属性和方法" class="headerlink" title="属性和方法"></a>属性和方法</h2><p>当我们为Person类增加一个属性时，如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@public</span></span><br><span class="line">    <span class="keyword">int</span> _age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="keyword">int</span> height;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>我们知道<code>@property</code>默认会生成一个带下划线的变量，以及对应属性set和get方法，我们再次通过clang命令编译重写导出后能看到如下代码</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Person_IMPL &#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="built_in">NSObject_IMPL</span> <span class="built_in">NSObject_IVARS</span>;</span><br><span class="line"><span class="keyword">int</span> _age;</span><br><span class="line"><span class="keyword">int</span> _height;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>也即验证了@property可以生成对应的变量。</p><p>关于@property生成的方法的细节，我们在后面的文章中再讲解</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>OC对象的本质是结构体</li><li>系统分配了16个字节给NSObject对象，但NSObject对象内部只使用了8个字节的空间（64bit环境下，可以通过class_getInstanceSize函数获得）</li><li><code>class_getInstanceSize</code>返回的是需要的最小空间，<code>malloc_size</code>返回的是实际分配的内存空间大小</li></ul><h2 id="参考和源码"><a href="#参考和源码" class="headerlink" title="参考和源码"></a>参考和源码</h2><p>Apple Source Browser - <a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">objc</a></p>]]></content>
      
      
      <categories>
          
          <category> ios </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 底层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitBook安装和使用</title>
      <link href="/p/9aea9f9/"/>
      <url>/p/9aea9f9/</url>
      
        <content type="html"><![CDATA[<p>介绍GitBook安装和使用</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>GitBook 是一个基于 Node.js 的命令行工具，支持 Markdown 和 AsciiDoc 两种语法格式，可以输出 HTML、PDF、eBook 等格式的电子书。所以我更喜欢把 GitBook 定义为文档格式转换工具。</p><p>因为 GitBook 是基于 Node.js，所以我们首先需要安装 Node.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 检查是否有Node.js环境</span><br><span class="line">$ node -v</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果没有node环境的，先安装Node环境</span><br><span class="line">$ brew install node</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 现在安装 Node.js 都会默认安装 npm（node 包管理工具），所以我们不用单独安装 npm，打开命令行，执行以下命令安装 GitBook：</span><br><span class="line">npm install -g gitbook-cli</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 检查是否安装成功</span><br><span class="line">gitbook -v</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>想象一下，现在你准备构建一本书籍，你在硬盘上新建了一个叫 mybook 的文件夹，按照以前的做法，你会新建一个 Word 文档，写上标题，然后开始巴滋巴滋地笔耕。但是现在有了 GitBook，你首先要做的是在 mybook 文件夹下执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitbook init</span><br></pre></td></tr></table></figure><p>执行完后，你会看到多了两个文件 —— README.md 和 SUMMARY.md，它们的作用如下：</p><blockquote><p>README.md —— 书籍的介绍写在这个文件里<br>SUMMARY.md —— 书籍的目录结构在这里配置</p></blockquote><p>然后就是编辑这个书的目录了，实际上需要一个支持MarkDown的编辑器，我们使用VSCode，来编辑 README.md 和 SUMMARY.md文件</p><p>编辑 SUMMARY.md 文件，内容修改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* [Python 基础](README.md)</span><br><span class="line">* 1.python基础</span><br><span class="line">  * [1.1.认识Python](day01&#x2F;01-Python简介.md)</span><br><span class="line">  * [1.2.第一个Python程序](day01&#x2F;02-第一个程序.md)</span><br><span class="line">  * [1.3.Pycharm设置（知道）](day01&#x2F;03-Pycharm设置（知道）.md)</span><br><span class="line">  * [1.4.多文件项目的演练](day02&#x2F;04-多文件项目的演练.md)</span><br><span class="line">  * [1.5.注释](day02&#x2F;05-注释.md)</span><br><span class="line">  * [1.6.算数运算符](day02&#x2F;06-算数运算符.md)</span><br><span class="line">  * [1.7.程序执行原理（科普）](day02&#x2F;07-程序执行原理（科普）.md)</span><br><span class="line">  * [1.8.变量的基本使用](day02&#x2F;08-变量的基本使用.md)</span><br><span class="line">* day03</span><br><span class="line">  * [1.9.变量的命名](day03&#x2F;09-变量的命名.md)</span><br><span class="line">  * [1.10.判断（if）语句](day03&#x2F;10-判断（if）语句.md)</span><br><span class="line">  * [1.11.运算符](day03&#x2F;11-运算符.md)</span><br><span class="line">  * [1.12.循环](day03&#x2F;12-循环.md)</span><br><span class="line">* day04</span><br><span class="line">  * [函数基础](day04&#x2F;函数基础.md)</span><br><span class="line">* day05</span><br><span class="line">  * [高级变量类型](day05&#x2F;高级变量类型.md)</span><br><span class="line">* day06</span><br><span class="line">  * [综合应用——名片管理系统](day06&#x2F;综合应用——名片管理系统.md)</span><br><span class="line">* day07</span><br><span class="line">  * [变量进阶（理解）](day07&#x2F;变量进阶（理解）.md)</span><br><span class="line">  * [函数进阶](day07&#x2F;函数进阶.md)</span><br></pre></td></tr></table></figure><p>然后我们回到命令行，在 mybook 文件夹中再次执行<code>gitbook init</code>命令。GitBook 会查找 SUMMARY.md 文件中描述的目录和文件，如果没有则会将其创建。</p><p>接着我们执行<code>gitbook serve</code> 来预览这本书籍，执行命令后会对 Markdown 格式的文档进行转换，默认转换为 html 格式，最后提示 “Serving book on <a href="http://localhost:4000”。嗯，打开浏览器看一下吧">http://localhost:4000”。嗯，打开浏览器看一下吧</a>.</p><p>当你写得差不多，你可以执行 gitbook build 命令构建书籍，默认将生成的静态网站输出到 _book 目录。实际上，这一步也包含在 gitbook serve 里面，因为它们是 HTML，所以 GitBook 通过 Node.js 给你提供服务了。</p><p>当然，build 命令可以指定路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitbook build [书籍路径] [输出路径]</span><br></pre></td></tr></table></figure><p>serve 命令也可以指定端口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitbook serve --port 2333</span><br></pre></td></tr></table></figure><p>你还可以生成 PDF 格式的电子书：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gitbook pdf .&#x2F; .&#x2F;mybook.pdf</span><br><span class="line">gitbook epub .&#x2F; .&#x2F;mybook.epub</span><br><span class="line">gitbook mobi .&#x2F; .&#x2F;mybook.mobi</span><br></pre></td></tr></table></figure><p>如果生成不了，你可能还需要安装一些工具，比如 ebook-convert。或者在 Typora 中安装 Pandoc 进行导出。</p><p>此时基本就完成了。</p><h2 id="安装过程中遇到的问题"><a href="#安装过程中遇到的问题" class="headerlink" title="安装过程中遇到的问题"></a>安装过程中遇到的问题</h2><ol><li><p><code>gitbook init</code>超时<br>解决：替换npm的源</p></li><li><p><code>gitbook build</code>生成的html本地不能跳转<br>解决：修改书籍下”theme.js”文件的内容。把<code>if(m)for(</code>替换为<code>if(false)for(</code></p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>使用Hexo搭建博客</title>
      <link href="/p/eb656981/"/>
      <url>/p/eb656981/</url>
      
        <content type="html"><![CDATA[<p>介绍使用Hexo搭建博客</p><a id="more"></a><p>[TOC]</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>mac 10.14<br>默认已安装好了HomeBrew和Git</p><h2 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h2><h3 id="安装Node-js环境"><a href="#安装Node-js环境" class="headerlink" title="安装Node.js环境"></a>安装Node.js环境</h3><p>先检测电脑山管是否安装有Node.js环境，能正确显示版本号即表示node安装成功（mac不自带Node.js环境）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm -v</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> node -v</span></span><br></pre></td></tr></table></figure><p>安装Node.js（Hexo是基于Node.js环境的）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> brew install node</span></span><br></pre></td></tr></table></figure><p>安装npm</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install</span><br></pre></td></tr></table></figure><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -g表示全局安装</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install hexo-cli -g</span></span><br></pre></td></tr></table></figure><h3 id="初始化博客"><a href="#初始化博客" class="headerlink" title="初始化博客"></a>初始化博客</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd myblog             # 创建并进入存储博客的目录(myblog)</span><br><span class="line">$ hexo init             # 初始化本地博客</span><br></pre></td></tr></table></figure><h3 id="生成并运行服务"><a href="#生成并运行服务" class="headerlink" title="生成并运行服务"></a>生成并运行服务</h3><p>执行下述命令生成本地网页文件并开启服务器，然后通过<a href="http://localhost:4000查看本地博客。">http://localhost:4000查看本地博客。</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g                # Generate static files</span><br><span class="line">$ hexo s                # Run server</span><br></pre></td></tr></table></figure><h3 id="关联GitHub"><a href="#关联GitHub" class="headerlink" title="关联GitHub"></a>关联GitHub</h3><p>修改myblog目录下的_config.yml文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy: </span><br><span class="line">  type: git</span><br><span class="line">  repo: 这里填入你之前在GitHub上创建仓库的完整路径，记得加上 .git</span><br><span class="line">  branch: maste</span><br></pre></td></tr></table></figure><p>双线部署</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo:</span><br><span class="line">    gitee: https:&#x2F;&#x2F;gitee.com&#x2F;ticsmatic&#x2F;ticsmatic.git</span><br><span class="line">    github: https:&#x2F;&#x2F;github.com&#x2F;ticsmatic&#x2F;ticsmatic.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>部署发布</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g </span><br><span class="line">$ hexo d &#x2F;&#x2F; Deploy to remote sites</span><br><span class="line">或者使用组合命令：</span><br><span class="line">$ hexo d -g</span><br></pre></td></tr></table></figure><p>若执行<code>hexo g</code>出错则执行<code>npm install hexo --save</code>，<br>若执行<code>hexo d</code>出错则执行<code>npm install hexo-deployer-git --save</code>。错误修正后再次执行<code>hexo g</code>和<code>hexo d</code>上传到服务器</p><p>若未关联GitHub，执行hexo d时会提示输入GitHub账号用户名和密码，即:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">username for &#39;https:&#x2F;&#x2F;github.com&#39;:</span><br><span class="line">password for &#39;https:&#x2F;&#x2F;github.com&#39;:</span><br></pre></td></tr></table></figure><p><code>hexo d</code>执行成功后便可通过git 仓库地址访问博客，看到的内容和<a href="http://localhost:4000相同。">http://localhost:4000相同。</a></p><h3 id="更换Hexo主题"><a href="#更换Hexo主题" class="headerlink" title="更换Hexo主题"></a>更换Hexo主题</h3><p>以比较精简的为例 <a href="https://www.haomwei.com/technology/maupassant-hexo.html" target="_blank" rel="noopener">maupassant</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;tufu9441&#x2F;maupassant-hexo.git themes&#x2F;maupassant</span><br><span class="line">$ npm install hexo-renderer-pug --save</span><br><span class="line">$ npm install hexo-renderer-sass --save</span><br></pre></td></tr></table></figure><p>将myblog目录下_config.yml里的theme的名称landscape更改为next。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g  &#x2F;&#x2F; 生成缓存和静态文件</span><br><span class="line">$ hexo d  &#x2F;&#x2F; 重新部署到服务器</span><br><span class="line">$ hexo s  &#x2F;&#x2F; Run server</span><br></pre></td></tr></table></figure><p>当本地博客部署到服务器后，网页端无变化时可以采用下述命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean  &#x2F;&#x2F; 清楚缓存文件(db.json)和已生成的静态文件(public)</span><br></pre></td></tr></table></figure><p>推荐主题</p><ul><li><a href="https://github.com/huweihuang/hexo-theme-huweihuang" target="_blank" rel="noopener">A-Boy</a></li><li><a href="https://github.com/huweihuang/hexo-theme-huweihuang" target="_blank" rel="noopener">Anisina</a></li><li><a href="https://link.jianshu.com/?t=https://github.com/icylogic/maupassant-hexo" target="_blank" rel="noopener">Maupassant</a> 更适用于写文章</li><li><a href="https://link.jianshu.com/?t=https://github.com/wuchong/jacman" target="_blank" rel="noopener">Jacman</a></li><li><a href="https://xaoxuu.com/wiki/material-x/" target="_blank" rel="noopener">Material-X</a></li><li><a href="https://github.com/SukkaW/hexo-theme-suka" target="_blank" rel="noopener">hexo-theme-suka</a></li><li><a href="https://github.com/xaoxuu/hexo-theme-volantis" target="_blank" rel="noopener">volantis</a> ✔️</li></ul><h2 id="写个博客"><a href="#写个博客" class="headerlink" title="写个博客"></a>写个博客</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new &quot;article title&quot;</span><br></pre></td></tr></table></figure><p>然后执行生成，发布即可</p><h2 id="其它知识"><a href="#其它知识" class="headerlink" title="其它知识"></a>其它知识</h2><p>当安装的一些插件不需要时，可以卸载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall 模块</span><br><span class="line"> </span><br><span class="line">删除本地模块时你应该思考的问题：是否将在package.json上的相应依赖信息也消除？</span><br><span class="line">npm uninstall 模块：删除模块，但不删除模块留在package.json中的对应信息</span><br><span class="line">npm uninstall 模块 --save 删除模块，同时删除模块留在package.json中dependencies下的对应信息</span><br><span class="line">npm uninstall 模块 --save-dev 删除模块，同时删除模块留在package.json中devDependencies下的对应信息</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">hexo官方文档</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Git基础操作</title>
      <link href="/p/22f526fc/"/>
      <url>/p/22f526fc/</url>
      
        <content type="html"><![CDATA[<p>z</p><a id="more"></a><h3 id="Git基础操作"><a href="#Git基础操作" class="headerlink" title="Git基础操作"></a>Git基础操作</h3><p><img src="https://cdn.ticsmatic.com/git_storehouse_desc.png" alt="git仓库介绍"></p><p>更多参考：<a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">GitBook V2</a></p><h4 id="配置账户"><a href="#配置账户" class="headerlink" title="配置账户"></a>配置账户</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git version                           # 查看版本</span><br><span class="line">$ git config -l                         # 查看当前配置</span><br><span class="line">$ git config --global user.name &quot;Dean&quot;  # 设置用户名，邮箱 </span><br><span class="line">$ git config --global user.email g.xiangyu1990@gmail.com    # 设置用户名，邮箱 </span><br><span class="line">$ git config --global alias.ci commit   # 设置git命令的别名</span><br><span class="line">$ git config --global alias.co checkout # 设置git命令的别名</span><br></pre></td></tr></table></figure><h4 id="仓库-repository"><a href="#仓库-repository" class="headerlink" title="仓库(repository)"></a>仓库(repository)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git init                              # 创建一个本地的git仓库</span><br><span class="line">$ git clone https:&#x2F;&#x2F;xx.git &#x2F;path        # 克隆一个远程的git仓库到指定路径</span><br></pre></td></tr></table></figure><h4 id="添加-add"><a href="#添加-add" class="headerlink" title="添加(add)"></a>添加(add)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git add fileA fileB                   # 将本地指定文件名或目录（新增和修改，没有删除）的文件添加到暂存区</span><br><span class="line">$ git add .                             # 将本地所有的（新增和修改，没有删除）文件添加到暂存区</span><br><span class="line">$ git add -u                            # 将本地的（修改和删除，没有新增）文件添加到暂存区</span><br><span class="line">$ git add -A                            # 将本地所有改动添加到暂存区（git add -A &#x3D; git add . + git add -u）</span><br></pre></td></tr></table></figure><h4 id="删除-重命名-rm-mv"><a href="#删除-重命名-rm-mv" class="headerlink" title="删除/重命名(rm/mv)"></a>删除/重命名(rm/mv)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git rm &lt;file&gt;                           # 删除文件</span><br><span class="line">git rm -r &lt;floder&gt;                      # 删除文件夹</span><br><span class="line">git rm --cached &lt;file&gt;                  # 从版本库中删除文件，但不删除文件，此时文件只会在本地存在 </span><br><span class="line">git mv &lt;old_name&gt; &lt;new_name&gt;            # 文件重命名</span><br></pre></td></tr></table></figure><h4 id="提交-commit"><a href="#提交-commit" class="headerlink" title="提交(commit)"></a>提交(commit)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git commit m &quot;add file&quot;</span><br><span class="line">$ git commit -am &quot;add file&quot;             # 等价于git add . + git commit -m &quot;add file&quot;</span><br><span class="line">$ git commit -m &quot;add fileA&quot; readme.md   # 提交一个文件</span><br><span class="line">$ git commit &quot;增补提交&quot; --amend          # 增补提交             </span><br><span class="line">$ git commit -C head --amend</span><br></pre></td></tr></table></figure><h4 id="状态-status"><a href="#状态-status" class="headerlink" title="状态(status)"></a>状态(status)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git status                            # 查看你的代码在缓存与当前工作目录的状态</span><br><span class="line">$ git status -s                         # 将结果以简短的形式输出</span><br><span class="line">$ git status --ignored                  # 显示被忽略的文件</span><br></pre></td></tr></table></figure><h4 id="差异-diff"><a href="#差异-diff" class="headerlink" title="差异(diff)"></a>差异(diff)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git diff                              # 查看工作目录（working tree）暂存区（index）的差别</span><br><span class="line">$ git diff --cached                     # 查看暂存起来的文件（stage）与并未提交（commit）的差别</span><br><span class="line">$ git diff --staged                     # 同上</span><br><span class="line">$ git diff HEAD                         # 查看最后一次提交之后的的差别（HEAD代表最近一次commit的信息）</span><br><span class="line">$ git diff --stat                       # 查看显示简略结果(文件列表)</span><br><span class="line">$ git diff commit1 commit2              # 对比两次提交的内容（也可以是branch，哈希值）</span><br></pre></td></tr></table></figure><h4 id="查看历史-log"><a href="#查看历史-log" class="headerlink" title="查看历史(log)"></a>查看历史(log)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># https:&#x2F;&#x2F;git-scm.com&#x2F;docs&#x2F;git-log</span><br><span class="line">$ git log -2                            # 查看前2次修改</span><br><span class="line">$ git log --oneline                     # 一行显示一条log</span><br><span class="line">$ git log -p                            # 查看详细修改内容 </span><br><span class="line">$ git log --stat                        # 查看提交统计信息</span><br><span class="line">$ git log --graph                       # 显示何时出现了分支和合并等信息</span><br><span class="line">$ git reflog                            # 重返未来，以便确定要回到未来的哪个版本</span><br></pre></td></tr></table></figure><h4 id="暂存-stash"><a href="#暂存-stash" class="headerlink" title="暂存(stash)"></a>暂存(stash)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git stash                             # 存储</span><br><span class="line">$ git stash save &quot;message&quot;              # 存储加说明</span><br><span class="line">$ git stash list                        # 查看储藏列表</span><br><span class="line">$ git stash pop                         # 恢复并删除存储</span><br><span class="line">$ git stash apply                       # 恢复最新的保存，但不删除</span><br><span class="line">$ git stash drop stash@&#123;0&#125;              # 删除</span><br><span class="line">$ git stash clear                       # 删除所有</span><br></pre></td></tr></table></figure><h4 id="取消-重置-checkout-reset"><a href="#取消-重置-checkout-reset" class="headerlink" title="取消/重置(checkout/reset)"></a>取消/重置(checkout/reset)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout file1 file2              # 撤销未提交的修改</span><br><span class="line">$ git checkout .                        # 撤销所有未提交的文件修改</span><br><span class="line"></span><br><span class="line">$ git reset --mixed                     # git reset默认值，重置暂存区，但不改变工作区，再提交的话需要先添加到暂存区再commit</span><br><span class="line">$ git reset --soft                      # 回退到某个版本，不改变暂存区和工作区（如果还要提交，直接commit即可）</span><br><span class="line">$ git reset --hard                      # 彻底回退到某个版本，替换暂存区和工作区，本地的源码也会变为上一个版本的内容</span><br><span class="line"># 彻底回退到某个版本</span><br><span class="line">$ git reset commit_id</span><br><span class="line">$ git reset head^</span><br><span class="line">$ git reset filename                    # 将文件撤出暂存区（相当于git add filename的反向操作）</span><br></pre></td></tr></table></figure><h4 id="撤销-revert"><a href="#撤销-revert" class="headerlink" title="撤销(revert)"></a>撤销(revert)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git revert commit                     # 撤销指定commit</span><br><span class="line">$ git revert -no-edit HEAD              # 撤销上一次并直接使用默认注释</span><br><span class="line">$ git revert -n HEAD                    # 撤销上一次但不commit</span><br><span class="line">$ git revert -m 1 mergecomitid          # 撤销分支的合并，且保留现有分支之后的提交记录</span><br><span class="line"></span><br><span class="line">(实践：feature分支合并到Dev分支，一段时间后发现这个feature分支有严重的bug，影响到Dev分支下业务的进行需要撤销掉feature分支的代码，可使用git revert命令，常用的附加参数是‘-m 1’，代表保留dev分支后的代码。撤销提交过程一般会有冲突，解决冲突，提交代码为commitidR, 当feature分支的bug修复完成，再次往Dev合并时，需要先git revert commitidR，然后把feature合并到dev上，流程完毕)</span><br></pre></td></tr></table></figure><h4 id="本地分支"><a href="#本地分支" class="headerlink" title="本地分支"></a>本地分支</h4><h5 id="查看、新建、切换"><a href="#查看、新建、切换" class="headerlink" title="查看、新建、切换"></a>查看、新建、切换</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ git branch -a                         # 列出所有分支信息</span><br><span class="line">$ git branch &lt;branchname&gt;               # 新建分支</span><br><span class="line">$ git checkout &lt;branchname&gt;             # 切换分支</span><br><span class="line">$ git checkout -b &lt;branchname&gt;          # 基于当前分支创建并且换到新分支</span><br><span class="line">$ git branch feature&#x2F;login 82b31b       # 基于某次提交、分支、或标签新建分支</span><br><span class="line">$ git branch tmp feature&#x2F;login</span><br></pre></td></tr></table></figure><h5 id="分支合并-merge"><a href="#分支合并-merge" class="headerlink" title="分支合并(merge)"></a>分支合并(merge)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ git merge feature&#x2F;login               # 在develop分支上，把feature分支合并到develop分支</span><br><span class="line">$ git merge feature --no-ff -m &quot;msg&quot;    # 强制显示每次操作</span><br></pre></td></tr></table></figure><h5 id="变基-rebase"><a href="#变基-rebase" class="headerlink" title="变基(rebase)"></a>变基(rebase)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase &lt;branch_name&gt;              # 目标分支</span><br><span class="line">$ git rebase --continue                 # 执行rebase出现冲突解决后，执行该命令会继续应用(apply)余下的补丁</span><br><span class="line">$ git rebase --skip                     # 跳过当前提交，取以服务端为准</span><br><span class="line">$ git rebase --abort                    # 终止rebase, 分支会回到rebase开始前的状态</span><br></pre></td></tr></table></figure><h5 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d feature&#x2F;login</span><br><span class="line">$ git branch -D feature&#x2F;login           # 强制删除，即使分支没有被合并也删除</span><br></pre></td></tr></table></figure><h4 id="远端分支"><a href="#远端分支" class="headerlink" title="远端分支"></a>远端分支</h4><h5 id="新建、删除、关联本地分支"><a href="#新建、删除、关联本地分支" class="headerlink" title="新建、删除、关联本地分支"></a>新建、删除、关联本地分支</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin locbranch:originbranch               # 新建</span><br><span class="line">$ git push origin --delete &lt;branchname&gt;                 # 删除</span><br><span class="line">$ git branch --set-upstream-to&#x3D;origin&#x2F;develop develop   # 关联本地分支</span><br></pre></td></tr></table></figure><h5 id="分支拉取-fetch-pull"><a href="#分支拉取-fetch-pull" class="headerlink" title="分支拉取(fetch/pull)"></a>分支拉取(fetch/pull)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ git fetch origin develop              # 只是获取远程仓库的数据至.git目录，并未merge本地</span><br><span class="line">$ git merge origin&#x2F;develop              # 把获取的远程仓库的数据手工merge至当前分支</span><br><span class="line">$ git pull origin develop               # 获取远程仓库的数据，并自动merge至当前的分支，相当于以上两步, git pull &#x3D;&#x3D; git fetch + git merge</span><br><span class="line">$ git pull --rebase                     # 也可以使用git pull的rebase策略</span><br></pre></td></tr></table></figure><h5 id="分支推送"><a href="#分支推送" class="headerlink" title="分支推送"></a>分支推送</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git push -f                           # 强推</span><br><span class="line">$ git push --all                        # 本地所有分支推送到远端</span><br></pre></td></tr></table></figure><h5 id="prune"><a href="#prune" class="headerlink" title="prune"></a>prune</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote prune origin                 # 修剪远程分支</span><br></pre></td></tr></table></figure><h4 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git tag v1.0.0 commit_id              # 新建（标签不能重命名）</span><br><span class="line">$ git tag                               # 查看</span><br><span class="line">$ git show v1.0.0</span><br><span class="line">$ git tag -d v1.0.0                     # 删除</span><br><span class="line">$ git push origin v1.0.0                # 推送标签</span><br><span class="line">$ git push origin --tags</span><br><span class="line">$ git push origin :v1.0.0               # 删除远端标签</span><br><span class="line">$ git checkout -b branch_name tag_name   # 切换到某个tag</span><br></pre></td></tr></table></figure><h4 id="其它操作"><a href="#其它操作" class="headerlink" title="其它操作"></a>其它操作</h4><h5 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#39;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&#39;</span><br><span class="line">之间的内容是我的修改</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">之间的内容是别人的修改</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">一般是删除冲突标记，并解决冲突</span><br></pre></td></tr></table></figure><h5 id="Vi编辑器"><a href="#Vi编辑器" class="headerlink" title="Vi编辑器"></a>Vi编辑器</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ vi filename                       # 创建文件 touch filename</span><br><span class="line">vi编辑: i</span><br><span class="line">按ESC键 跳到命令模式</span><br><span class="line">:wq 是保存退出 </span><br><span class="line">:q! 是不保存强制退出</span><br></pre></td></tr></table></figure><h5 id="硬核配置项目git-git-config文件"><a href="#硬核配置项目git-git-config文件" class="headerlink" title="硬核配置项目git(.git/config文件)"></a>硬核配置项目git(.git/config文件)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">直接打开.git目录下的config文件进行编辑，参考内容如下</span><br><span class="line">[core]</span><br><span class="line">repositoryformatversion &#x3D; 0</span><br><span class="line">filemode &#x3D; true</span><br><span class="line">bare &#x3D; false</span><br><span class="line">logallrefupdates &#x3D; true</span><br><span class="line">ignorecase &#x3D; true</span><br><span class="line">precomposeunicode &#x3D; true</span><br><span class="line">[remote &quot;origin&quot;]</span><br><span class="line">url &#x3D; https:&#x2F;&#x2F;gitee.com&#x2F;ticsmatic_admin&#x2F;CodeStore.git</span><br><span class="line">fetch &#x3D; +refs&#x2F;heads&#x2F;*:refs&#x2F;remotes&#x2F;origin&#x2F;*</span><br><span class="line">[branch &quot;master&quot;]</span><br><span class="line">remote &#x3D; origin</span><br><span class="line">merge &#x3D; refs&#x2F;heads&#x2F;master</span><br><span class="line">[branch &quot;develop&quot;]</span><br><span class="line">remote &#x3D; origin</span><br><span class="line">merge &#x3D; refs&#x2F;heads&#x2F;develop</span><br></pre></td></tr></table></figure><h5 id="单文件回退"><a href="#单文件回退" class="headerlink" title="单文件回退"></a>单文件回退</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset comit_id filename       # 把某个文件回退到某个提交历史，checkout也可以</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>阿里云SSL证书使用</title>
      <link href="/p/2c49c232/"/>
      <url>/p/2c49c232/</url>
      
        <content type="html"><![CDATA[<p>标题</p><a id="more"></a><h1 id="阿里云SSL证书使用"><a href="#阿里云SSL证书使用" class="headerlink" title="阿里云SSL证书使用"></a>阿里云SSL证书使用</h1><p>流程概要<br>购买-&gt;申请证书（提交资料，填入域名、联系方式）-&gt;ssl域名解析验证-&gt;等待审核(大致5分钟)-&gt;审核成功-下载使用</p><h2 id="购买"><a href="#购买" class="headerlink" title="购买"></a>购买</h2><p>采用免费的个人版</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>购买后点击”申请证书“<br>填入资料（域名、联系人、联系方式）<br>提交审核，大约3-20分钟，审核成功<br>然后下载证书（选择需要的证书类型，有Tomcat、Apache、Nginx、IIS等）</p><h2 id="实例（为七牛云配置Https证书）"><a href="#实例（为七牛云配置Https证书）" class="headerlink" title="实例（为七牛云配置Https证书）"></a>实例（为七牛云配置Https证书）</h2><ol><li>购买SSL证书<br>在阿里云购买证书SSL证书</li><li>填写SSL证书申请资料<br>填写申请资料，其中要绑定的域名为<code>cdn.ticsmatic.com</code>，然后验证域名解析，验证成功</li><li>下载证书<br>然后等待证书审核成功，下载Nginx类型的证书（因为七牛云需要的证书格式是pem、key，Nginx服务类型的证书刚好符合）<br>分割线</li><li>使用证书<br>在七牛云的<code>SSL证书服务</code>tab下，上传在阿里云下载的SSL证书</li><li>七牛云添加域名<br>在七牛云的<code>CDN</code>下添加自己的域名<code>cdn.ticsmatic.com</code>，选择已经添加的https证书</li><li>七牛云cname解析<br>添加完域名后，七牛云会提示去对应的域名服务商进行cname域名解析。进入到阿里云的域名解析，解析七牛云的域名。填写cname信息后，去七牛云验证是佛解析成功（一般实时出结果）</li><li>在七牛云中使用自定义的域名<br>在气七牛云的<code>对象存储</code>服务中，绑定自己的域名<code>cdn.ticsmatic.com</code>，然后访问路径下的对象资源时，前缀就是<code>cdn.ticsmatic.com</code></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>使用volantis主题</title>
      <link href="/p/6cb5ab8a/"/>
      <url>/p/6cb5ab8a/</url>
      
        <content type="html"><![CDATA[<p>z</p><a id="more"></a><p>[TOC]</p><p><a href="https://xaoxuu.com/" target="_blank" rel="noopener">演示地址</a></p><p><a href="https://volantis.js.org/" target="_blank" rel="noopener">文档地址</a></p><h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><p><a href="https://volantis.js.org/getting-started/" target="_blank" rel="noopener">开始使用</a><br>第1/3步：下载主题源码到 themes/ 文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;xaoxuu&#x2F;hexo-theme-volantis themes&#x2F;volantis</span><br></pre></td></tr></table></figure><p>第2/3步：修改站点配置文件 blog/_config.yml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: volantis</span><br></pre></td></tr></table></figure><p>第3/3步：检查并安装依赖<br>安装 Hexo 搜索的依赖包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -S hexo-generator-search hexo-generator-json-content</span><br></pre></td></tr></table></figure><p>安装 stylus 渲染器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -S hexo-renderer-stylus</span><br></pre></td></tr></table></figure><h2 id="站点"><a href="#站点" class="headerlink" title="站点"></a>站点</h2><p><a href="https://volantis.js.org/site-settings/" target="_blank" rel="noopener">文档</a></p><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p><a href="https://volantis.js.org/theme-settings/" target="_blank" rel="noopener">文档</a></p><h2 id="页面"><a href="#页面" class="headerlink" title="页面"></a>页面</h2><p><a href="https://volantis.js.org/page-settings/" target="_blank" rel="noopener">文档</a></p><h2 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h2><p><a href="https://volantis.js.org/tag-settings/" target="_blank" rel="noopener">文档</a></p><span class="p red">红色</span><p class="p center logo large">Volantis</p><div class="note"><p>为简单的一句话提供的简便写法。</p></div><div class="checkbox"><input type="radio"><p>纯文本测试</p></div>]]></content>
      
      
      <categories>
          
          <category> ios </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
